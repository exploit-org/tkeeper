package org.exploit.keeper.model.keyset

import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.unit.TimestampUnit
import org.exploit.keeper.exception.TKeeperException
import org.threeten.bp.Instant
import kotlin.math.max

data class KeySetPolicy(
    val apply: NotAfter? = null,
    val process: NotAfter? = null,
    val allowHistoricalProcess: Boolean = true
) {
    fun validate() {
        apply?.validate()
        process?.validate()

        if (apply != null && process != null) {
            val applySeconds = apply.seconds() ?: return
            val processSeconds = process.seconds() ?: return

            if (processSeconds <= applySeconds)
                throw TKeeperException(ErrorType.INVALID_KEY_SET_POLICY, "process must be later than apply")
        }
    }

    data class NotAfter(val unit: TimestampUnit, val notAfter: Long? = null) {
        fun seconds(): Long? = when (unit) {
            TimestampUnit.SECONDS -> notAfter
            TimestampUnit.MILLISECONDS -> notAfter?.div(1000)
        }

        fun expired(): Boolean = seconds()?.let {
            Instant.now().isAfter(Instant.ofEpochSecond(it))
        } ?: false

        fun validate() {
            val now = Instant.now()

            val seconds = seconds()?.let { max(it, 0) }
                ?: return

            val instant = Instant.ofEpochSecond(seconds)

            if (!instant.isAfter(now))
                throw TKeeperException(ErrorType.INVALID_KEY_SET_POLICY, "notAfter must be in the future")
        }
    }
}