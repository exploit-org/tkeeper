package org.exploit.keeper.service.auth.internal

import com.linecorp.armeria.common.HttpRequest
import com.linecorp.armeria.common.HttpResponse
import com.linecorp.armeria.server.DecoratingHttpServiceFunction
import com.linecorp.armeria.server.HttpService
import com.linecorp.armeria.server.ServiceRequestContext
import jakarta.inject.Singleton
import org.exploit.crypto.Hash
import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.controller.support.ControllerSupport
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.extension.crypto.decodeBase64OrNull
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.extension.crypto.toSchnorrSignature
import org.exploit.keeper.extension.getOrSet
import org.exploit.keeper.extension.http.AUTH_ATTRIBUTE_KEY
import org.exploit.keeper.extension.http.auditId
import org.exploit.keeper.extension.http.toQueryMap
import org.exploit.keeper.extension.toKeeperId
import org.exploit.keeper.model.audit.ctx.Auth
import org.exploit.keeper.model.auth.InternalAuthData
import org.exploit.keeper.service.audit.AuditContextService
import org.exploit.keeper.service.boot.KeeperBootService
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.integrity.KeeperSignatureService
import org.exploit.keeper.service.nonce.NonceStore
import org.exploit.keeper.util.path.AntPathMatcher
import org.exploit.tss.signature.SchnorrSignature
import java.security.MessageDigest
import kotlin.math.abs

@Singleton
class InternalAuthenticator(
    private val db: RocksKeyDB,
    private val signer: KeeperSignatureService,
    private val clients: TKeeperClients,
    private val auditCtx: AuditContextService,
    private val support: ControllerSupport,
    private val nonces: NonceStore,
    private val bootProofs: KeeperBootService
) : DecoratingHttpServiceFunction {
    private val ignore: List<AntPathMatcher> = listOf(
        AntPathMatcher("/v1/health/**"),
        AntPathMatcher("/v1/integrity/publicKey")
    )

    private val initData by lazy {
        db.readInitData()
    }

    override fun serve(delegate: HttpService, ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {
        if (ignore.any { it.matches(ctx.path()) })
            return delegate.serve(ctx, req)

        return runCatching {
            val h = parseHeadersOrDeny(ctx, req)
                ?: return deny(ctx)

            if (!validateTargetOrDeny(h))
                return deny(ctx)

            if (!validateTimeNonceOrDeny(h))
                return deny(ctx)

            val client = clients.find(h.instanceId)
                ?: return deny(ctx)

            val verifyKey = selectVerifyKeyOrDeny(client, h)
                ?: return deny(ctx)

            if (!validateKidOrDeny(verifyKey, h))
                return deny(ctx)

            if (!verifyBootProofStrictOrDeny(verifyKey, h))
                return deny(ctx)

            if (!verifySignatureOrDeny(verifyKey, h))
                return deny(ctx)

            pinIfNeeded(client, verifyKey)
            attachAuth(ctx, h.instanceId)
            delegate.serve(ctx, req)
        }.getOrElse { deny(ctx) }
    }

    private fun parseHeadersOrDeny(ctx: ServiceRequestContext, req: HttpRequest): AuthHeaders? {
        val headers = req.headers()
        val instanceId = headers.get(KeeperSignatureService.HEADER_INSTANCE_ID)?.toIntOrNull() ?: return null
        val intendedFor = headers.get(KeeperSignatureService.HEADER_INTENDED_FOR)?.toIntOrNull() ?: return null

        val timestamp = headers.get(KeeperSignatureService.HEADER_TIMESTAMP)?.toLongOrNull() ?: return null
        val nonce = headers.get(KeeperSignatureService.HEADER_NONCE) ?: return null

        val kidBytes = headers.get(KeeperSignatureService.HEADER_KID)?.decodeBase64OrNull() ?: return null

        val pubFromHeader = headers.get(KeeperSignatureService.HEADER_PUBLIC_KEY)
            ?.decodeBase64OrNull()
            ?.let { Ed25519PublicKey(it) }

        val signature = headers.get(KeeperSignatureService.HEADER_SIGNATURE)
            ?.decodeBase64OrNull()
            ?.let { runCatching { it.toSchnorrSignature() }.getOrNull() } ?: return null

        val proof = headers.get(KeeperSignatureService.HEADER_BOOT_PROOF)?.decodeBase64OrNull() ?: return null

        val query = ctx.query()?.toQueryMap() ?: emptyMap()

        return AuthHeaders(
            instanceId = instanceId,
            intendedFor = intendedFor,
            timestamp = timestamp,
            nonce = nonce,
            kidBytes = kidBytes,
            pubFromHeader = pubFromHeader,
            signature = signature,
            proof = proof,
            path = ctx.path(),
            query = query
        )
    }

    private fun validateTargetOrDeny(h: AuthHeaders): Boolean {
        return h.intendedFor == initData.peerId
    }

    private fun validateTimeNonceOrDeny(h: AuthHeaders): Boolean {
        if (abs(System.currentTimeMillis() - h.timestamp) > 30_000)
            return false

        if (!nonces.rememberIfNew(h.nonce))
            return false

        return true
    }

    private fun selectVerifyKeyOrDeny(client: TKeeperClient, h: AuthHeaders): Ed25519PublicKey? {
        val pinned = client.publicKey.get()

        if (pinned != null)
            return pinned

        return h.pubFromHeader
    }

    private fun validateKidOrDeny(verifyKey: Ed25519PublicKey, h: AuthHeaders): Boolean {
        val expectedKid = Hash.sha256(verifyKey.encoded())
        return MessageDigest.isEqual(h.kidBytes, expectedKid)
    }

    private fun verifyBootProofStrictOrDeny(verifyKey: Ed25519PublicKey, h: AuthHeaders): Boolean {
        return bootProofs.verify(
            instanceId = h.instanceId,
            pub = verifyKey.encoded(),
            proof = h.proof,
            timestamp = h.timestamp,
            nonce = h.nonce
        )
    }

    private fun verifySignatureOrDeny(
        verifyKey: Ed25519PublicKey,
        h: AuthHeaders
    ): Boolean {
        val hash = signer.hashForSigning(
            instanceId = h.instanceId,
            intendedFor = h.intendedFor,
            path = h.path,
            query = h.query,
            timestamp = h.timestamp,
            nonce = h.nonce,
            kid64 = h.kidBytes.toBase64(),
            proof64 = h.proof.toBase64()
        )

        return runCatching { Ed25519Provider.getInstance().verify(hash, h.signature, verifyKey) }
            .getOrDefault(false)
    }

    private fun pinIfNeeded(client: TKeeperClient, verifyKey: Ed25519PublicKey) {
        if (client.publicKey.get() == null) {
            client.publicKey.getOrSet { verifyKey }
        }
    }

    private fun attachAuth(ctx: ServiceRequestContext, instanceId: Int) {
        val subject = instanceId.toKeeperId()
        ctx.setAttr(AUTH_ATTRIBUTE_KEY, InternalAuthData(subject))
        ctx.auditId()?.let { rid -> auditCtx.updateIfPresent(rid) { it.auth = Auth(subject) } }
    }

    private fun deny(ctx: ServiceRequestContext): HttpResponse =
        support.finishErrorMsgpack(ctx, ErrorType.ACCESS_DENIED)

    private class AuthHeaders(
        val instanceId: Int,
        val intendedFor: Int,
        val timestamp: Long,
        val nonce: String,
        val kidBytes: ByteArray,
        val pubFromHeader: Ed25519PublicKey?,
        val signature: SchnorrSignature,
        val proof: ByteArray,
        val path: String,
        val query: Map<String, String>
    )
}