package org.exploit.keeper.service.auth

import com.nimbusds.jose.crypto.ECDSAVerifier
import com.nimbusds.jose.crypto.RSASSAVerifier
import com.nimbusds.jose.jwk.ECKey
import com.nimbusds.jose.jwk.JWK
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jwt.SignedJWT
import jakarta.annotation.PreDestroy
import jakarta.ws.rs.NotAuthorizedException
import org.exploit.keeper.model.key.KeyData
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.io.Closeable
import java.io.FileInputStream
import java.net.URI
import java.net.URL
import java.nio.file.Paths
import java.time.Duration
import java.util.concurrent.Executors
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicReference

class JwtMachineAuthenticator(private val jwksLocation: String, refreshDuration: Duration): RequestAuthenticator, Closeable {
    private val jwksCache = JwkCache(jwksLocation, refreshDuration)

    override fun authenticate(token: String): KeyData {
        val signedJWT = parseJwt(token)

        val header = signedJWT.header
        val claims = signedJWT.jwtClaimsSet

        val keyId = header.keyID ?: throw NotAuthorizedException("No Key id (kid) in JWT header")

        val verifier = when (val publicKey = jwksCache.get(keyId)) {
            is RSAKey -> RSASSAVerifier(publicKey)
            is ECKey -> ECDSAVerifier(publicKey)

            else -> throw NotAuthorizedException("Unsupported key type: ${publicKey.javaClass.simpleName}")
        }

        if (!signedJWT.verify(verifier))
            throw NotAuthorizedException("JWT signature verification failed")

        val subject = claims.subject
        val permissions = claims.getStringListClaim("permissions") ?: emptyList()

        return KeyData(subject, permissions)
    }

    @PreDestroy
    override fun close() {
        jwksCache.close()
    }

    private fun parseJwt(token: String): SignedJWT {
        return try {
            SignedJWT.parse(token)
        } catch (e: Exception) {
            throw NotAuthorizedException("Bad JWT")
        }
    }

    private inner class JwkCache(private val location: String, interval: Duration): Closeable {
        private val ref = AtomicReference<JWKSet>()
        private val scheduler: ScheduledExecutorService = Executors.newSingleThreadScheduledExecutor()

        init {
            ref.set(load())

            scheduler.scheduleAtFixedRate(
                { refresh() },
                interval.toMillis(),
                interval.toMillis(),
                TimeUnit.MILLISECONDS
            )
        }

        fun get(keyId: String): JWK =
            ref.get().getKeyByKeyId(keyId)
                ?: throw NotAuthorizedException("JWKS: no key with kid=$keyId")

        private fun load(): JWKSet {
            val uri = URI.create(location)

            return when (uri.scheme?.lowercase()) {
                "http", "https" ->
                    JWKSet.load(URL(jwksLocation))

                "file" ->
                    Paths.get(uri).toFile().let { file ->
                        FileInputStream(file).use { JWKSet.load(it) }
                    }

                null ->
                    FileInputStream(jwksLocation).use { JWKSet.load(it) }

                else ->
                    error("Unsupported URI scheme: ${uri.scheme}")
            }
        }

        private fun refresh() {
            try {
                ref.set(load())
            } catch (e: Exception) {
                LOGGER.error("Failed to reload JWKS: ", e)
            }
        }

        override fun close() {
            scheduler.shutdownNow()
        }
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(JwtMachineAuthenticator::class.java)
    }
}