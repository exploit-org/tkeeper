package org.exploit.keeper.service.auth.decorator

import com.linecorp.armeria.common.HttpRequest
import com.linecorp.armeria.common.HttpResponse
import com.linecorp.armeria.server.DecoratingHttpServiceFunction
import com.linecorp.armeria.server.HttpService
import com.linecorp.armeria.server.ServiceRequestContext
import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType.UNAUTHENTICATED
import org.exploit.keeper.controller.support.ControllerSupport
import org.exploit.keeper.extension.http.AUTH_ATTRIBUTE_KEY
import org.exploit.keeper.extension.http.auditId
import org.exploit.keeper.model.audit.ctx.Auth
import org.exploit.keeper.model.audit.ctx.Outcome
import org.exploit.keeper.service.audit.AuditContextService
import org.exploit.keeper.service.auth.external.ExternalRequestAuthenticator
import org.exploit.keeper.service.auth.external.TokenRequestAuthenticator

@Singleton
class ExternalAuthDecorator(
    private val support: ControllerSupport,
    private val authenticator: ExternalRequestAuthenticator,
    private val auditCtx: AuditContextService
) : DecoratingHttpServiceFunction {

    override fun serve(delegate: HttpService, ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {
        if (authenticator.shouldSkip(ctx.path()))
            return delegate.serve(ctx, req)

        return when (authenticator) {
            is TokenRequestAuthenticator -> handleTokenAuthenticator(authenticator, delegate, ctx, req)

            else -> error("Unsupported ExternalRequestAuthenticator implementation")
        }
    }

    private fun handleTokenAuthenticator(authenticator: TokenRequestAuthenticator, delegate: HttpService, ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {
        val token = authenticator.extract(req.headers())
            ?: return finishNotAuthenticated(ctx)

        val auth = try {
            authenticator.authenticate(token)
        } catch (e: Exception) {
            return finishNotAuthenticated(ctx)
        }

        ctx.setAttr(AUTH_ATTRIBUTE_KEY, auth)
        auditSubject(ctx, auth.subject)

        return delegate.serve(ctx, req)
    }

    private fun finishNotAuthenticated(ctx: ServiceRequestContext): HttpResponse {
        val auditId = ctx.auditId()
        if (auditId != null) {
            auditCtx.updateIfPresent(auditId) {
                it.out = Outcome(
                    statusCode = UNAUTHENTICATED.statusCode,
                    error = UNAUTHENTICATED
                )
            }
        }

        if (!support.finishAndAudit(ctx, UNAUTHENTICATED.statusCode, UNAUTHENTICATED)) {
            return support.auditFailedJson()
        }

        return support.writeJsonError(UNAUTHENTICATED)
    }


    private fun auditSubject(ctx: ServiceRequestContext, subject: String) {
        val auditId = ctx.auditId()

        if (auditId != null) {
            auditCtx.updateIfPresent(auditId) {
                it.auth = Auth(subject)
            }
        }
    }
}