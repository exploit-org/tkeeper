package org.exploit.keeper.service.auth.external

import com.nimbusds.jose.crypto.ECDSAVerifier
import com.nimbusds.jose.crypto.RSASSAVerifier
import com.nimbusds.jose.jwk.ECKey
import com.nimbusds.jose.jwk.JWK
import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import com.nimbusds.jwt.SignedJWT
import org.exploit.keeper.model.auth.AuthData
import org.exploit.keeper.model.auth.SimpleAuthData
import org.slf4j.LoggerFactory
import java.io.Closeable
import java.io.FileInputStream
import java.net.URI
import java.net.URL
import java.nio.file.Paths
import java.time.Duration
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicReference

class JwtMachineAuthenticator(
    jwksLocation: String,
    refreshDuration: Duration
) : ExternalRequestAuthenticator, Closeable {
    private val jwksCache = JwkCache(jwksLocation, refreshDuration)

    override fun authenticate(token: String): AuthData {
        val signedJWT = parseJwt(token)

        val header = signedJWT.header
        val claims = signedJWT.jwtClaimsSet

        val keyId = header.keyID ?: error("No kid in JWT")

        val publicKey = jwksCache.get(keyId)
        val verifier = when (publicKey) {
            is RSAKey -> RSASSAVerifier(publicKey)
            is ECKey -> ECDSAVerifier(publicKey)
            else -> error("Unsupported key type: ${publicKey.javaClass.simpleName}")
        }

        if (!signedJWT.verify(verifier)) {
            error("JWT signature verification failed")
        }

        val subject = claims.subject ?: error("No subject in JWT claims")

        val permissions = claims.getStringListClaim("permissions") ?: emptyList()

        return SimpleAuthData(subject = subject, permissions = permissions)
    }

    override fun close() {
        jwksCache.close()
    }

    private fun parseJwt(token: String): SignedJWT {
        return try {
            SignedJWT.parse(token)
        } catch (e: Exception) {
            error("Bad JWT")
        }
    }

    private class JwkCache(private val location: String, interval: Duration) : Closeable {
        private val ref = AtomicReference<JWKSet>()
        private val scheduler = Executors.newSingleThreadScheduledExecutor()

        init {
            ref.set(load())
            scheduler.scheduleAtFixedRate(
                { refresh() },
                interval.toMillis(),
                interval.toMillis(),
                TimeUnit.MILLISECONDS
            )
        }

        fun get(keyId: String): JWK =
            ref.get().getKeyByKeyId(keyId) ?: error("JWKS: no key with kid=$keyId")

        private fun load(): JWKSet {
            val uri = URI.create(location)
            return when (uri.scheme?.lowercase()) {
                "http", "https" -> JWKSet.load(URL(location))
                "file" -> Paths.get(uri).toFile().inputStream().use { JWKSet.load(it) }
                null -> FileInputStream(location).use { JWKSet.load(it) }
                else -> error("Unsupported URI scheme: ${uri.scheme}")
            }
        }

        private fun refresh() {
            try {
                ref.set(load())
            } catch (e: Exception) {
                LOGGER.error("Failed to reload JWKS", e)
            }
        }

        override fun close() {
            scheduler.shutdownNow()
        }

        companion object {
            private val LOGGER = LoggerFactory.getLogger(JwkCache::class.java)
        }
    }

    companion object {
        const val ID = "jwt"
    }
}

