package org.exploit.keeper.service.event

import jakarta.annotation.PostConstruct
import jakarta.inject.Singleton
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.extension.performSuccessOnly
import org.exploit.keeper.model.event.RoundEndEvent
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.signature.registry.SessionManagerResolver
import org.exploit.signalix.annotations.EventHandler
import org.exploit.signalix.manager.EventScope
import org.exploit.signalix.marker.Listener

@Singleton
class KeeperSessionEventListener(
    private val eventScope: EventScope,
    private val clients: TKeeperClients,
    private val sessionManagers: SessionManagerResolver
): Listener {
    @EventHandler
    fun onRoundEnd(e: RoundEndEvent) {
        clearSession(e.sessionId, e.type)

        clients.forBroadcast(e.participants).performSuccessOnly {
            when (e.type) {
                SessionType.FROST -> it.frost.abort(e.sessionId)
                SessionType.GG20 -> it.gg20.abort(e.sessionId)
            }
        }
    }

    @EventHandler
    fun onClean(e: SessionCleanEvent) {
        clearSession(e.sessionId, e.type)
    }

    private fun clearSession(sid: String, type: SessionType) {
        sessionManagers.findBySessionId(type, sid)?.destroy(sid)
    }

    @PostConstruct
    fun init() {
        eventScope.registerListener(this)
    }
}