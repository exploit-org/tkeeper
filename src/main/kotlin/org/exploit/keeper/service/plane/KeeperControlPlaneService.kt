package org.exploit.keeper.service.plane

import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.PeerState
import org.exploit.keeper.constant.common.StoreState
import org.exploit.keeper.constant.permission.Permission
import org.exploit.keeper.constant.scope.KeyScope
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.extension.performSuccessOnly
import org.exploit.keeper.extension.toKeeperId
import org.exploit.keeper.model.auth.AuthData
import org.exploit.keeper.model.auth.plane.ControlPlaneAuthConfig
import org.exploit.keeper.model.inventory.AssetInventoryItem
import org.exploit.keeper.model.plane.AllowedKey
import org.exploit.keeper.model.plane.AllowedKeySetPage
import org.exploit.keeper.model.plane.AuditInfo
import org.exploit.keeper.model.plane.System
import org.exploit.keeper.service.audit.AuditService
import org.exploit.keeper.service.auth.external.ExternalRequestAuthenticator
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperComplianceService
import org.exploit.keeper.service.core.KeeperService
import kotlin.math.max
import kotlin.math.min

@Singleton
class KeeperControlPlaneService(
    private val db: RocksKeyDB,
    private val audit: AuditService,
    private val clients: TKeeperClients,
    private val keeper: KeeperService,
    private val authenticator: ExternalRequestAuthenticator,
    private val compliance: KeeperComplianceService
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun audit(): AuditInfo {
        return audit.info()
    }

    fun system(): System {
        keeper.ensureInitialized()
        val peers = clients.findAll()

        val peerMap: MutableMap<String, PeerState> = mutableMapOf()
        val succeeded = peers.performSuccessOnly { it.health.status() }

        for (success in succeeded)
            peerMap[success.key.toKeeperId()] = if (success.value.body().ready) PeerState.READY else PeerState.NOT_READY

        val failedPeers = peers.filter { !succeeded.containsKey(it.peerId) }

        for (failed in failedPeers)
            peerMap[failed.peerId.toKeeperId()] = PeerState.UNAVAILABLE

        return System(
            id = initData.peerId.toKeeperId(),
            state = when (keeper.status().state) {
                StoreState.SEALED, StoreState.UNINITIALIZED -> PeerState.NOT_READY
                else -> PeerState.READY
            },
            threshold = initData.threshold,
            totalPeers = initData.total,
            peers = peerMap
        )
    }

    fun authConfig(): ControlPlaneAuthConfig =
        authenticator.controlPlane()

    fun listKeysFor(authData: AuthData, historical: Boolean, assetOwner: String?, logicalId: String?, lastSeen: String?, limit: Int): AllowedKeySetPage {
        keeper.ensureReady()

        val out = ArrayList<AllowedKey>(limit)
        var cursor = lastSeen
        var hasMore = false
        var nextCursor: String? = null

        val fetchBatch = min(500, max(limit * 3, 200))

        while (out.size < limit) {
            val page = compliance.loadAssetInventory(historical, logicalId, assetOwner, cursor, fetchBatch)
            val items = page.inventory.items

            if (items.isEmpty()) {
                hasMore = false
                nextCursor = null
                break
            }

            for (item in items) {
                val allowed = item.toAllowedKey(authData) ?: continue
                out += allowed
                if (out.size == limit) break
            }

            cursor = page.nextCursor
            hasMore = page.hasMore
            nextCursor = cursor

            if (!page.hasMore) break
        }

        return AllowedKeySetPage(out, nextCursor, hasMore)
    }

    private fun AssetInventoryItem.toAllowedKey(authData: AuthData): AllowedKey? {
        val scopes = ArrayList<KeyScope>()

        if (authData.hasPermission(Permission.keySign(logicalId)))
            scopes.add(KeyScope.SIGN)

        if (authData.hasPermission(Permission.keyEncrypt(logicalId)))
            scopes.add(KeyScope.ENCRYPT)

        if (authData.hasPermission(Permission.keyDecrypt(logicalId)))
            scopes.add(KeyScope.DECRYPT)

        if (authData.hasPermission(Permission.keyVerify(logicalId)))
            scopes.add(KeyScope.VERIFY)

        if (authData.hasPermission(Permission.keyGetPublicKey(logicalId)))
            scopes.add(KeyScope.PUBLIC)

        if (authData.hasPermission(Permission.keyDestroy(logicalId)))
            scopes.add(KeyScope.DESTROY)

        if (scopes.isEmpty())
            return null

        return AllowedKey(
            curve = curve,
            logicalId = logicalId,
            generation = currentGeneration,
            status = status,
            scopes = scopes
        )
    }
}