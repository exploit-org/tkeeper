package org.exploit.keeper.service.signature.frost

import jakarta.annotation.PreDestroy
import jakarta.inject.Singleton
import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.LMKDB
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toBigInt
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.PublicKeyDto
import org.exploit.keeper.service.misc.CurvePointDecoder
import org.exploit.keeper.service.signature.ThresholdSessionFactory
import org.exploit.threshield.curve.PointOps
import org.exploit.threshield.frost.FrostClient
import org.exploit.threshield.frost.context.FrostContext
import org.exploit.threshield.frost.context.commitment.InMemoryCommitmentContext
import org.exploit.threshield.frost.context.crypto.InMemoryCryptoContext
import org.exploit.threshield.frost.context.signature.InMemorySignatureAggregatorContext
import java.util.concurrent.TimeUnit

@Singleton
class FrostSessionFactory(
    private val keyDb: LMKDB,
    private val config: KeeperConfig,
    private val decoder: CurvePointDecoder
) : ThresholdSessionFactory<FrostSessionClient<out PointOps<*>>> {
    private val sessionMap = InMemoryTemporaryMap<String, FrostSessionClient<out PointOps<*>>>(
        config.session().frost().expire().seconds, TimeUnit.SECONDS
    )

    override fun <P : PointOps<P>> createSession(
        sessionId: String,
        keyId: String,
        operations: Operations,
        publicKey: PublicKeyDto,
        participants: List<Int>,
        curve: KeeperCurve<P>
    ): FrostSessionClient<out PointOps<*>> {
        if (!participants.contains(config.idx()))
            throw BadRequestException("Service is not participant")

        val keyShare = keyDb.private.get(keyId)?.toPrivateKey()
            ?: throw BadRequestException("Private Key not found")

        if (keyShare.curve != curve.name)
            throw BadRequestException("Curve mismatch for key $keyId")

        val relatedPublicKey = decoder.decode(curve.params, publicKey.data64.decodeBase64())

        val context = FrostContext.newBuilder(curve.opsClass.java)
            .operations(operations.values)
            .aggregator(InMemorySignatureAggregatorContext())
            .commitment(InMemoryCommitmentContext())
            .crypto(InMemoryCryptoContext.newBuilder<P>()
                .idx(config.idx())
                .ski(keyShare.ski.toBigInt())
                .Y(relatedPublicKey as PointOps<P>)
                .curve(curve.params)
                .participants(participants)
                .build()
            )
            .build()

        return FrostSessionClient<P>(FrostClient(sessionId, context), operations.values, curve)
            .also {
                sessionMap.put(sessionId, it)
            }
    }

    @Suppress("UNCHECKED_CAST")
    override fun <P : PointOps<P>> session(sessionId: String): FrostSessionClient<P> {
        val session = sessionMap.get(sessionId) ?: throw BadRequestException("Session not found")
        return session as FrostSessionClient<P>
    }

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)
    }

    override fun type(): SessionType {
        return SessionType.FROST
    }

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }
}