package org.exploit.keeper.service.signature.verify

import jakarta.inject.Singleton
import org.exploit.crypto.curve.Secp256k1Provider
import org.exploit.crypto.key.ECPublicKey
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.SignatureType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodePublicKey
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.secp256k1.Secp256k1PointOps
import org.exploit.tss.signature.ECDSASignature
import org.exploit.tss.signature.Signature

@Singleton
@Suppress("UNCHECKED_CAST")
class ECDSASecp256k1SignatureVerifier(private val pub: PublicKeyService): SignatureVerifier {
    override fun verify(keyId: String, data: ByteArray, signature: Signature, generation: Int, context: SignatureContext?): Boolean {
        val pub = pub.getPublicKey(keyId, generation)
        val decoded = decodePublicKey(curve(), pub.data) as ECPublicKey<Secp256k1PointOps>

        return Secp256k1Provider.getInstance().verify(data, signature, decoded)
    }

    override fun createSignature(bytes: ByteArray): Signature {
        if (bytes.size != 65) {
            throw TKeeperException(ErrorType.INVALID_ECDSA_SIGNATURE)
        }

        val r = bytes.copyOfRange(0, 32)
        val s = bytes.copyOfRange(32, 64)
        val recId = bytes[64]

        return ECDSASignature(r, s, recId)
    }

    override fun curve(): CurveName = CurveName.SECP256K1

    override fun type(): SignatureType = SignatureType.ECDSA
}