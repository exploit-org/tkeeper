package org.exploit.keeper.service.signature.gg20

import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.gg20.commitment.GG20GammaCommitmentDto
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.commitment.GammaCommitment

class GG20CommitmentHandler<P : WeierstrassPointOps<P>>(
    private val sessionFactory: GG20SessionManager<P>,
    private val clients: TKeeperClients
) {
    fun broadcastGammaCommitment(sessionId: String): Round<Void> {
        val session = sessionFactory.session(sessionId).client
        val commitment = session.context().crypto().ephemeral().commitment
        val r = session.context().crypto().ephemeral().r_i
        val dto = GG20GammaCommitmentDto(r, commitment.encode(true))

        val peers = clients.forBroadcast(session.context().crypto().participants())

        val (_, dead) = peers.performAndReturnDead { it.gg20.storeCommitment(sessionId, dto) }

        return Round(null, dead = dead, restart = dead.isNotEmpty())
    }

    fun storeCommitment(sessionId: String, idx: Int, commitment: GG20GammaCommitmentDto) {
        val session = sessionFactory.session(sessionId)

        val point = commitment.point.let {
            session.client.context().crypto().curve()
                .decodePoint(it)
        }

        session.client.context().integrity().storeGammaCommitment(idx, GammaCommitment(point, commitment.r))
    }
}