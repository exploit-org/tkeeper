package org.exploit.keeper.service.signature.gg20

import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.gg20.commitment.GG20GammaCommitmentDto
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.commitment.GammaCommitment
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class GG20CommitmentHandler<P : WeierstrassPointOps<P>>(
    private val sessionFactory: GG20SessionManager<P>,
    private val clients: TKeeperClients
) {
    fun broadcastGammaCommitment(sessionId: String): Mono<Void> {
        val session = sessionFactory.session(sessionId).client
        val commitment = session.context().crypto().ephemeral().commitment
        val r = session.context().crypto().ephemeral().r_i
        val dto = GG20GammaCommitmentDto(r, commitment.encode(true).toBase64())

        val peers = clients.forBroadcast(session.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap { it.gg20.storeCommitment(sessionId, dto).toMono()
                .flatMap { r -> r.successOrThrow() }
            }
            .then()
    }

    fun storeCommitment(sessionId: String, idx: Int, commitment: GG20GammaCommitmentDto) {
        val session = sessionFactory.session(sessionId)

        val point = commitment.point64.let {
            session.client.context().crypto().curve()
                .decodePoint(it.decodeBase64())
        }

        session.client.context().integrity().storeGammaCommitment(idx, GammaCommitment(point, commitment.r))
    }
}