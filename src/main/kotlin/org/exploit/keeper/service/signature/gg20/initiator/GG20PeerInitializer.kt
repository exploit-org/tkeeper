package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.extension.context
import org.exploit.keeper.extension.succeed
import org.exploit.keeper.extension.wait
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.tss.curve.ec.WeierstrassPointOps
import java.util.concurrent.CompletableFuture

class GG20PeerInitializer<P : WeierstrassPointOps<P>>(
    private val peerId: Int,
    private val factory: GG20SessionManager<P>,
    private val pubKeyService: PublicKeyService
) {
    fun init(clients: List<TKeeperClient>, sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>, context: SignatureContext?) {
        val pub = pubKeyService.getPublicKey(keyId)
        val aad = context(keyId, sessionId)
        val participants = clients.map { client -> client.peerId } + peerId

        val session = factory.createSession(sessionId, keyId, operations.values, pub, participants, aad)

        val body = InitSession(
            sessionId = sessionId,
            keyId = keyId,
            publicKey = pub,
            operations = operations.values,
            participants = session.client.context().crypto().participants(),
            curve = curve.name,
            additionalContext = aad,
            context = context
        )

        val futures = ArrayList<CompletableFuture<Void>>()

        for (client in clients) {
            futures.add(client.gg20.init(body).succeed())
        }

        futures.wait()
    }
}