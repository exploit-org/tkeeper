package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.OperationsDto
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.tss.curve.ec.WeierstrassPointOps
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class GG20PeerInitializer<P : WeierstrassPointOps<P>>(
    private val peerId: Int,
    private val factory: GG20SessionManager<P>,
    private val pubKeyService: PublicKeyService
) {
    fun init(clients: List<TKeeperClient>, sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>): Mono<List<TKeeperClient>> {
        return pubKeyService.getPublicKey(keyId)
            .flatMap { pub ->
                val session = factory.createSession(sessionId, keyId, operations, pub, (clients.map { client -> client.peerId } + peerId))

                val body = InitSession(
                    sessionId = sessionId,
                    keyId = keyId,
                    publicKey = pub,
                    operations = OperationsDto(operations.values.mapValues { it.value.toBase64() }),
                    participants = session.client.context().crypto().participants(),
                    curve = curve.name
                )

                Flux.fromIterable(clients)
                    .flatMap {
                        it.gg20.init(body).toMono()
                            .flatMap { r -> r.successOrThrow() }
                            .thenReturn(it)
                    }
                    .collectList()
            }

    }
}