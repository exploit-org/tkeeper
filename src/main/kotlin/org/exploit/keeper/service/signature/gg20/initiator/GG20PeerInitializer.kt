package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.extension.context
import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.tss.curve.ec.WeierstrassPointOps

class GG20PeerInitializer<P : WeierstrassPointOps<P>>(
    private val peerId: Int,
    private val factory: GG20SessionManager<P>,
    private val pubKeyService: PublicKeyService
) {
    fun init(clients: List<TKeeperClient>, sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>, tweak: String?): Round<Void> {
        val pub = pubKeyService.getPublicKey(keyId, tweak = tweak)
        val aad = context(keyId, sessionId)
        val participants = clients.map { client -> client.peerId } + peerId

        val session = factory.createSession(sessionId, keyId, operations.values, pub, participants, aad, null, tweak)

        val body = InitSession(
            sessionId = sessionId,
            keyId = keyId,
            publicKey = pub,
            operations = operations.values,
            participants = session.client.context().crypto().participants(),
            curve = curve.name,
            additionalContext = aad,
            context = null,
            tweak = tweak
        )

        val (_, dead) = clients.performAndReturnDead { it.gg20.init(body) }

        return Round(null, dead = dead, restart = dead.isNotEmpty())
    }
}