package org.exploit.keeper.service.signature.gg20.initiator

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.BitKeeperClient
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.OperationsDto
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.gg20.GG20SessionFactory
import org.exploit.threshield.curve.PointOps
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class GG20PeerInitializer(
    private val config: KeeperConfig,
    private val factory: GG20SessionFactory,
    private val pubKeyService: PublicKeyService
) {
    fun <P : PointOps<P>> init(clients: List<BitKeeperClient>, sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>): Mono<List<BitKeeperClient>> {
        return pubKeyService.getPublicKey(keyId)
            .flatMap { pub ->
                val session = factory.createSession(sessionId, keyId, operations, pub, (clients.map { client -> client.peerId } + config.idx()), curve)

                val body = InitSession(
                    sessionId = sessionId,
                    keyId = keyId,
                    publicKey = pub,
                    operations = OperationsDto(operations.values.mapValues { it.value.toBase64() }),
                    participants = session.client.context().crypto().participants(),
                    curve = curve.name
                )

                Flux.fromIterable(clients)
                    .flatMap {
                        it.gg20.init(body).toMono().thenReturn(it)
                    }
                    .collectList()
            }

    }
}