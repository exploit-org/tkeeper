package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.constant.crypto.SignatureType
import org.exploit.keeper.constant.crypto.TSSCode
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toKeeperList
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.ThresholdSignature
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.event.RoundEndEvent
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.signature.SignatureService
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.ec.WeierstrassPointOps

class GG20SignatureService<P : WeierstrassPointOps<P>>(
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val peerInitializer: GG20PeerInitializer<P>,
    private val commitmentBroadcaster: GG20CommitmentBroadcaster<P>,
    private val mtaInitiator: GG20MtAInitiator<P>,
    private val offlinePhaseCollector: GG20OfflinePhaseCollector<P>,
    private val finalizer: GG20SignatureFinalizer<P>,
    private val eventScope: EventScope
): SignatureService<P> {
    override fun sign(sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>, context: SignatureContext?, lastRound: Round<ThresholdSignature>?): Round<ThresholdSignature> {
        operations.ensureAll32Bytes()

        val imposters = lastRound?.imposters ?: emptySet()
        val dead = lastRound?.dead ?: emptySet()

        val currentGen = db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        val clients = clients.findThreshold(exclude = imposters + dead)

        try {
            val initRound = round(sessionId, imposters, dead, clients) {
                peerInitializer.init(clients, sessionId, keyId, operations, curve, context)
            }

            if (initRound.restart)
                return initRound

            val broadcastRound = round(sessionId, imposters, dead, clients) {
                commitmentBroadcaster.broadcast(clients, sessionId)
            }

            if (broadcastRound.restart)
                return broadcastRound

            val mtaRound = round(sessionId, imposters, dead, clients) {
                mtaInitiator.startMtA(clients, sessionId)
            }

            if (mtaRound.restart)
                return mtaRound

            val collectRound = round(sessionId, imposters, dead, clients) {
                offlinePhaseCollector.collect(clients, sessionId)
            }

            if (collectRound.restart)
                return collectRound

            val sigRound = finalizer.completeSignature(clients, sessionId)

            if (sigRound.restart) {
                clearSession(sessionId, clients)
                return Round(
                    null,
                    imposters = imposters + sigRound.imposters,
                    dead = dead + sigRound.dead,
                    restart = true
                )
            }

            val computed = requireNotNull(sigRound.value)

            return Round(
                ThresholdSignature(
                    code = TSSCode.SUCCESS,
                    type = SignatureType.ECDSA,
                    signature = computed,
                    generation = currentGen,
                    imposters = imposters.toKeeperList()
                )
            )
        } catch (e: Exception) {
            clearSession(sessionId, clients)

            if (e is TKeeperException)
                throw TKeeperException(e.errorType, details = e.details, imposters = imposters, dead = dead)

            throw TKeeperException(ErrorType.INTERNAL_ERROR, imposters = imposters, dead = dead, cause = e)
        }
    }

    private fun round(sid: String, knownImposters: Set<Int>, knownDead: Set<Int>, clients: List<TKeeperClient>, func: () -> Round<*>): Round<ThresholdSignature> {
        val r = func.invoke()

        if (r.restart) {
            clearSession(sid, clients)
            return Round(null, imposters = knownImposters + r.imposters, dead = knownDead + r.dead, restart = true)
        }

        return Round(null)
    }

    private fun clearSession(id: String, clients: List<TKeeperClient>) {
        eventScope.call(RoundEndEvent(id, SessionType.GG20, clients.map { it.peerId }))
    }
}