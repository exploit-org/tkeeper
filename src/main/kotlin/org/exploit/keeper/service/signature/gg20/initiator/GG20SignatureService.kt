package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.signature.SignatureService
import org.exploit.keeper.util.ErrorHandlers
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.ec.WeierstrassPointOps

class GG20SignatureService<P : WeierstrassPointOps<P>>(
    private val clients: TKeeperClients,
    private val peerInitializer: GG20PeerInitializer<P>,
    private val commitmentBroadcaster: GG20CommitmentBroadcaster<P>,
    private val mtaInitiator: GG20MtAInitiator<P>,
    private val offlinePhaseCollector: GG20OfflinePhaseCollector<P>,
    private val finalizer: GG20SignatureFinalizer<P>,
    private val eventScope: EventScope
): SignatureService<P> {
    override fun sign(sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>): TSSResult {
        try {
            val clients = clients.findThreshold()

            peerInitializer.init(clients, sessionId, keyId, operations, curve)
            commitmentBroadcaster.broadcast(clients, sessionId)
            mtaInitiator.startMtA(clients, sessionId)
            offlinePhaseCollector.collect(clients, sessionId)

            val signature = finalizer.completeSignature(clients, sessionId)
            eventScope.call(SessionCleanEvent(sessionId, SessionType.GG20))

            return TSSResult.success(signature)
        } catch (e: Exception) {
            ErrorHandlers.handleAbort(sessionId, SessionType.GG20, eventScope, e)
            return TSSResult.failed()
        }
    }
}