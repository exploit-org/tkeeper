package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.constant.crypto.SignatureType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.ThresholdSignature
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperComplianceService
import org.exploit.keeper.service.signature.SignatureService
import org.exploit.keeper.util.ErrorHandlers
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.ec.WeierstrassPointOps

class GG20SignatureService<P : WeierstrassPointOps<P>>(
    private val compliance: KeeperComplianceService,
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val peerInitializer: GG20PeerInitializer<P>,
    private val commitmentBroadcaster: GG20CommitmentBroadcaster<P>,
    private val mtaInitiator: GG20MtAInitiator<P>,
    private val offlinePhaseCollector: GG20OfflinePhaseCollector<P>,
    private val finalizer: GG20SignatureFinalizer<P>,
    private val eventScope: EventScope
): SignatureService<P> {
    override fun sign(sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>, context: SignatureContext?): ThresholdSignature {
        operations.ensureAll32Bytes()

        val currentGen = db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        if (!compliance.allowedForApplyOperations(keyId))
            throw TKeeperException(ErrorType.KEY_APPLY_OPS_FORBIDDEN, keyId)

        val clients = clients.findThreshold()

        try {
            peerInitializer.init(clients, sessionId, keyId, operations, curve, context)
            commitmentBroadcaster.broadcast(clients, sessionId)
            mtaInitiator.startMtA(clients, sessionId)
            offlinePhaseCollector.collect(clients, sessionId)

            val signature = finalizer.completeSignature(clients, sessionId)
            eventScope.call(SessionCleanEvent(sessionId, SessionType.GG20))

            return ThresholdSignature.success(signature, SignatureType.ECDSA,currentGen)
        } catch (e: Exception) {
            ErrorHandlers.handleAbort(sessionId, SessionType.GG20, eventScope, e)
            return ThresholdSignature.failed(currentGen, SignatureType.ECDSA)
        }
    }
}