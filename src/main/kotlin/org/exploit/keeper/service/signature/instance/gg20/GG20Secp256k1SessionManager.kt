package org.exploit.keeper.service.signature.instance.gg20

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.db.LMKDB
import org.exploit.keeper.extension.unwrap
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.request.Sign
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.keeper.service.signature.instance.SessionManagerInstance
import org.exploit.secp256k1.Secp256k1PointOps
import org.exploit.signalix.manager.EventScope

@Singleton
class GG20Secp256k1SessionManager(
    keyDb: LMKDB, config: KeeperConfig,
    clients: BitKeeperClients, pubKey: PublicKeyService,
    eventScope: EventScope
): GG20SessionManager<Secp256k1PointOps>(
    keyDb, config, KeeperCurve.SECP256K1,
    clients, pubKey, eventScope
), SessionManagerInstance {
    override fun curve(): CurveName {
        return CurveName.SECP256K1
    }

    override fun sign(sign: Sign): Uni<TSSResult> {
        return initiator.signature.sign(
            sessionId = sign.sessionId,
            keyId = sign.keyId,
            operations = sign.operations.unwrap(),
            curve = curve
        )
    }

    override fun session(): SessionType {
        return SessionType.GG20
    }

    override fun hasSessionId(sessionId: String): Boolean {
        return sessionMap.containsKey(sessionId)
    }

    override fun destroy(sessionId: String) {
        sessionMap.get(sessionId)?.client?.destroy()
    }
}