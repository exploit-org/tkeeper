package org.exploit.keeper.service.signature.gg20

import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.model.gg20.commitment.GG20ChaumPedersonCommitmentDto
import org.exploit.keeper.model.gg20.commitment.GG20OfflinePhaseData
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.ec.WeierstrassCurveParams
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitment
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitmentWithValue
import org.exploit.tss.proof.model.ChaumPedersenProof

class GG20OfflinePhaseHandler<P : WeierstrassPointOps<P>>(
    private val eventScope: EventScope,
    private val clients: TKeeperClients,
    private val sessionFactory: GG20SessionManager<P>
) {
    fun broadcast(sessionId: String): Round<Void> {
        val session = sessionFactory.session(sessionId).client
        val gamma = session.context().crypto().ephemeral().Gamma_i

        val delta = session.signature().computeDeltaShare()
        val lambda = session.integrity().computeLambdaI()
        val sigma = session.integrity().computeSigmaCommitment()

        val broadcast = GG20OfflinePhaseData(
            gamma = gamma.encode(true),
            delta = delta,
            lambda = lambda.dto(),
            sigma = sigma.dto()
        )

        val peers = clients.forBroadcast(session.context().crypto().participants())

        val (_, dead) = peers.performAndReturnDead { it.gg20.storeOfflinePhase(sessionId, broadcast) }

        return Round(null, dead = dead, restart = dead.isNotEmpty())
    }

    fun store(sessionId: String, idx: Int, data: GG20OfflinePhaseData) {
        val session = sessionFactory.session(sessionId)
        val params = session.client.context().crypto().curve()

        val gammaPoint = data.gamma.let {
            params.decodePoint(it)
        }

        val lambda = data.lambda.unwrapValue(params)
        val sigma = data.sigma.unwrap(params)

        try {
            session.client.signature().storeGamma(idx, gammaPoint)
            session.client.integrity().storeLambdaCommitment(idx, lambda)
            session.client.integrity().storeSigmaCommitment(idx, sigma)
            session.client.context().signature().storeDeltaShare(idx, data.delta)
        } catch (_: Exception) {
            eventScope.call(SessionCleanEvent(sessionId, SessionType.GG20))
            throw TKeeperException(ErrorType.IMPOSTER_FOUND, imposters = setOf(idx))
        }
    }

    private fun GG20ChaumPedersonCommitmentDto.unwrap(curve: WeierstrassCurveParams<P>) = ChaumPedersenCommitment(
        curve.decodePoint(tpoint), ChaumPedersenProof(curve.decodePoint(proof.a), proof.r, proof.s)
    )

    private fun GG20ChaumPedersonCommitmentDto.unwrapValue(curve: WeierstrassCurveParams<P>) = ChaumPedersenCommitmentWithValue(
        unwrap(curve), value?.let { curve.decodePoint(it) }
            ?: throw TKeeperException(ErrorType.INVALID_REQUEST_BODY, "Chaum pederson commitment value is missing")
    )
}