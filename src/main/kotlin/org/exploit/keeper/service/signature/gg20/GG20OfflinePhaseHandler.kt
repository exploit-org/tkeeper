package org.exploit.keeper.service.signature.gg20

import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.extension.*
import org.exploit.keeper.model.gg20.commitment.GG20ChaumPedersonCommitmentDto
import org.exploit.keeper.model.gg20.commitment.GG20OfflinePhaseData
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.tss.curve.ec.WeierstrassCurveParams
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.commitment.ChaumPedersenProof
import org.exploit.tss.ecdsa.commitment.ChaumPedersonCommitment
import org.exploit.tss.ecdsa.commitment.ChaumPedersonCommitmentWithValue
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class GG20OfflinePhaseHandler<P : WeierstrassPointOps<P>>(
    private val clients: BitKeeperClients,
    private val sessionFactory: GG20SessionManager<P>
) {
    fun broadcast(sessionId: String): Mono<Void> {
        val session = sessionFactory.session(sessionId).client
        val gamma = session.context().crypto().ephemeral().Gamma_i

        val delta = session.signature().computeDeltaShare()
        val lambda = session.integrity().computeLambdaI()
        val sigma = session.integrity().computeSigmaCommitment()

        val broadcast = GG20OfflinePhaseData(
            gamma64 = gamma.encode(true).toBase64(),
            delta = delta,
            lambda = lambda.dto(),
            sigma = sigma.dto()
        )

        val peers = clients.forBroadcast(session.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap { it.gg20.storeOfflinePhase(sessionId, broadcast).toMono()
                .flatMap { r -> r.successOrThrow() }
            }
            .then()
    }

    fun store(sessionId: String, idx: Int, data: GG20OfflinePhaseData) {
        val session = sessionFactory.session(sessionId)
        val params = session.client.context().crypto().curve()

        val gammaPoint = data.gamma64.let {
            params.decodePoint(it.decodeBase64())
        }

        val lambda = data.lambda.unwrapValue(params)
        val sigma = data.sigma.unwrap(params)

        session.client.signature().storeGamma(idx, gammaPoint)
        session.client.integrity().storeLambdaCommitment(idx, lambda)
        session.client.integrity().storeSigmaCommitment(idx, sigma)
        session.client.context().signature().storeDeltaShare(idx, data.delta)
    }

    private fun GG20ChaumPedersonCommitmentDto.unwrap(curve: WeierstrassCurveParams<P>) = ChaumPedersonCommitment(
        curve.decodePoint(tpoint64.decodeBase64()), t,
        ChaumPedersenProof(curve.decodePoint(proof.A64.decodeBase64()), proof.r, proof.s)
    )

    private fun GG20ChaumPedersonCommitmentDto.unwrapValue(curve: WeierstrassCurveParams<P>) = ChaumPedersonCommitmentWithValue(
        unwrap(curve), value64?.let { curve.decodePoint(it.decodeBase64()) } ?: throw BadRequestException("Chaum pederson doesn't contain value")
    )
}