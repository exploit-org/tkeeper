package org.exploit.keeper.service.signature.gg20

import jakarta.inject.Singleton
import jakarta.ws.rs.BadRequestException
import org.bouncycastle.math.ec.ECCurve
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.gg20.commitment.GG20ChaumPedersonCommitmentDto
import org.exploit.keeper.model.gg20.commitment.GG20OfflinePhaseData
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.threshield.curve.jce.ECCurveParams
import org.exploit.threshield.curve.jce.ECPointOps
import org.exploit.threshield.ecdsa.commitment.ChaumPedersenProof
import org.exploit.threshield.ecdsa.commitment.ChaumPedersonCommitment
import org.exploit.threshield.ecdsa.commitment.ChaumPedersonCommitmentWithValue
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class GG20OfflinePhaseHandler(
    private val clients: BitKeeperClients,
    private val sessionFactory: GG20SessionFactory
) {
    fun broadcast(sessionId: String): Mono<Void> {
        val session = sessionFactory.session(sessionId).client
        val gamma = session.context().crypto().ephemeral().Gamma_i.dto()

        val delta = session.signature().computeDeltaShare()
        val lambda = session.integrity().computeLambdaI()
        val sigma = session.integrity().computeSigmaCommitment()

        val broadcast = GG20OfflinePhaseData(
            gamma = gamma,
            delta = delta,
            lambda = lambda.dto(),
            sigma = sigma.dto()
        )

        val peers = clients.forBroadcast(session.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap { it.gg20.storeOfflinePhase(sessionId, broadcast).toMono() }
            .then()
    }

    fun store(sessionId: String, idx: Int, data: GG20OfflinePhaseData) {
        val session = sessionFactory.session(sessionId)
        val params = session.client.context().crypto().curve() as ECCurveParams

        val gammaPoint = data.gamma.let {
            params.x9ECParameters.curve.createPoint(it.x, it.y)
        }

        val lambda = data.lambda.unwrapValue(params.x9ECParameters.curve)
        val sigma = data.sigma.unwrap(params.x9ECParameters.curve)

        session.client.signature().storeGamma(idx, gammaPoint)
        session.client.integrity().storeLambdaCommitment(idx, lambda)
        session.client.integrity().storeSigmaCommitment(idx, sigma)
        session.client.context().signature().storeDeltaShare(idx, data.delta)
    }

    private fun GG20ChaumPedersonCommitmentDto.unwrap(curve: ECCurve) = ChaumPedersonCommitment(
        curve.createPoint(tpoint.x, tpoint.y), t,
        ChaumPedersenProof(curve.createPoint(proof.A.x, proof.A.y), proof.r, proof.s)
    )

    private fun GG20ChaumPedersonCommitmentDto.unwrapValue(curve: ECCurve) = ChaumPedersonCommitmentWithValue(
        unwrap(curve),
        value?.let {
            ECPointOps(curve.createPoint(it.x, it.y))
        } ?: throw BadRequestException("Chaum pederson doesn't contain value")
    )

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(GG20OfflinePhaseHandler::class.java)
    }
}