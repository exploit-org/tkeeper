package org.exploit.keeper.service.signature.gg20

import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.gg20.commitment.GG20ChaumPedersonCommitmentDto
import org.exploit.keeper.model.gg20.commitment.GG20OfflinePhaseData
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.tss.curve.ec.WeierstrassCurveParams
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitment
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitmentWithValue
import org.exploit.tss.proof.model.ChaumPedersenProof
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class GG20OfflinePhaseHandler<P : WeierstrassPointOps<P>>(
    private val clients: TKeeperClients,
    private val sessionFactory: GG20SessionManager<P>
) {
    fun broadcast(sessionId: String): Mono<Void> {
        val session = sessionFactory.session(sessionId).client
        val gamma = session.context().crypto().ephemeral().Gamma_i

        val delta = session.signature().computeDeltaShare()
        val lambda = session.integrity().computeLambdaI()
        val sigma = session.integrity().computeSigmaCommitment()

        val broadcast = GG20OfflinePhaseData(
            gamma = gamma.encode(true),
            delta = delta,
            lambda = lambda.dto(),
            sigma = sigma.dto()
        )

        val peers = clients.forBroadcast(session.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap { it.gg20.storeOfflinePhase(sessionId, broadcast).toMono()
                .flatMap { r -> r.successOrThrow() }
            }
            .then()
    }

    fun store(sessionId: String, idx: Int, data: GG20OfflinePhaseData) {
        val session = sessionFactory.session(sessionId)
        val params = session.client.context().crypto().curve()

        val gammaPoint = data.gamma.let {
            params.decodePoint(it)
        }

        val lambda = data.lambda.unwrapValue(params)
        val sigma = data.sigma.unwrap(params)

        session.client.signature().storeGamma(idx, gammaPoint)
        session.client.integrity().storeLambdaCommitment(idx, lambda)
        session.client.integrity().storeSigmaCommitment(idx, sigma)
        session.client.context().signature().storeDeltaShare(idx, data.delta)
    }

    private fun GG20ChaumPedersonCommitmentDto.unwrap(curve: WeierstrassCurveParams<P>) = ChaumPedersenCommitment(
        curve.decodePoint(tpoint), ChaumPedersenProof(curve.decodePoint(proof.a), proof.r, proof.s)
    )

    private fun GG20ChaumPedersonCommitmentDto.unwrapValue(curve: WeierstrassCurveParams<P>) = ChaumPedersenCommitmentWithValue(
        unwrap(curve), value?.let { curve.decodePoint(it) } ?: throw BadRequestException("Chaum pederson doesn't contain value")
    )
}