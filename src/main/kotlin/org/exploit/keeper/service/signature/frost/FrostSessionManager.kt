package org.exploit.keeper.service.signature.frost

import jakarta.annotation.PreDestroy
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.toBigInt
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.RawPublicKeyDto
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.pub.commits.KeeperCommitmentService
import org.exploit.keeper.service.signature.ThresholdSessionFactory
import org.exploit.keeper.service.signature.frost.initiator.FrostPeerBroadcaster
import org.exploit.keeper.service.signature.frost.initiator.FrostPeerInitializer
import org.exploit.keeper.service.signature.frost.initiator.FrostSignatureFinalizer
import org.exploit.keeper.service.signature.frost.initiator.FrostSignatureService
import org.exploit.keeper.util.TKeeperTweak
import org.exploit.keeper.util.temporary.InMemoryTemporaryMap
import org.exploit.signalix.manager.EventScope
import org.exploit.sodium.ReadOnlyBuffer
import org.exploit.sodium.SecretBox
import org.exploit.tss.curve.PointOps
import org.exploit.tss.frost.FrostClient
import org.exploit.tss.frost.context.FrostContext
import org.exploit.tss.frost.context.commitment.InMemoryCommitmentContext
import org.exploit.tss.frost.context.crypto.InMemoryCryptoContext
import org.exploit.tss.frost.context.signature.InMemorySignatureAggregatorContext
import java.util.concurrent.TimeUnit

abstract class FrostSessionManager<P : PointOps<P>>(
    private val commitments: KeeperCommitmentService,
    private val memKey: ReadOnlyBuffer,
    private val keyDb: RocksKeyDB,

    protected val config: KeeperConfig,
    protected val curve: KeeperCurve<P>,
    protected val clients: TKeeperClients,
    protected val pubKey: PublicKeyService,
    protected val eventScope: EventScope
) : ThresholdSessionFactory<FrostSessionClient<P>, P> {
    protected val sessionMap = InMemoryTemporaryMap<String, FrostSessionClient<P>>(
        config.session.frost.expire.seconds, TimeUnit.SECONDS
    )

    private val initData by lazy {
        keyDb.readInitData()
    }

    val respondent = Respondent()
    val initiator = Initiator()

    override fun createSession(
        sessionId: String,
        keyId: String,
        operations: Map<String, ByteArray>,
        publicKey: RawPublicKeyDto,
        participants: List<Int>,
        additionalContext: ByteArray,
        context: SignatureContext?,
        tweak: String?
    ): FrostSessionClient<P> {
        val peerId = initData.peerId

        if (!participants.contains(peerId))
            throw TKeeperException(ErrorType.NOT_PARTICIPANT)

        val keyShare = keyDb.vault.readCurrentKey(keyId)?.toPrivateKey()
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        val currentGen = keyDb.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, "Not latest key gen info: $keyId")

        if (keyShare.curve != curve.name)
            throw TKeeperException(ErrorType.CURVE_MISMATCH)

        val relatedPublicKey = curve.params.decodePoint(publicKey.data)

        val ski = if (tweak.isNullOrBlank()) keyShare.ski else {
            TKeeperTweak.tweak(keyShare.ski.toBigInt(), keyId.toByteArray(), curve.name, tweak, curve.params.curveOrder)
                .toUnsignedByteArray(curve.keySize())
        }

        val frostContext = FrostContext.newBuilder(curve.opsClass.java)
            .operations(operations)
            .aggregator(InMemorySignatureAggregatorContext())
            .commitment(InMemoryCommitmentContext())
            .crypto(InMemoryCryptoContext.newBuilder<P>()
                .idx(peerId)
                .memKey(memKey::read)
                .ski(SecretBox.of(ski, memKey.read(), true))
                .Y(relatedPublicKey)
                .curve(curve.params)
                .participants(participants)
                .build()
            )
            .aad(additionalContext)
            .build()

        return FrostSessionClient(
            client = createClient(sessionId, frostContext, context),
            operations = operations,
            curve = curve,
            keyId = keyId,
            generation = currentGen,
            tweak = tweak
        ).also {
            sessionMap.put(sessionId, it)
        }
    }

    override fun session(sessionId: String): FrostSessionClient<P> {
        return sessionMap.get(sessionId) ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)
    }

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)?.client
            ?.destroy()
    }

    override fun type(): SessionType {
        return SessionType.FROST
    }

    override fun supportsCurve(curveName: CurveName): Boolean {
        return curve.name == curveName
    }

    abstract fun createClient(sessionId: String, frost: FrostContext<P>, context: SignatureContext?): FrostClient<P>

    inner class Respondent {
        val commitment = FrostCommitmentHandler({ initData.peerId }, clients, this@FrostSessionManager, commitments)
        val sigPart = FrostSignaturePartHandler({ initData.peerId }, this@FrostSessionManager)
    }

    inner class Initiator {
        val broadcaster = FrostPeerBroadcaster(respondent.commitment)
        val initializer = FrostPeerInitializer({initData.peerId}, this@FrostSessionManager, pubKey)
        val finalizer = FrostSignatureFinalizer(this@FrostSessionManager)
        val signature = FrostSignatureService(keyDb, clients, broadcaster,initializer, finalizer, eventScope)
    }

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }
}