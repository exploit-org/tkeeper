package org.exploit.keeper.service.signature.frost

import jakarta.annotation.PreDestroy
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.RawPublicKeyDto
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.ThresholdSessionFactory
import org.exploit.keeper.service.signature.frost.initiator.FrostPeerBroadcaster
import org.exploit.keeper.service.signature.frost.initiator.FrostPeerInitializer
import org.exploit.keeper.service.signature.frost.initiator.FrostSignatureFinalizer
import org.exploit.keeper.service.signature.frost.initiator.FrostSignatureService
import org.exploit.signalix.manager.EventScope
import org.exploit.sodium.ReadOnlyBuffer
import org.exploit.sodium.SecretBox
import org.exploit.tss.curve.PointOps
import org.exploit.tss.frost.FrostClient
import org.exploit.tss.frost.context.FrostContext
import org.exploit.tss.frost.context.commitment.InMemoryCommitmentContext
import org.exploit.tss.frost.context.crypto.InMemoryCryptoContext
import org.exploit.tss.frost.context.signature.InMemorySignatureAggregatorContext
import java.util.concurrent.TimeUnit

abstract class FrostSessionManager<P : PointOps<P>>(
    private val memKey: ReadOnlyBuffer,
    private val keyDb: RocksKeyDB,

    protected val config: KeeperConfig,
    protected val curve: KeeperCurve<P>,
    protected val clients: TKeeperClients,
    protected val pubKey: PublicKeyService,
    protected val eventScope: EventScope
) : ThresholdSessionFactory<FrostSessionClient<P>, P> {
    protected val sessionMap = InMemoryTemporaryMap<String, FrostSessionClient<P>>(
        config.session().frost().expire().seconds, TimeUnit.SECONDS
    )

    private val initData by lazy {
        keyDb.readInitData()
    }

    val respondent = Respondent()
    val initiator = Initiator()

    override fun createSession(
        sessionId: String,
        keyId: String,
        operations: Map<String, ByteArray>,
        publicKey: RawPublicKeyDto,
        participants: List<Int>,
    ): FrostSessionClient<P> {
        val peerId = initData.peerId

        if (!participants.contains(peerId))
            throw TKeeperException(400, "Service is not participant")

        val keyShare = keyDb.storage.get(keyId)?.toPrivateKey()
            ?: throw TKeeperException(400, "Private Key not found")

        if (keyShare.curve != curve.name)
            throw TKeeperException(400, "Curve mismatch for key $keyId")

        val relatedPublicKey = curve.params.decodePoint(publicKey.data)

        val context = FrostContext.newBuilder(curve.opsClass.java)
            .operations(operations)
            .aggregator(InMemorySignatureAggregatorContext())
            .commitment(InMemoryCommitmentContext())
            .crypto(InMemoryCryptoContext.newBuilder<P>()
                .idx(peerId)
                .memKey(memKey::read)
                .ski(SecretBox.of(keyShare.ski, memKey.read(), true))
                .Y(relatedPublicKey)
                .curve(curve.params)
                .participants(participants)
                .build()
            )
            .build()

        return FrostSessionClient<P>(
            client = FrostClient(sessionId, context),
            operations = operations,
            curve = curve
        ).also {
            sessionMap.put(sessionId, it)
        }
    }

    override fun session(sessionId: String): FrostSessionClient<P> {
        return sessionMap.get(sessionId) ?: throw TKeeperException(400, "Session not found")
    }

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)?.client
            ?.destroy()
    }

    override fun type(): SessionType {
        return SessionType.FROST
    }

    override fun supportsCurve(curveName: CurveName): Boolean {
        return curve.name == curveName
    }

    inner class Respondent {
        val commitment = FrostCommitmentHandler({ initData.peerId }, clients, this@FrostSessionManager)
        val sigPart = FrostSignaturePartHandler({ initData.peerId }, this@FrostSessionManager)
    }

    inner class Initiator {
        val broadcaster = FrostPeerBroadcaster(respondent.commitment)
        val initializer = FrostPeerInitializer({initData.peerId}, this@FrostSessionManager, pubKey)
        val finalizer = FrostSignatureFinalizer(this@FrostSessionManager)
        val signature = FrostSignatureService(clients, broadcaster, initializer, finalizer, eventScope)
    }

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }
}