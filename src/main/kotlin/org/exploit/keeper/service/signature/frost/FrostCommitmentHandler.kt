package org.exploit.keeper.service.signature.frost

import jakarta.inject.Singleton
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.frost.FrostOperationCommitment
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.threshield.curve.PointOps
import org.exploit.threshield.frost.model.ParticipantCommitment
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class FrostCommitmentHandler(
    private val config: KeeperConfig,
    private val clients: BitKeeperClients,
    private val factory: FrostSessionFactory
) {
    fun broadcast(sessionId: String): Mono<Void> {
        val session = factory.session(sessionId)

        val commitment = session.operations.mapValues {
            session.client.preProcessor()
                .generateCommitment(it.key)
                .toParticipant(config.idx())
                .dto()
        }

        val peers = clients.forBroadcast(session.client.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap { it.frost.storeCommitment(sessionId, FrostOperationCommitment(commitment)).toMono() }
            .then()
    }

    fun <P : PointOps<P>> store(sessionId: String, idx: Int, operation: FrostOperationCommitment) {
        val session = factory.session<P>(sessionId)

        val unwrappedCommitments = operation.commitments.mapValues {
            ParticipantCommitment(idx,
                session.curve.createPointOps(it.value.D64.decodeBase64()),
                session.curve.createPointOps(it.value.E64.decodeBase64()),
                session.curve.createPointOps(it.value.Y64.decodeBase64()),
            )
        }

        for ((opId, commitment) in unwrappedCommitments) {
            session.client.context()
                .commitment()
                .storePeerCommitment(idx, opId, commitment)
        }
    }
}