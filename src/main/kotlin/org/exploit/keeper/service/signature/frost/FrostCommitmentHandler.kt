package org.exploit.keeper.service.signature.frost

import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.perform
import org.exploit.keeper.model.frost.FrostOperationCommitment
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.tss.curve.PointOps
import org.exploit.tss.frost.model.ParticipantCommitment

class FrostCommitmentHandler<P : PointOps<P>>(
    private val peerId: () -> Int,
    private val clients: TKeeperClients,
    private val factory: FrostSessionManager<P>
) {
    fun broadcast(sessionId: String) {
        val session = factory.session(sessionId)

        val commitment = session.operations.mapValues {
            session.client.preProcessor()
                .generateCommitment(it.key)
                .toParticipant(peerId())
                .dto()
        }

        val peers = clients.forBroadcast(session.client.context().crypto().participants())

        peers.perform {
            it.frost.storeCommitment(sessionId, FrostOperationCommitment(commitment))
        }
    }

    fun store(sessionId: String, idx: Int, operation: FrostOperationCommitment) {
        val session = factory.session(sessionId)

        val unwrappedCommitments = operation.commitments.mapValues {
            ParticipantCommitment(idx,
                session.curve.createPointOps(it.value.d),
                session.curve.createPointOps(it.value.e),
                session.curve.createPointOps(it.value.y),
                session.curve.createPointOps(it.value.r),
                it.value.sigma
            )
        }

        for ((opId, commitment) in unwrappedCommitments) {
            session.client.context()
                .commitment()
                .storePeerCommitment(idx, opId, commitment)
        }
    }
}