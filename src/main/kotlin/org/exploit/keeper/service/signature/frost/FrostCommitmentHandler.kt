package org.exploit.keeper.service.signature.frost

import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.frost.FrostOperationCommitment
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.tss.curve.PointOps
import org.exploit.tss.frost.model.ParticipantCommitment
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class FrostCommitmentHandler<P : PointOps<P>>(
    private val peerId: () -> Int,
    private val clients: TKeeperClients,
    private val factory: FrostSessionManager<P>
) {
    fun broadcast(sessionId: String): Mono<Void> {
        val session = factory.session(sessionId)

        val commitment = session.operations.mapValues {
            session.client.preProcessor()
                .generateCommitment(it.key)
                .toParticipant(peerId())
                .dto()
        }

        val peers = clients.forBroadcast(session.client.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap { it.frost.storeCommitment(sessionId, FrostOperationCommitment(commitment)).toMono()
                .flatMap { r -> r.successOrThrow() }
            }
            .then()
    }

    fun store(sessionId: String, idx: Int, operation: FrostOperationCommitment) {
        val session = factory.session(sessionId)

        val unwrappedCommitments = operation.commitments.mapValues {
            ParticipantCommitment(idx,
                session.curve.createPointOps(it.value.d),
                session.curve.createPointOps(it.value.e),
                session.curve.createPointOps(it.value.y),
                session.curve.createPointOps(it.value.r),
                it.value.sigma
            )
        }

        for ((opId, commitment) in unwrappedCommitments) {
            session.client.context()
                .commitment()
                .storePeerCommitment(idx, opId, commitment)
        }
    }
}