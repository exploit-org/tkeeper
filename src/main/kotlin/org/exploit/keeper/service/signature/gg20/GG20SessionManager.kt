package org.exploit.keeper.service.signature.gg20

import jakarta.annotation.PreDestroy
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.LMKDB
import org.exploit.keeper.exception.BitKeeperException
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.PublicKeyDto
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.ThresholdSessionFactory
import org.exploit.keeper.service.signature.gg20.initiator.*
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.ec.WeierstrassCurveParams
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.GG20Client
import org.exploit.tss.ecdsa.context.GG20Context
import org.exploit.tss.ecdsa.context.aggregator.InMemoryAggregatorContext
import org.exploit.tss.ecdsa.context.crypto.CryptoContext
import org.exploit.tss.ecdsa.context.init.InitContext
import org.exploit.tss.ecdsa.context.integrity.InMemoryIntegrityContext
import org.exploit.tss.ecdsa.context.mta.MtAContext
import org.exploit.tss.ecdsa.generator.GG20CommitmentGenerator
import org.exploit.sodium.SecretBox
import java.util.concurrent.TimeUnit

abstract class GG20SessionManager<P : WeierstrassPointOps<P>>(
    protected val keyDb: LMKDB,
    protected val config: KeeperConfig,
    protected val curve: KeeperCurve<P>,

    protected val clients: BitKeeperClients,
    protected val pubKey: PublicKeyService,
    protected val eventScope: EventScope
): ThresholdSessionFactory<GG20SessionClient<P>, P> {
    protected val sessionMap = InMemoryTemporaryMap<String, GG20SessionClient<P>>(
        config.session().gg20().expire().seconds, TimeUnit.SECONDS
    )

    val respondent by lazy {
        Respondent()
    }

    val initiator by lazy {
        Initiator()
    }

    override fun createSession(
        sessionId: String,
        keyId: String,
        operations: Operations,
        publicKey: PublicKeyDto,
        participants: List<Int>,
    ): GG20SessionClient<P> {
        if (!participants.contains(config.idx()))
            throw BitKeeperException(400, "Service is not participant")

        val curveParams = curve.params as WeierstrassCurveParams<P>
        val opsClass = curve.opsClass

        if (operations.values.size != 1)
            throw BitKeeperException(400, "Only one operation is supported for GG20")

        val (opId, message) = operations.values.toList()[0]

        val publicOps = curveParams.decodePoint(publicKey.data64.decodeBase64())
        val keyShare = keyDb.private.get(keyId)?.toPrivateKey()
            ?: throw BitKeeperException(400, "Key not found")

        if (keyShare.curve != curve.name)
            throw BitKeeperException(400, "Curve mismatch for key $keyId")

        val initContext = InitContext.inMemoryBuilder()
            .message(message)
            .additionalContext(ByteArray(0))
            .build()

        val cryptoContext = CryptoContext.inMemoryBuilder(opsClass.java)
            .idx(config.idx())
            .ski(SecretBox.of(keyShare.ski, keyDb.encKey(), true))
            .publicKey(publicOps)
            .curve(curveParams)
            .memKey(keyDb.encKeySupplier())
            .participants(participants)
            .build()

        val context = GG20Context.newBuilder(curve.opsClass.java)
            .init(initContext)
            .mta(MtAContext.inMemory())
            .aggregator(InMemoryAggregatorContext())
            .integrity(InMemoryIntegrityContext())
            .crypto(cryptoContext)
            .build()

        val g = curveParams.g
        val q = curve.params.getCurveOrder()
        val h = curveParams.generatorH

        val generator = GG20CommitmentGenerator(q, g, h)

        val client = GG20Client(sessionId, context, generator)
            .apply { init() }

        val session = GG20SessionClient(
            client = client,
            opId = opId,
            message = message
        )

        sessionMap.put(sessionId, session)

        return session
    }

    override fun session(sessionId: String): GG20SessionClient<P> =
        sessionMap.get(sessionId) ?: throw BitKeeperException(400, "Session not found")

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)?.client?.destroy()
    }

    override fun type(): SessionType =
        SessionType.GG20

    override fun supportsCurve(curveName: CurveName): Boolean {
        return curve.name == curveName
    }

    inner class Respondent {
        val commitment = GG20CommitmentHandler(this@GG20SessionManager, clients)
        val offlinePhase = GG20OfflinePhaseHandler(clients, this@GG20SessionManager)
        val mta = GG20MtAHandler(config, clients, this@GG20SessionManager)
        val sigPart = GG20SignaturePartHandler(config, eventScope, this@GG20SessionManager)
    }

    inner class Initiator {
        val commitment = GG20CommitmentBroadcaster(respondent.commitment)
        val mta = GG20MtAInitiator(respondent.mta)
        val offlinePhase = GG20OfflinePhaseCollector(respondent.offlinePhase)
        val peerInitializer = GG20PeerInitializer(config, this@GG20SessionManager, pubKey)
        val finalizer = GG20SignatureFinalizer(config, this@GG20SessionManager, respondent.sigPart)

        val signature = GG20SignatureService(
            clients = clients,
            peerInitializer = peerInitializer,
            commitmentBroadcaster = commitment,
            mtaInitiator = mta,
            offlinePhaseCollector = offlinePhase,
            finalizer = finalizer,
            eventScope = eventScope
        )
    }

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }
}