package org.exploit.keeper.service.signature.gg20

import jakarta.annotation.PreDestroy
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.RawPublicKeyDto
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.ThresholdSessionFactory
import org.exploit.keeper.service.signature.gg20.initiator.*
import org.exploit.keeper.util.temporary.InMemoryTemporaryMap
import org.exploit.signalix.manager.EventScope
import org.exploit.sodium.ReadOnlyBuffer
import org.exploit.sodium.SecretBox
import org.exploit.tss.curve.ec.WeierstrassCurveParams
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.GG20Client
import org.exploit.tss.ecdsa.context.GG20Context
import org.exploit.tss.ecdsa.context.aggregator.InMemoryAggregatorContext
import org.exploit.tss.ecdsa.context.crypto.CryptoContext
import org.exploit.tss.ecdsa.context.init.InitContext
import org.exploit.tss.ecdsa.context.integrity.InMemoryIntegrityContext
import org.exploit.tss.ecdsa.context.mta.MtAContext
import org.exploit.tss.ecdsa.generator.GG20CommitmentGenerator
import java.util.concurrent.TimeUnit

abstract class GG20SessionManager<P : WeierstrassPointOps<P>>(
    private val memKey: ReadOnlyBuffer,
    private val keyDb: RocksKeyDB,
    protected val config: KeeperConfig,
    protected val curve: KeeperCurve<P>,

    protected val clients: TKeeperClients,
    protected val pubKey: PublicKeyService,
    protected val eventScope: EventScope
): ThresholdSessionFactory<GG20SessionClient<P>, P> {
    protected val sessionMap = InMemoryTemporaryMap<String, GG20SessionClient<P>>(
        config.session.gg20.expire.seconds, TimeUnit.SECONDS
    )

    private val initData by lazy {
        keyDb.readInitData()
    }

    val respondent by lazy {
        Respondent()
    }

    val initiator by lazy {
        Initiator()
    }

    override fun createSession(
        sessionId: String,
        keyId: String,
        operations: Map<String, ByteArray>,
        publicKey: RawPublicKeyDto,
        participants: List<Int>,
        additionalContext: ByteArray,
        context: SignatureContext? // no context for GG20
    ): GG20SessionClient<P> {
        val peerId = initData.peerId

        if (!participants.contains(peerId))
            throw TKeeperException(ErrorType.NOT_PARTICIPANT)

        val curveParams = curve.params as WeierstrassCurveParams<P>
        val opsClass = curve.opsClass

        if (operations.size != 1)
            throw TKeeperException(ErrorType.TOO_MANY_OPERATIONS)

        val (opId, message) = operations.toList()[0]

        val publicOps = curveParams.decodePoint(publicKey.data)
        val keyShare = keyDb.vault.readCurrentKey(keyId)?.toPrivateKey()
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        if (keyShare.curve != curve.name)
            throw TKeeperException(ErrorType.CURVE_MISMATCH)

        val initContext = InitContext.inMemoryBuilder()
            .message(message)
            .additionalContext(ByteArray(0))
            .build()

        val cryptoContext = CryptoContext.inMemoryBuilder(opsClass.java)
            .idx(peerId)
            .ski(SecretBox.of(keyShare.ski, memKey.read(), true))
            .publicKey(publicOps)
            .curve(curveParams)
            .memKey(memKey::read)
            .participants(participants)
            .build()

        val context = GG20Context.newBuilder(curve.opsClass.java)
            .init(initContext)
            .mta(MtAContext.inMemory())
            .aggregator(InMemoryAggregatorContext())
            .integrity(InMemoryIntegrityContext())
            .crypto(cryptoContext)
            .build()

        val g = curveParams.g
        val q = curve.params.curveOrder
        val h = curveParams.generatorH

        val generator = GG20CommitmentGenerator(q, g, h)

        val client = GG20Client(sessionId, context, generator)
            .apply { init() }

        val session = GG20SessionClient(
            client = client,
            opId = opId,
            message = message
        )

        sessionMap.put(sessionId, session)

        return session
    }

    override fun session(sessionId: String): GG20SessionClient<P> =
        sessionMap.get(sessionId) ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)?.client?.context()?.destroy()
    }

    override fun type(): SessionType =
        SessionType.GG20

    override fun supportsCurve(curveName: CurveName): Boolean {
        return curve.name == curveName
    }

    inner class Respondent {
        val commitment by lazy {
            GG20CommitmentHandler(this@GG20SessionManager, clients)
        }

        val offlinePhase by lazy {
            GG20OfflinePhaseHandler(eventScope, clients, this@GG20SessionManager)
        }

        val mta by lazy {
            GG20MtAHandler(initData.peerId, clients, this@GG20SessionManager, eventScope)
        }

        val sigPart by lazy {
            GG20SignaturePartHandler(initData.peerId, this@GG20SessionManager)
        }
    }

    inner class Initiator {
        val commitment by lazy {
            GG20CommitmentBroadcaster(respondent.commitment)
        }

        val mta by lazy {
            GG20MtAInitiator(respondent.mta)
        }

        val offlinePhase by lazy {
            GG20OfflinePhaseCollector(respondent.offlinePhase)
        }

        val peerInitializer by lazy {
            GG20PeerInitializer(initData.peerId, this@GG20SessionManager, pubKey)
        }

        val finalizer by lazy {
            GG20SignatureFinalizer(initData.peerId, this@GG20SessionManager, respondent.sigPart)
        }

        val signature by lazy {
            GG20SignatureService(
                db = keyDb,
                clients = clients,
                peerInitializer = peerInitializer,
                commitmentBroadcaster = commitment,
                mtaInitiator = mta,
                offlinePhaseCollector = offlinePhase,
                finalizer = finalizer,
                eventScope = eventScope
            )
        }
    }

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }
}