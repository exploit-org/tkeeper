package org.exploit.keeper.service.signature.verify

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import org.exploit.crypto.curve.Secp256k1Provider
import org.exploit.crypto.signature.ECDSASignature
import org.exploit.crypto.signature.Signature
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.decodePublicKey
import org.exploit.keeper.service.pub.NaivePublicKeyService

@Singleton
class Secp256k1SignatureVerifier(private val pub: NaivePublicKeyService): SignatureVerifier {
    override fun verify(keyId: String, data: ByteArray, signature: Signature): Uni<Boolean> =
        pub.getPublicKey(keyId).map {
            val decoded = decodePublicKey(curve(), it.data64.decodeBase64())
            Secp256k1Provider.getInstance().verify(data, signature, decoded)
        }

    override fun createSignature(bytes: ByteArray): Signature {
        return ECDSASignature.decode(bytes)
    }

    override fun curve(): CurveName = CurveName.SECP256K1
}