package org.exploit.keeper.service.signature.gg20

import jakarta.annotation.PreDestroy
import jakarta.inject.Singleton
import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.LMKDB
import org.exploit.keeper.extension.toBigInt
import org.exploit.keeper.model.Operations
import org.exploit.keeper.service.signature.ThresholdSessionFactory
import org.exploit.threshield.curve.PointOps
import org.exploit.threshield.curve.jce.ECCurveParams
import org.exploit.threshield.curve.jce.ECPointOps
import org.exploit.threshield.ecdsa.GG20Client
import org.exploit.threshield.ecdsa.constant.GG20
import org.exploit.threshield.ecdsa.context.GG20Context
import org.exploit.threshield.ecdsa.context.aggregator.InMemoryAggregatorContext
import org.exploit.threshield.ecdsa.context.crypto.CryptoContext
import org.exploit.threshield.ecdsa.context.init.InitContext
import org.exploit.threshield.ecdsa.context.integrity.InMemoryIntegrityContext
import org.exploit.threshield.ecdsa.context.mta.MtAContext
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.util.concurrent.TimeUnit

@Singleton
class GG20SessionFactory(
    private val keyDb: LMKDB,
    private val config: KeeperConfig
): ThresholdSessionFactory<GG20SessionClient> {
    private val sessionMap = InMemoryTemporaryMap<String, GG20SessionClient>(
        config.session().gg20().expire().seconds, TimeUnit.SECONDS
    )

    override fun <P: PointOps<P>> createSession(
        sessionId: String, keyId: String,
        operations: Operations, participants: List<Int>,
        curve: KeeperCurve<P>
    ): GG20SessionClient {
        if (!participants.contains(config.idx()))
            throw BadRequestException("Service is not participant")

        if (curve.params !is ECCurveParams)
            throw BadRequestException("Curve is not supported")

        if (operations.values.size != 1)
            throw BadRequestException("Only one operation is supported for GG20")

        val (opId, message) = operations.values.toList()[0]

        val curveParams = curve.params
        val keyShare = keyDb.private.get(keyId)?.toBigInt() ?: throw BadRequestException("Key not found")

        val relatedFullPublicKey = keyDb.public.get(keyId)?.toPointOps(curveParams)
            ?: throw IllegalStateException("Public Key not found for $keyId")

        val initContext = InitContext.inMemoryBuilder()
            .message(message)
            .additionalContext(ByteArray(0))
            .build()

        val cryptoContext = CryptoContext.inMemoryBuilder()
            .idx(config.idx())
            .ski(keyShare)
            .publicKey(relatedFullPublicKey)
            .curve(curveParams)
            .participants(participants)
            .build()

        val context = GG20Context.newBuilder()
            .init(initContext)
            .mta(MtAContext.inMemory())
            .aggregator(InMemoryAggregatorContext())
            .integrity(InMemoryIntegrityContext())
            .crypto(cryptoContext)
            .build()

        val client = GG20Client(sessionId, context, GG20.CommitmentGenerator.SECP256k1)
            .apply { init() }

        return GG20SessionClient(client, opId, message)
            .also {
                sessionMap.put(sessionId, it)
            }
    }

    override fun <P : PointOps<P>> session(sessionId: String): GG20SessionClient =
        sessionMap.get(sessionId) ?: throw BadRequestException("Session not found")

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)
    }

    override fun type(): SessionType {
        return SessionType.GG20
    }

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }

    private fun ByteArray.toPointOps(curveParams: ECCurveParams): ECPointOps {
        return ECPointOps(curveParams.x9ECParameters.curve.decodePoint(this))
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(GG20SessionFactory::class.java)
    }
}