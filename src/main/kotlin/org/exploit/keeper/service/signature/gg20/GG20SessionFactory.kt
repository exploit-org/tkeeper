package org.exploit.keeper.service.signature.gg20

import jakarta.annotation.PreDestroy
import jakarta.inject.Singleton
import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.LMKDB
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toBigInt
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.PublicKeyDto
import org.exploit.keeper.service.misc.CurvePointDecoder
import org.exploit.keeper.service.signature.ThresholdSessionFactory
import org.exploit.threshield.curve.PointOps
import org.exploit.threshield.curve.jce.ECCurveParams
import org.exploit.threshield.curve.jce.ECPointOps
import org.exploit.threshield.ecdsa.GG20Client
import org.exploit.threshield.ecdsa.constant.GG20
import org.exploit.threshield.ecdsa.context.GG20Context
import org.exploit.threshield.ecdsa.context.aggregator.InMemoryAggregatorContext
import org.exploit.threshield.ecdsa.context.crypto.CryptoContext
import org.exploit.threshield.ecdsa.context.init.InitContext
import org.exploit.threshield.ecdsa.context.integrity.InMemoryIntegrityContext
import org.exploit.threshield.ecdsa.context.mta.MtAContext
import java.util.concurrent.TimeUnit

@Singleton
class GG20SessionFactory(
    private val keyDb: LMKDB,
    private val config: KeeperConfig,
    private val decoder: CurvePointDecoder
): ThresholdSessionFactory<GG20SessionClient> {
    private val sessionMap = InMemoryTemporaryMap<String, GG20SessionClient>(
        config.session().gg20().expire().seconds, TimeUnit.SECONDS
    )

    override fun <P : PointOps<P>> createSession(
        sessionId: String,
        keyId: String,
        operations: Operations,
        publicKey: PublicKeyDto,
        participants: List<Int>,
        curve: KeeperCurve<P>
    ): GG20SessionClient {
        if (!participants.contains(config.idx()))
            throw BadRequestException("Service is not participant")

        if (curve.params !is ECCurveParams)
            throw BadRequestException("Curve is not supported")

        if (operations.values.size != 1)
            throw BadRequestException("Only one operation is supported for GG20")

        val (opId, message) = operations.values.toList()[0]

        val curveParams = curve.params
        val publicOps = decoder.decode(curve.params, publicKey.data64.decodeBase64())

        val keyShare = keyDb.private.get(keyId)?.toPrivateKey() ?: throw BadRequestException("Key not found")

        if (keyShare.curve != curve.name)
            throw BadRequestException("Curve mismatch for key $keyId")

        val initContext = InitContext.inMemoryBuilder()
            .message(message)
            .additionalContext(ByteArray(0))
            .build()

        val cryptoContext = CryptoContext.inMemoryBuilder()
            .idx(config.idx())
            .ski(keyShare.ski.toBigInt())
            .publicKey(publicOps as ECPointOps)
            .curve(curveParams)
            .participants(participants)
            .build()

        val context = GG20Context.newBuilder()
            .init(initContext)
            .mta(MtAContext.inMemory())
            .aggregator(InMemoryAggregatorContext())
            .integrity(InMemoryIntegrityContext())
            .crypto(cryptoContext)
            .build()

        val client = GG20Client(sessionId, context, GG20.CommitmentGenerator.SECP256k1)
            .apply { init() }

        return GG20SessionClient(client, opId, message)
            .also {
                sessionMap.put(sessionId, it)
            }
    }

    override fun <P : PointOps<P>> session(sessionId: String): GG20SessionClient =
        sessionMap.get(sessionId) ?: throw BadRequestException("Session not found")

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)
    }

    override fun type(): SessionType =
        SessionType.GG20

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }
}