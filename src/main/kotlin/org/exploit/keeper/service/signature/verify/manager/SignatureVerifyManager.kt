package org.exploit.keeper.service.signature.verify.manager

import io.quarkus.arc.All
import jakarta.inject.Singleton
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.request.Verify
import org.exploit.keeper.service.signature.verify.SignatureVerifier
import reactor.core.publisher.Mono

@Singleton
class SignatureVerifyManager(
    @All
    private val verifiers: MutableList<SignatureVerifier>,
    private val db: RocksKeyDB
) {
    fun verify(verify: Verify): Mono<Boolean> {
        val curve = extractCurve(verify.keyId)
        val sigType = verify.sigType ?: curve.fallbackSigType

        val verifier = verifiers.find { it.curve() == curve && it.type() == sigType }
            ?: throw TKeeperException(400, "Signature verifier not found for $curve -> $sigType")

        val data = verify.data64.decodeBase64()
        val signature = verifier.createSignature(verify.signature64.decodeBase64())

        return verifier.verify(verify.keyId, data, signature)
    }

    private fun extractCurve(keyId: String): CurveName =
        db.storage.get(keyId)
            ?.toPrivateKey()
            ?.also { it.destroy() }
            ?.curve ?: throw TKeeperException(400, "$keyId not found")
}