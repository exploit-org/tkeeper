package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.ComputedSignature
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.keeper.service.signature.gg20.GG20SignaturePartHandler
import org.exploit.tss.curve.ec.WeierstrassPointOps

class GG20SignatureFinalizer<P : WeierstrassPointOps<P>>(
    private val peerId: Int,
    private val factory: GG20SessionManager<P>,
    private val signaturePartHandler: GG20SignaturePartHandler<P>
) {
    fun completeSignature(peers: List<TKeeperClient>, sessionId: String): Round<ComputedSignature> {
        val session = factory.session(sessionId)
        val aggregatorContext = session.client.context().aggregator()

        aggregatorContext.storePartialS(peerId, signaturePartHandler.computePartialS(sessionId).result)
        val (responses, dead) = peers.performAndReturnDead { it.gg20.computeS(sessionId) }

        if (dead.isNotEmpty())
            return Round(null, dead = dead, restart = true)

        val values = responses.mapValues { it.value.body.result }

        for ((peerId, result) in values)
            aggregatorContext.storePartialS(peerId, result)

        val signature = session.client.aggregator().calculateSignature()
        return Round(ComputedSignature(mapOf(session.opId to signature.encode().toBase64())))
    }
}