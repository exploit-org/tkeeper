package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.api.client.BitKeeperClient
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.ComputedSignature
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.keeper.service.signature.gg20.GG20SignaturePartHandler
import org.exploit.tss.curve.ec.WeierstrassPointOps
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class GG20SignatureFinalizer<P : WeierstrassPointOps<P>>(
    private val config: KeeperConfig,
    private val factory: GG20SessionManager<P>,
    private val signaturePartHandler: GG20SignaturePartHandler<P>
) {
    fun completeSignature(peers: List<BitKeeperClient>, sessionId: String): Mono<ComputedSignature> {
        return Flux.fromIterable(peers)
            .flatMap {it.gg20.computeS(sessionId).toMono()
                .flatMap { r -> r.successOrThrow() }
            }
            .collectList()
            .flatMap {
                val session = factory.session(sessionId)
                val aggregatorContext = session.client.context().aggregator()

                aggregatorContext.storePartialS(config.idx(), signaturePartHandler.computePartialS(sessionId).result)

                for (value in it)
                    aggregatorContext.storePartialS(value.serviceId, value.result)

                val signature = session.client.aggregator().calculateSignature()
                Mono.just(ComputedSignature(mapOf(session.opId to signature.encode().toBase64())))
            }
    }
}