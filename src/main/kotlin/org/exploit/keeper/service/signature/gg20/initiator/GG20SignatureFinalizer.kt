package org.exploit.keeper.service.signature.gg20.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.extension.perform
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.model.ComputedSignature
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.keeper.service.signature.gg20.GG20SignaturePartHandler
import org.exploit.tss.curve.ec.WeierstrassPointOps

class GG20SignatureFinalizer<P : WeierstrassPointOps<P>>(
    private val peerId: Int,
    private val factory: GG20SessionManager<P>,
    private val signaturePartHandler: GG20SignaturePartHandler<P>
) {
    fun completeSignature(peers: List<TKeeperClient>, sessionId: String): ComputedSignature {
        val session = factory.session(sessionId)
        val aggregatorContext = session.client.context().aggregator()

        aggregatorContext.storePartialS(peerId, signaturePartHandler.computePartialS(sessionId).result)
        val values = peers.perform { it.gg20.computeS(sessionId) }

        for (value in values)
            aggregatorContext.storePartialS(value.serviceId, value.result)

        val signature = session.client.aggregator().calculateSignature()
        return ComputedSignature(mapOf(session.opId to signature.encode().toBase64()))
    }
}