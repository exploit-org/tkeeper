package org.exploit.keeper.service.signature.frost.initiator

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.BitKeeperClient
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.OperationsDto
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.frost.FrostSessionFactory
import org.exploit.threshield.curve.PointOps
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class FrostPeerInitializer(
    private val config: KeeperConfig,
    private val factory: FrostSessionFactory,
    private val pubKeyService: PublicKeyService
) {
    fun <P : PointOps<P>> init(clients: List<BitKeeperClient>, sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>): Mono<List<BitKeeperClient>> {
        return pubKeyService.getPublicKey(keyId).flatMap {
            factory.createSession(sessionId, keyId, operations, it, clients.map { client -> client.peerId } + config.idx(), curve)

            val body = InitSession(
                sessionId = sessionId,
                keyId = keyId,
                publicKey = it,
                operations = OperationsDto(operations.values.mapValues { o -> o.value.toBase64() }),
                participants = factory.session(sessionId).client.context().crypto().participants(),
                curve = curve.name
            )

            Flux.fromIterable(clients)
                .flatMap { client ->
                    client.frost.init(body).toMono()
                        .thenReturn(client)
                }
                .collectList()
        }
    }
}