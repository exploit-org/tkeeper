package org.exploit.keeper.service.signature.frost.initiator

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.BitKeeperClient
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.OperationsDto
import org.exploit.keeper.service.signature.frost.FrostSessionFactory
import org.exploit.threshield.curve.PointOps
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class FrostPeerInitializer(
    private val config: KeeperConfig,
    private val factory: FrostSessionFactory
) {
    fun <P : PointOps<P>> init(clients: List<BitKeeperClient>, sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>): Mono<List<BitKeeperClient>> {
        factory.createSession(sessionId, keyId, operations, clients.map { client -> client.peerId } + config.idx(), curve)

        val body = InitSession(
            sessionId = sessionId,
            keyId = keyId,
            operations = OperationsDto(operations.values.mapValues { o -> o.value.toBase64() }),
            participants = factory.session(sessionId).client.context().crypto().participants(),
            curve = curve.name
        )

        return Flux.fromIterable(clients)
            .flatMap {
                it.frost.init(body).toMono()
                    .thenReturn(it)
            }
            .collectList()
    }
}