package org.exploit.keeper.service.signature.frost.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.extension.context
import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.frost.FrostSessionManager
import org.exploit.tss.curve.PointOps

class FrostPeerInitializer<P : PointOps<P>>(
    private val peerId: () -> Int,
    private val factory: FrostSessionManager<P>,
    private val pubKeyService: PublicKeyService
) {
    fun init(clients: List<TKeeperClient>, sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>, context: SignatureContext?): Round<Void> {
        val pub = pubKeyService.getPublicKey(keyId)
        val aad = context(keyId, sessionId)
        val participants = clients.map { client -> client.peerId } + peerId()

        factory.createSession(sessionId, keyId, operations.values, pub, participants, aad, context)

        val body = InitSession(
            sessionId = sessionId,
            keyId = keyId,
            publicKey = pub,
            operations = operations.values,
            participants = factory.session(sessionId).client.context().crypto().participants(),
            curve = curve.name,
            additionalContext = aad,
            context = context
        )

        val (_, failed) = clients.performAndReturnDead { it.frost.init(body) }

        return Round(null, dead = failed, restart = failed.isNotEmpty())
    }
}