package org.exploit.keeper.service.signature.frost.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.OperationsDto
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.frost.FrostSessionManager
import org.exploit.tss.curve.PointOps
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class FrostPeerInitializer<P : PointOps<P>>(
    private val peerId: () -> Int,
    private val factory: FrostSessionManager<P>,
    private val pubKeyService: PublicKeyService
) {
    fun init(clients: List<TKeeperClient>, sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>): Mono<List<TKeeperClient>> {
        return pubKeyService.getPublicKey(keyId).flatMap {
            factory.createSession(sessionId, keyId, operations, it, clients.map { client -> client.peerId } + peerId())

            val body = InitSession(
                sessionId = sessionId,
                keyId = keyId,
                publicKey = it,
                operations = OperationsDto(operations.values.mapValues { o -> o.value.toBase64() }),
                participants = factory.session(sessionId).client.context().crypto().participants(),
                curve = curve.name
            )

            Flux.fromIterable(clients)
                .flatMap { client ->
                    client.frost.init(body).toMono()
                        .flatMap { r -> r.successOrThrow() }
                        .thenReturn(client)
                }
                .collectList()
        }
    }
}