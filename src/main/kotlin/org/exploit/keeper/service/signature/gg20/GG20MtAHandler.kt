package org.exploit.keeper.service.signature.gg20

import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.gg20.mta.GG20MtAComputeRequest
import org.exploit.keeper.model.gg20.mta.GG20MtAResult
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.constant.GG20
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

class GG20MtAHandler<P : WeierstrassPointOps<P>>(
    private val peerId: Int,
    private val clients: TKeeperClients,
    private val sessionFactory: GG20SessionManager<P>
) {
    fun exchange(sessionId: String): Mono<Void> {
        val session = sessionFactory.session(sessionId)
            .client

        val initiatorMessage = session.context().mta().initiator.message()

        val request = GG20MtAComputeRequest(
            sessionId = sessionId,
            zk = session.context().crypto().zkSetup().dto(),
            initiatorPublicKey = session.context().crypto().paillier().publicKey.dto(),
            message = initiatorMessage.dto()
        )

        val peers = clients.forBroadcast(session.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap {
                it.gg20.computeMta(request).toMono()
                    .flatMap { r -> r.successOrThrow() }
            }
            .doOnNext {
                session.mta().asInitiator().store(GG20.ComputationType.GAMMA, it.peerId, it.gamma.unwrap())
                session.mta().asInitiator().store(GG20.ComputationType.LAGRANGE, it.peerId, it.lagrange.unwrap())
            }
            .then()
    }

    fun compute(idx: Int, request: GG20MtAComputeRequest): GG20MtAResult {
        val respondentApi = sessionFactory.session(request.sessionId)
            .client
            .mta()
            .asRespondent()

        val initiatorPublicKey = request.initiatorPublicKey.unwrap()
        val initiatorMessage = request.message.unwrap()
        val zkSetup = request.zk.unwrap()

        val gammaResult = respondentApi.compute(
            GG20.ComputationType.GAMMA, idx,
            initiatorPublicKey, zkSetup, initiatorMessage
        )

        val lagrangeResult = respondentApi.compute(
            GG20.ComputationType.LAGRANGE, idx,
            initiatorPublicKey, zkSetup, initiatorMessage
        )

        return GG20MtAResult(peerId, gammaResult.dto(), lagrangeResult.dto())
    }
}