package org.exploit.keeper.service.signature.gg20

import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.model.gg20.mta.GG20MtAComputeRequest
import org.exploit.keeper.model.gg20.mta.GG20MtAResult
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.ecdsa.constant.GG20

class GG20MtAHandler<P : WeierstrassPointOps<P>>(
    private val peerId: Int,
    private val clients: TKeeperClients,
    private val sessionFactory: GG20SessionManager<P>,
    private val eventScope: EventScope
) {
    fun exchange(sessionId: String): Round<Void> {
        val session = sessionFactory.session(sessionId)
            .client

        val initiatorMessage = session.context().mta().initiator.message()

        val request = GG20MtAComputeRequest(
            sessionId = sessionId,
            zk = session.context().crypto().zkSetup().dto(),
            initiatorPublicKey = session.context().crypto().paillier().publicKey.dto(),
            message = initiatorMessage.dto()
        )

        val peers = clients.forBroadcast(session.context().crypto().participants())
        val (responses, dead) = peers.performAndReturnDead { it.gg20.computeMta(request) }

        if (dead.isNotEmpty())
            return Round(null, dead = dead, restart = true)

        val results = responses.mapValues { it.value.body }

        val imposters = HashSet<Int>()

        for ((peerId, result) in results) {
            try {
                session.mta().asInitiator().store(GG20.ComputationType.GAMMA, peerId, result.gamma.unwrap())
                session.mta().asInitiator().store(GG20.ComputationType.LAGRANGE, peerId, result.lagrange.unwrap())
            } catch (_: Exception) {
                imposters.add(peerId)
            }
        }

        if (imposters.isNotEmpty())
            eventScope.call(SessionCleanEvent(sessionId, SessionType.GG20))

        return Round(null, imposters = imposters, restart = imposters.isNotEmpty())
    }

    fun compute(idx: Int, request: GG20MtAComputeRequest): GG20MtAResult {
        val respondentApi = sessionFactory.session(request.sessionId)
            .client
            .mta()
            .asRespondent()

        val initiatorPublicKey = request.initiatorPublicKey.unwrap()
        val initiatorMessage = request.message.unwrap()
        val zkSetup = request.zk.unwrap()

        val gammaResult = respondentApi.compute(
            GG20.ComputationType.GAMMA, idx,
            initiatorPublicKey, zkSetup, initiatorMessage
        )

        val lagrangeResult = respondentApi.compute(
            GG20.ComputationType.LAGRANGE, idx,
            initiatorPublicKey, zkSetup, initiatorMessage
        )

        return GG20MtAResult(peerId, gammaResult.dto(), lagrangeResult.dto())
    }
}