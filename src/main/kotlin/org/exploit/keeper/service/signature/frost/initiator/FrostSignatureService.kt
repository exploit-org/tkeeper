package org.exploit.keeper.service.signature.frost.initiator

import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.signature.SignatureService
import org.exploit.keeper.util.ErrorHandlers
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.PointOps
import org.exploit.tss.exception.IdentifiableAbortException
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class FrostSignatureService<P : PointOps<P>>(
    private val clients: TKeeperClients,
    private val broadcaster: FrostPeerBroadcaster<P>,
    private val peerInitializer: FrostPeerInitializer<P>,
    private val finalizer: FrostSignatureFinalizer<P>,
    private val eventScope: EventScope
): SignatureService<P> {
    override fun sign(sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>): TSSResult {
        try {
            val clients = clients.findThreshold()

            peerInitializer.init(clients, sessionId, keyId, operations, curve)
            broadcaster.broadcast(clients, sessionId)

            val result = finalizer.completeSignature(clients, sessionId)
            eventScope.call(SessionCleanEvent(sessionId, SessionType.FROST))

            return TSSResult.success(result)
        } catch (e: Exception) {
            if (e is IdentifiableAbortException) {
                LOGGER.error("Signing aborted due to ${e.peerId}", e)
            }

            LOGGER.error("Error during signing process: ${e.message}", e)
            ErrorHandlers.handleAbort(sessionId, SessionType.FROST, eventScope, e)
            throw e
        }
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(FrostSignatureService::class.java)
    }
}