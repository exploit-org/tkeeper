package org.exploit.keeper.service.signature.frost.initiator

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.extension.toUni
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.keeper.service.signature.SignatureService
import org.exploit.keeper.util.ErrorHandlers
import org.exploit.signalix.manager.EventScope
import org.exploit.threshield.curve.PointOps
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import reactor.core.publisher.Mono
import reactor.core.publisher.Mono.defer

@Singleton
class FrostSignatureService(
    private val clients: BitKeeperClients,
    private val broadcaster: FrostPeerBroadcaster,
    private val peerInitializer: FrostPeerInitializer,
    private val finalizer: FrostSignatureFinalizer,
    private val eventScope: EventScope
): SignatureService {
    override fun <P : PointOps<P>> sign(sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>): Uni<TSSResult> {
        return clients.findThreshold()
            .flatMap { peerInitializer.init(it, sessionId, keyId, operations, curve) }
            .flatMap { broadcaster.broadcast(it, sessionId)  }
            .flatMap { defer { finalizer.completeSignature(it, sessionId).map { TSSResult.success(it) }}}
            .doOnNext { eventScope.call(SessionCleanEvent(sessionId, SessionType.FROST)) }
            .doOnError { ErrorHandlers.handleAbort(sessionId, SessionType.FROST, eventScope, it)}
            .onErrorResume {
                LOGGER.error("Error during signing process: ${it.message}", it)
                Mono.just(TSSResult.failed())
            }
            .toUni()
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(FrostSignatureService::class.java)
    }
}