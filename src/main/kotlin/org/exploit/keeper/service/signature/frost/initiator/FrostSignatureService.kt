package org.exploit.keeper.service.signature.frost.initiator

import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.constant.crypto.SignatureType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.ThresholdSignature
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.model.signature.BIP340Context
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.model.signature.TaprootContext
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperComplianceService
import org.exploit.keeper.service.signature.SignatureService
import org.exploit.keeper.util.ErrorHandlers
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.PointOps
import org.exploit.tss.exception.IdentifiableAbortException
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class FrostSignatureService<P : PointOps<P>>(
    private val compliance: KeeperComplianceService,
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val broadcaster: FrostPeerBroadcaster<P>,
    private val peerInitializer: FrostPeerInitializer<P>,
    private val finalizer: FrostSignatureFinalizer<P>,
    private val eventScope: EventScope
): SignatureService<P> {
    override fun sign(sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>, context: SignatureContext?): ThresholdSignature {
        context?.validate()
        operations.ensureAll32Bytes()

        val signatureType = if (curve.name != CurveName.SECP256K1)
            SignatureType.SCHNORR
        else when (context) {
            null -> SignatureType.SEC1R65SCHNORR
            is BIP340Context, is TaprootContext -> SignatureType.SCHNORR
        }

        val currentGen = db.vault.readLatestVersion(keyId)
            .activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        if (!compliance.allowedForApplyOperations(keyId))
            throw TKeeperException(ErrorType.KEY_APPLY_OPS_FORBIDDEN, keyId)

        val clients = clients.findThreshold()

        try {
            peerInitializer.init(clients, sessionId, keyId, operations, curve, context)
            broadcaster.broadcast(clients, sessionId)

            val result = finalizer.completeSignature(clients, sessionId)
            eventScope.call(SessionCleanEvent(sessionId, SessionType.FROST))

            return ThresholdSignature.success(result, signatureType,currentGen)
        } catch (e: Exception) {
            if (e is IdentifiableAbortException) {
                LOGGER.error("Signing aborted due to ${e.peerId}", e)
            }

            LOGGER.error("Error during signing process: ${e.message}", e)
            ErrorHandlers.handleAbort(sessionId, SessionType.FROST, eventScope, e)
            return ThresholdSignature.failed(currentGen, signatureType)
        }
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(FrostSignatureService::class.java)
    }
}