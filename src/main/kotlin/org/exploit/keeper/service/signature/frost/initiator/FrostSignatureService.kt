package org.exploit.keeper.service.signature.frost.initiator

import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SignatureType
import org.exploit.keeper.constant.crypto.TSSCode
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.performSuccessOnly
import org.exploit.keeper.extension.toKeeperList
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.ThresholdSignature
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.event.ImposterFoundEvent
import org.exploit.keeper.model.signature.BIP340Context
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.model.signature.TaprootContext
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.signature.SignatureService
import org.exploit.keeper.service.signature.frost.FrostSessionManager
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.PointOps

class FrostSignatureService<P : PointOps<P>>(
    private val factory: FrostSessionManager<P>,
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val broadcaster: FrostPeerBroadcaster<P>,
    private val peerInitializer: FrostPeerInitializer<P>,
    private val finalizer: FrostSignatureFinalizer<P>,
    private val eventScope: EventScope
): SignatureService<P> {
    override fun sign(sessionId: String, keyId: String, operations: Operations, curve: KeeperCurve<P>, context: SignatureContext?, lastRound: Round<ThresholdSignature>?): Round<ThresholdSignature> {
        context?.validate()
        operations.ensureAll32Bytes()

        val imposters = lastRound?.imposters ?: emptySet()
        val dead = lastRound?.dead ?: emptySet()

        val signatureType = if (curve.name != CurveName.SECP256K1)
            SignatureType.SCHNORR
        else when (context) {
            null -> SignatureType.SEC1R65SCHNORR
            is BIP340Context, is TaprootContext -> SignatureType.SCHNORR
        }

        try {
            val currentGen = db.vault.readLatestVersion(keyId)
                .activeGen
                ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

            val clients = clients.findThreshold(exclude = imposters + dead)

            val initRound = round(sessionId, imposters, dead) {
                peerInitializer.init(clients, sessionId, keyId, operations, curve, context)
            }

            if (initRound.restart)
                return initRound

            val broadcastRound = round(sessionId, imposters, dead) {
                broadcaster.broadcast(clients, sessionId)
            }

            if (broadcastRound.restart)
                return broadcastRound

            val signatureRound = finalizer.completeSignature(clients, sessionId)

            if (signatureRound.restart) {
                reset(sessionId, signatureRound)
                return Round(null, dead = dead + signatureRound.dead, imposters = imposters + signatureRound.imposters)
            }

            val finalSignature = ThresholdSignature(
                code = TSSCode.SUCCESS,
                type = signatureType,
                signature = signatureRound.value,
                generation = currentGen,
                imposters = imposters.toKeeperList()
            )

            return Round(finalSignature)
        } catch (e: Exception) {
            clearSession(sessionId)

            if (e is TKeeperException)
                throw TKeeperException(e.errorType, details = e.details, imposters = imposters, dead = dead)

            throw TKeeperException(ErrorType.INTERNAL_ERROR, imposters = imposters, dead = dead, cause = e)
        }
    }

    private fun round(sid: String, knownImposters: Set<Int>, knownDead: Set<Int>, func: () -> Round<*>): Round<ThresholdSignature> {
        val r = func.invoke()

        if (r.restart) {
            reset(sid, r)
            return Round(null, imposters = knownImposters + r.imposters, dead = knownDead + r.dead, restart = true)
        }

        return Round(null)
    }

    private fun reset(sid: String, r: Round<*>) {
        clearSession(sid)
        checkImposters(r)
    }

    private fun checkImposters(round: Round<*>) {
        if (round.imposters.isNotEmpty())
            eventScope.call(ImposterFoundEvent(round.imposters))
    }

    private fun clearSession(id: String) {
        val session = factory.session(id)
        val clients = clients.forBroadcast(session.client.context().crypto().participants())

        factory.clear(id)
        clients.performSuccessOnly { it.frost.abort(id) }
    }
}