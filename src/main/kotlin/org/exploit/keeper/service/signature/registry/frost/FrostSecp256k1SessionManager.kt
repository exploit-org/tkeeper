package org.exploit.keeper.service.signature.registry.frost

import jakarta.inject.Singleton
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodeBase64
import org.exploit.keeper.extension.unwrap
import org.exploit.keeper.model.ThresholdSignature
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.request.Sign
import org.exploit.keeper.model.signature.BIP340Context
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.model.signature.TaprootContext
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperComplianceService
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.frost.FrostSessionManager
import org.exploit.keeper.service.signature.registry.SessionManagerInstance
import org.exploit.secp256k1.Secp256k1PointOps
import org.exploit.signalix.manager.EventScope
import org.exploit.sodium.ReadOnlyBuffer
import org.exploit.tss.frost.FrostClient
import org.exploit.tss.frost.context.FrostContext
import org.exploit.tss.frost.secp256k1.FrostBIP340Scheme
import org.exploit.tss.frost.secp256k1.FrostSecp256k1Scheme
import org.exploit.tss.frost.secp256k1.FrostTaprootScheme
import java.util.*

@Singleton
class FrostSecp256k1SessionManager(
    private val compliance: KeeperComplianceService,
    memKey: ReadOnlyBuffer,
    keyDb: RocksKeyDB, config: KeeperConfig,
    clients: TKeeperClients, pubKey: PublicKeyService,
    eventScope: EventScope
): FrostSessionManager<Secp256k1PointOps>(
    memKey, keyDb,
    config, KeeperCurve.SECP256K1,
    clients, pubKey, eventScope
), SessionManagerInstance {
    override fun curve(): CurveName {
        return CurveName.SECP256K1
    }

    override fun sign(sign: Sign, lastRound: Round<ThresholdSignature>?): ThresholdSignature {
        if (!compliance.allowedForApplyOperations(sign.keyId))
            throw TKeeperException(ErrorType.KEY_APPLY_OPS_FORBIDDEN, sign.keyId)

        val round = initiator.signature.sign(
            sessionId = UUID.randomUUID().toString(),
            keyId = sign.keyId,
            operations = sign.operations.unwrap(sign.hash),
            curve = curve,
            context = sign.context,
            lastRound = lastRound
        )

        if (round.restart)
            return sign(sign, round)

        return requireNotNull(round.value)
    }

    override fun createClient(sessionId: String, frost: FrostContext<Secp256k1PointOps>, context: SignatureContext?): FrostClient<Secp256k1PointOps> {
        if (context == null)
            return FrostClient(sessionId, frost, FrostSecp256k1Scheme())

        context.validate()

        val scheme = when (context) {
            is BIP340Context -> FrostBIP340Scheme()
            is TaprootContext -> FrostTaprootScheme(context.merkleRoot64?.decodeBase64() ?: ByteArray(0))
        }

        return FrostClient(sessionId, frost, scheme)
    }

    override fun session(): SessionType {
        return SessionType.FROST
    }

    override fun hasSessionId(sessionId: String): Boolean {
        return sessionMap.containsKey(sessionId)
    }

    override fun destroy(sessionId: String) {
        sessionMap.get(sessionId)?.client?.destroy()
    }
}