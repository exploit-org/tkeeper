package org.exploit.keeper.service.signature.registry.gg20

import jakarta.inject.Singleton
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.crypto.SessionType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.unwrap
import org.exploit.keeper.model.ThresholdSignature
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.request.Sign
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperComplianceService
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.keeper.service.signature.registry.SessionManagerInstance
import org.exploit.secp256k1.Secp256k1PointOps
import org.exploit.signalix.manager.EventScope
import org.exploit.sodium.ReadOnlyBuffer
import java.util.*

@Singleton
class GG20Secp256k1SessionManager(
    private val compliance: KeeperComplianceService,
    memKey: ReadOnlyBuffer,
    keyDb: RocksKeyDB, config: KeeperConfig,
    clients: TKeeperClients, pubKey: PublicKeyService,
    eventScope: EventScope
): GG20SessionManager<Secp256k1PointOps>(
    memKey, keyDb, config,
    KeeperCurve.SECP256K1, clients,
    pubKey, eventScope
), SessionManagerInstance {
    override fun curve(): CurveName {
        return CurveName.SECP256K1
    }

    override fun sign(sign: Sign, lastRound: Round<ThresholdSignature>?): ThresholdSignature {
        if (!compliance.allowedForApplyOperations(sign.keyId))
            throw TKeeperException(ErrorType.KEY_APPLY_OPS_FORBIDDEN, sign.keyId)

        return signWithRounds(sign, lastRound, 0)
    }

    private fun signWithRounds(
        sign: Sign,
        lastRound: Round<ThresholdSignature>?,
        rounds: Int
    ): ThresholdSignature {
        val maxRounds = config.session.gg20.maxRounds
        val nextRounds = rounds + 1

        if (nextRounds > maxRounds) {
            throw TKeeperException(ErrorType.SESSION_MAX_ROUNDS_EXCEEDED, sign.keyId)
        }

        val round = initiator.signature.sign(
            sessionId = UUID.randomUUID().toString(),
            keyId = sign.keyId,
            operations = sign.operations.unwrap(sign.hash),
            curve = curve,
            context = sign.context,
            lastRound = lastRound,
            tweak = sign.tweak
        )

        if (round.restart) {
            return signWithRounds(sign, round, nextRounds)
        }

        return requireNotNull(round.value)
    }

    override fun session(): SessionType {
        return SessionType.GG20
    }

    override fun hasSessionId(sessionId: String): Boolean {
        return sessionMap.containsKey(sessionId)
    }

    override fun destroy(sessionId: String) {
        sessionMap.get(sessionId)?.client?.destroy()
    }
}