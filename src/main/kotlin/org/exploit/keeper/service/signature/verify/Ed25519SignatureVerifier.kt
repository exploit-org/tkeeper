package org.exploit.keeper.service.signature.verify

import jakarta.inject.Singleton
import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.crypto.key.ECPublicKey
import org.exploit.ed25519.Ed25519PointOps
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.SignatureType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.decodePublicKey
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.tss.signature.SchnorrSignature
import org.exploit.tss.signature.Signature
import reactor.core.publisher.Mono

@Singleton
class Ed25519SignatureVerifier(private val pub: PublicKeyService): SignatureVerifier {
    override fun verify(keyId: String, data: ByteArray, signature: Signature): Mono<Boolean> {
        return pub.getPublicKey(keyId)
            .map {
                val decoded = decodePublicKey(curve(), it.data) as ECPublicKey<Ed25519PointOps>
                Ed25519Provider.getInstance().verify(data, signature, decoded)
            }
    }

    override fun createSignature(bytes: ByteArray): Signature {
        if (bytes.size != 64) {
            throw TKeeperException(400, "Invalid schnorr signature")
        }

        val r = bytes.copyOfRange(0, 32)
        val s = bytes.copyOfRange(32, 64)

        return SchnorrSignature(r, s)
    }

    override fun curve(): CurveName = CurveName.ED25519

    override fun type(): SignatureType = SignatureType.SCHNORR
}