package org.exploit.keeper.service.signature.frost.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.extension.performIndexed
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.model.ComputedSignature
import org.exploit.keeper.service.signature.frost.FrostSessionManager
import org.exploit.tss.curve.PointOps

class FrostSignatureFinalizer<P : PointOps<P>>(private val factory: FrostSessionManager<P>) {
    fun completeSignature(clients: List<TKeeperClient>, sessionId: String): ComputedSignature {
        val session = factory.session(sessionId)

        session.operations.mapValues {
            session.client.signature().computeZ(it.key)
        }.forEach {
            session.client.aggregator().storeZ(session.client.context().crypto().idx(), it.key, it.value)
        }

        val computedZ = clients.performIndexed { it.frost.computeZ(sessionId) }

        for ((peerId, z) in computedZ) {
            z.values.forEach { (opId, value) ->
                session.client.aggregator().storeZ(peerId, opId, value)
            }
        }

        val signatures = session.operations.mapValues {
            session.client.aggregator().computeSignature(it.key).encode()
                .toBase64()
        }

        return ComputedSignature(signatures)
    }
}