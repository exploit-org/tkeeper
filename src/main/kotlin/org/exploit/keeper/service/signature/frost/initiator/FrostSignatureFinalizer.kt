package org.exploit.keeper.service.signature.frost.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.ComputedSignature
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.service.signature.frost.FrostSessionManager
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.PointOps

class FrostSignatureFinalizer<P : PointOps<P>>(
    private val eventScope: EventScope,
    private val factory: FrostSessionManager<P>
) {
    fun completeSignature(clients: List<TKeeperClient>, sessionId: String): Round<ComputedSignature> {
        val session = factory.session(sessionId)

        session.operations.mapValues {
            session.client.signature().computeZ(it.key)
        }.forEach {
            session.client.aggregator().storeZ(session.client.context().crypto().idx(), it.key, it.value)
        }

        val (computedZResponse, dead) = clients.performAndReturnDead { it.frost.computeZ(sessionId) }

        if (dead.isNotEmpty())
            return Round(null, dead = dead, restart = true)

        val imposters = HashSet<Int>()
        val computedZ = computedZResponse.mapValues { (_, v) -> v.body }

        for ((peerId, z) in computedZ) {
            z.values.forEach { (opId, value) ->
                try {
                    session.client.aggregator().storeZ(peerId, opId, value)
                } catch (_: Exception) {
                    imposters.add(peerId)
                }
            }
        }

        if (imposters.isNotEmpty()) {
            return Round(value = null, imposters = imposters, restart = true)
        }

        val signatures = session.operations.mapValues {
            session.client.aggregator().computeSignature(it.key).encode()
                .toBase64()
        }

        return Round(ComputedSignature(signatures))
    }
}