package org.exploit.keeper.service.signature.frost.initiator

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.BitKeeperClient
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.ComputedSignature
import org.exploit.keeper.service.signature.frost.FrostSessionFactory
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class FrostSignatureFinalizer(private val factory: FrostSessionFactory) {
    fun completeSignature(clients: List<BitKeeperClient> , sessionId: String): Mono<ComputedSignature> {
        val session = factory.session(sessionId)

        session.operations.mapValues {
            session.client.signature().computeZ(it.key)
        }.forEach {
            session.client.aggregator().storeZ(session.client.context().crypto().idx(), it.key, it.value)
        }

        return Flux.fromIterable(clients)
            .flatMap {
                it.frost.computeZ(sessionId).toMono()
                    .handle { v, s ->
                        try {
                            v.values.forEach { (opId, value) ->
                                session.client.aggregator().storeZ(it.peerId, opId, value)
                            }
                            s.next(v)
                        } catch (e: Exception) {
                            s.error(e)
                        }
                    }
            }
            .then(Mono.defer {
                val signatures = session.operations.mapValues {
                    session.client.aggregator().computeSignature(it.key)
                }

                Mono.just(ComputedSignature(signatures))
            })
    }
}