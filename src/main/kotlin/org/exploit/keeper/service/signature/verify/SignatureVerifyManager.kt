package org.exploit.keeper.service.signature.verify

import jakarta.inject.Singleton
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodeBase64
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.request.Verify

@Singleton
class SignatureVerifyManager(
    private val verifiers: List<SignatureVerifier>,
    private val db: RocksKeyDB
) {
    fun verify(verify: Verify): Boolean {
        val curve = extractCurve(verify.keyId)
        val sigType = verify.sigType ?: curve.fallbackSigType

        val verifier = verifiers.find { it.curve() == curve && it.type() == sigType }
            ?: throw TKeeperException(ErrorType.SIGNATURE_VERIFIER_NOT_FOUND)

        val data = verify.data64.decodeBase64()
        val signature = verifier.createSignature(verify.signature64.decodeBase64())

        return verifier.verify(verify.keyId, data, signature)
    }

    private fun extractCurve(keyId: String): CurveName =
        db.storage.get(keyId)
            ?.toPrivateKey()
            ?.also { it.destroy() }
            ?.curve ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
}