package org.exploit.keeper.service.signature.verify

import jakarta.inject.Singleton
import org.exploit.crypto.Hash
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodeBase64
import org.exploit.keeper.extension.extractCurveAndDestroy
import org.exploit.keeper.model.request.Verify
import org.exploit.keeper.service.core.KeeperComplianceService

@Singleton
class SignatureVerifyManager(
    private val db: RocksKeyDB,
    private val compliance: KeeperComplianceService,
    private val verifiers: List<SignatureVerifier>,
) {
    fun verify(verify: Verify): Boolean {
        val targetGeneration = verify.generation ?: db.vault.readLatestVersion(verify.keyId).activeGen
                ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, verify.keyId)

        if (!compliance.allowedForProcessOperation(verify.keyId, targetGeneration))
            throw TKeeperException(ErrorType.KEY_PROCESS_OPS_FORBIDDEN, verify.keyId)

        val curve = KeeperCurve.fromName(extractCurve(verify.keyId, targetGeneration))
        val signatureBytes = verify.signature64.decodeBase64()

        val sigType = verify.sigType

        if (!curve.supportedSignatureTypes().contains(sigType))
            throw TKeeperException(ErrorType.UNSUPPORTED_CURVE, "Curve $curve is not supported for signature type $sigType")

        val verifier = verifiers.find { it.curve() == curve.name && it.type() == sigType }
            ?: throw TKeeperException(ErrorType.SIGNATURE_VERIFIER_NOT_FOUND)

        val signature = verifier.createSignature(signatureBytes)

        var data = verify.data64.decodeBase64()
        if (verify.hash) data = Hash.sha256(data)

        if (data.size != 32)
            throw TKeeperException(ErrorType.INVALID_PAYLOAD, "Payload size must be 32 bytes, but got ${data.size}")

        return verifier.verify(verify.keyId, data, signature, targetGeneration, verify.context, verify.tweak)
    }

    private fun extractCurve(keyId: String, version: Int): CurveName =
        db.vault.readKey(keyId, version)
            ?.extractCurveAndDestroy()
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
}