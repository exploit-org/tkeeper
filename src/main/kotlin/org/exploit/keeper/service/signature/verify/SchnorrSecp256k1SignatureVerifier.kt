package org.exploit.keeper.service.signature.verify

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import org.exploit.crypto.curve.Secp256k1Provider
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey
import org.exploit.crypto.signature.SchnorrSignature
import org.exploit.crypto.signature.Signature
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.SignatureType
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.decodePublicKey
import org.exploit.keeper.extension.toUni
import org.exploit.keeper.service.pub.PublicKeyService

@Singleton
class SchnorrSecp256k1SignatureVerifier(private val pub: PublicKeyService): SignatureVerifier {
    override fun verify(keyId: String, data: ByteArray, signature: Signature): Uni<Boolean> {
        return pub.getPublicKey(keyId)
            .map {
                val decoded = decodePublicKey(curve(), it.data64.decodeBase64()) as Secp256k1PublicKey
                Secp256k1Provider.getInstance().schnorr().verify(decoded, data, signature as SchnorrSignature)
            }
            .toUni()
    }

    override fun createSignature(bytes: ByteArray): Signature {
        val r = bytes.copyOfRange(0, 32)
        val s = bytes.copyOfRange(32, 64)

        return SchnorrSignature(r, s)
    }

    override fun curve(): CurveName = CurveName.SECP256K1

    override fun type(): SignatureType = SignatureType.SCHNORR
}