package org.exploit.keeper.service.signature.verify

import jakarta.inject.Singleton
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.ContextKind.BIP340
import org.exploit.keeper.constant.crypto.ContextKind.TAPROOT
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.SignatureType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodeBase64
import org.exploit.keeper.extension.crypto.decodePublicKey
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.model.signature.TaprootContext
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.secp256k1.Secp256k1
import org.exploit.secp256k1.taproot.Taproot
import org.exploit.tss.signature.SchnorrSignature
import org.exploit.tss.signature.Signature

@Singleton
class SchnorrSecp256k1SignatureVerifier(private val publicKeyService: PublicKeyService): SignatureVerifier {
    override fun verify(keyId: String, data: ByteArray, signature: Signature, generation: Int, context: SignatureContext?, tweak: String?): Boolean {
        val publicKey = publicKeyService.getPublicKey(keyId, generation, tweak).data
            .let { decodePublicKey(curve(), it) as Secp256k1PublicKey }

        val xOnly = Taproot.xOnly(publicKey.point())

        context?.validate()
        val kind = context?.kind ?: BIP340

        return when (kind) {
            BIP340 -> Secp256k1.schnorrVerify(data, signature.encode(), xOnly)
            TAPROOT -> {
                val taproot = context as TaprootContext
                val merkleRoot = taproot.merkleRoot64?.decodeBase64() ?: ByteArray(0)

                return Secp256k1.taprootVerify(data, signature.encode(), xOnly, merkleRoot)
            }
        }
    }

    override fun createSignature(bytes: ByteArray): Signature {
        if (bytes.size != 64) {
            throw TKeeperException(ErrorType.INVALID_SCHNORR_SIGNATURE)
        }

        val r = bytes.copyOfRange(0, 32)
        val s = bytes.copyOfRange(32, 64)

        return SchnorrSignature(r, s)
    }

    override fun curve(): CurveName {
        return CurveName.SECP256K1
    }

    override fun type(): SignatureType {
        return SignatureType.SCHNORR
    }
}