package org.exploit.keeper.service.signature.frost.initiator

import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.service.signature.frost.FrostCommitmentHandler
import org.exploit.tss.curve.PointOps

class FrostPeerBroadcaster<P : PointOps<P>>(private val commitmentHandler: FrostCommitmentHandler<P>) {
    fun broadcast(peers: List<TKeeperClient>, sessionId: String): Round<Void> {
        val r = commitmentHandler.broadcast(sessionId)

        if (r.restart)
            return r

        val (rounds, dead) = peers.performAndReturnDead {
            it.frost.broadcast(sessionId)
        }

        if (dead.isNotEmpty())
            return Round(null, dead = dead, restart = true)

        val totalDead = HashSet<Int>()
        val imposters = HashSet<Int>()

        rounds.forEach { (_, round) ->
            totalDead.addAll(round.body.dead)
            imposters.addAll(round.body.imposters)
        }

        return Round(null, dead = totalDead, imposters = imposters, restart = totalDead.isNotEmpty() || imposters.isNotEmpty())
    }
}