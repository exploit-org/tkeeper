package org.exploit.keeper.service.signature.verify

import jakarta.inject.Singleton
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.SignatureType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodePublicKey
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.tss.frost.secp256k1.verify.Secp256k1Frost
import org.exploit.tss.signature.Sec1RSchnorrSignature
import org.exploit.tss.signature.Signature

@Singleton
class Sec1R65Secp256k1SignatureVerifier(private val publicKeyService: PublicKeyService): SignatureVerifier {
    override fun verify(keyId: String, data: ByteArray, signature: Signature, generation: Int, context: SignatureContext?, tweak: String?): Boolean {
        val publicKey = publicKeyService.getPublicKey(keyId, generation, tweak).data
            .let { decodePublicKey(curve(), it) as Secp256k1PublicKey }
            .compress()

        return Secp256k1Frost.schnorrVerify(data, signature.encode(), publicKey)
    }

    override fun createSignature(bytes: ByteArray): Signature {
        if (bytes.size != 65)
            throw TKeeperException(ErrorType.INVALID_SEC1R65SCHNORR_SIGNATURE)

        val r33 = bytes.copyOfRange(0, 33)
        val s32 = bytes.copyOfRange(33, 65)

        return Sec1RSchnorrSignature(r33, s32)
    }

    override fun curve(): CurveName {
        return CurveName.SECP256K1
    }

    override fun type(): SignatureType {
        return SignatureType.SEC1R65SCHNORR
    }
}