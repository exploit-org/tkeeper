package org.exploit.keeper.service.frost

import jakarta.inject.Singleton
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.frost.FrostCommitmentDto
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.threshield.curve.PointOps
import org.exploit.threshield.frost.model.ParticipantCommitment
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class FrostCommitmentHandler(
    private val config: KeeperConfig,
    private val clients: BitKeeperClients,
    private val factory: FrostSessionFactory
) {
    fun broadcast(sessionId: String): Mono<Void> {
        val session = factory.session(sessionId)

        val commitment = session.client.preProcessor()
            .generateCommitment()
            .toParticipant(config.idx())
            .dto()

        val peers = clients.forBroadcast(session.client.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap { it.frost.storeCommitment(sessionId, commitment).toMono() }
            .then()
    }

    fun <P : PointOps<P>> store(sessionId: String, idx: Int, commitment: FrostCommitmentDto) {
        val session = factory.session<P>(sessionId)

        val unwrappedCommitment = ParticipantCommitment(idx,
            session.curve.createPointOps(commitment.D64.decodeBase64()),
            session.curve.createPointOps(commitment.E64.decodeBase64()),
            session.curve.createPointOps(commitment.Y64.decodeBase64()),
        )

        session.client.context()
            .commitment()
            .storePeerCommitment(idx, unwrappedCommitment)
    }
}