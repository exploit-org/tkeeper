package org.exploit.keeper.service.frost

import jakarta.annotation.PreDestroy
import jakarta.inject.Singleton
import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.LMKDB
import org.exploit.keeper.extension.toBigInt
import org.exploit.keeper.service.ThresholdSessionFactory
import org.exploit.threshield.curve.PointOps
import org.exploit.threshield.ed25519.Ed25519CurveParams
import org.exploit.threshield.ed25519.Ed25519PointOps
import org.exploit.threshield.frost.FrostClient
import org.exploit.threshield.frost.context.FrostContext
import org.exploit.threshield.frost.context.commitment.InMemoryCommitmentContext
import org.exploit.threshield.frost.context.crypto.InMemoryCryptoContext
import org.exploit.threshield.frost.context.signature.InMemorySignatureAggregatorContext
import java.util.concurrent.TimeUnit

@Singleton
class FrostSessionFactory(
    private val keyDb: LMKDB,
    private val config: KeeperConfig
) : ThresholdSessionFactory<FrostSessionClient<out PointOps<*>>> {
    private val sessionMap = InMemoryTemporaryMap<String, FrostSessionClient<out PointOps<*>>>(
        config.session().frost().expire().seconds, TimeUnit.SECONDS
    )

    override fun <P : PointOps<P>> createSession(
        sessionId: String, keyId: String, message: ByteArray, participants: List<Int>, curve: KeeperCurve<P>
    ): FrostSessionClient<P> {
        if (!participants.contains(config.idx()))
            throw BadRequestException("Service is not participant")

        val share = keyDb.private.get(keyId)?.toBigInt()
            ?: throw BadRequestException("Private Key not found")

        val relatedFullPublicKey = keyDb.public.get(keyId)?.let {
            curve.createPointOps(it)
        } ?: throw IllegalStateException("Public Key not found or invalid for $keyId")

        val context = FrostContext.newBuilder(curve.opsClass.java)
            .message(message)
            .aggregator(InMemorySignatureAggregatorContext())
            .commitment(InMemoryCommitmentContext())
            .crypto(InMemoryCryptoContext.newBuilder<P>()
                .idx(config.idx())
                .ski(share)
                .Y(relatedFullPublicKey)
                .curve(curve.params)
                .participants(participants)
                .build()
            )
            .build()

        return FrostSessionClient<P>(FrostClient(sessionId, context), curve)
            .also {
                sessionMap.put(sessionId, it)
            }
    }

    @Suppress("UNCHECKED_CAST")
    override fun <P : PointOps<P>> session(sessionId: String): FrostSessionClient<P> {
        val session = sessionMap.get(sessionId) ?: throw BadRequestException("Session not found")
        return session as FrostSessionClient<P>
    }

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)
    }

    override fun type(): SessionType {
        return SessionType.FROST
    }

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }

    private fun ByteArray.toPointOps() = Ed25519PointOps(this)
}