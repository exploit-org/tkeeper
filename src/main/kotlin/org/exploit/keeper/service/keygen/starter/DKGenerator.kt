package org.exploit.keeper.service.keygen.starter

import io.sentry.Sentry
import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import org.exploit.keeper.api.client.BitKeeperClient
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.exception.NotInitializedException
import org.exploit.keeper.exception.SealedException
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.extension.toUni
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.keeper.service.core.KeeperSealService
import org.exploit.keeper.service.keygen.DistributedKeyCollector
import org.exploit.keeper.service.keygen.DistributedKeyGen
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class DKGenerator(
    private val config: KeeperConfig,
    private val peers: BitKeeperClients,
    private val keyGen: DistributedKeyGen,
    private val collector: DistributedKeyCollector,
    private val seal: KeeperSealService
) {
    fun generateKey(keyId: String, curve: KeeperCurve<*>, overwrite: Boolean): Uni<Void> {
        if (!seal.initialized())
            throw NotInitializedException()

        if (seal.sealed())
            throw SealedException()

        keyGen.init(keyId, curve, overwrite)

        return initPeers(keyId, curve.name, overwrite)
            .flatMap { clients ->
                collectShares(keyId, clients)
                    .flatMap { computeShares(keyId, it) }
                    .onErrorResume {
                        abort(keyId, clients)
                            .then(Mono.error(it))
                    }
            }
            .doOnError {
                keyGen.abort(keyId)
            }
            .toUni()
    }

    private fun initPeers(keyId: String, curveName: CurveName, overwrite: Boolean): Mono<List<BitKeeperClient>> =
        peers.findHealthy(config.peers().size)
            .flatMapIterable { it }
            .flatMap {
                it.keyGen.init(keyId, curveName, overwrite).toMono()
                    .flatMap { r -> r.successOrThrow() }
                    .thenReturn(it)
            }
            .collectList()

    private fun collectShares(keyId: String, clients: List<BitKeeperClient>): Mono<List<BitKeeperClient>> =
        collector.collect(keyId, clients)
            .flatMapIterable { it }
            .flatMap { it.keyGen.collect(keyId).toMono()
                .flatMap { r -> r.successOrThrow() }
                .thenReturn(it)
            }
            .collectList()

    private fun computeShares(keyId: String, clients: List<BitKeeperClient>): Mono<Void> {
        keyGen.compute(keyId)

        return Flux.fromIterable(clients)
            .flatMap { it.keyGen.compute(keyId).toMono()
                .flatMap { r -> r.successOrThrow() }
            }
            .then()
    }

    private fun abort(keyId: String, clients: List<BitKeeperClient>): Mono<Void> {
        keyGen.abort(keyId)
        return Flux.fromIterable(clients)
            .flatMap {
                it.keyGen.abort(keyId).toMono()
                    .flatMap { r -> r.successOrThrow() }
            }
            .doOnError {
                Sentry.captureException(it)
            }
            .onErrorResume { Mono.empty() }
            .then()
    }
}