package org.exploit.keeper.service.keygen.generator

import org.exploit.crypto.stereotype.Sensitive
import org.exploit.threshield.curve.EllipticCurveParams
import org.exploit.threshield.curve.PointOps
import org.exploit.zktrust.util.ZKRandom
import java.math.BigInteger
import java.util.*

class NodeKeyGen<P : PointOps<P>>(
    private val curve: EllipticCurveParams<P>,
    private val n: Int, t: Int
) : Sensitive {

    private val coef: Array<BigInteger>
    private var commitments: List<PointOps<P>>? = null

    init {
        require(t in 1..n) { "bad t" }

        val q = curve.curveOrder
        coef = Array(t) { BigInteger(q.bitLength(), ZKRandom.getRandom()).mod(q) }

        val g = curve.g
        val tmp = ArrayList<PointOps<P>>(t)
        for (ak in coef) tmp.add(g.mul(ak))

        commitments = Collections.unmodifiableList(tmp)
    }

    fun commitments(): List<PointOps<P>> =
        commitments ?: error("Commitments have been erased")

    fun shareFor(idx: Int): BigInteger {
        require(idx in 1..n) { "idx out of range" }

        val q = curve.curveOrder
        val x = BigInteger.valueOf(idx.toLong())
        var pow = BigInteger.ONE
        var s = BigInteger.ZERO

        for (ak in coef) {
            s = s.add(ak.multiply(pow)).mod(q)
            pow = pow.multiply(x).mod(q)
        }
        return s
    }

    override fun erase() {
        Arrays.fill(coef, BigInteger.ZERO)
        commitments = null
    }

    companion object {
        fun <P : PointOps<P>> verifyShare(
            curve: EllipticCurveParams<P>, idx: Int,
            share: BigInteger, commits: List<PointOps<P>>
        ): Boolean {
            val g = curve.g
            val lhs = g.mul(share).normalize()

            val q = curve.curveOrder
            val x = BigInteger.valueOf(idx.toLong())
            var pow = BigInteger.ONE
            var rhs = curve.infinity

            for (Ck in commits) {
                rhs = rhs.add(Ck.mul(pow))
                pow = pow.multiply(x).mod(q)
            }

            return lhs == rhs.normalize()
        }

        fun aggregateShares(shares: List<BigInteger>, q: BigInteger): BigInteger =
            shares.fold(BigInteger.ZERO) { acc, s -> acc.add(s).mod(q) }
    }
}