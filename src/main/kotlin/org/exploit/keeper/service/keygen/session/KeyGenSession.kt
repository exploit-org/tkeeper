package org.exploit.keeper.service.keygen.session

import org.exploit.crypto.stereotype.Sensitive
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.model.keygen.ShamirShareDto
import org.exploit.keeper.service.keygen.generator.NodeKeyGen
import org.exploit.threshield.curve.PointOps
import java.math.BigInteger

class KeyGenSession<P : PointOps<P>>(
    val curve: KeeperCurve<P>,
    private val peerId: Int,
    private val gen: NodeKeyGen<P>,
    private val n: Int
): Sensitive {
    private val shares = mutableListOf<BigInteger>()

    @Synchronized
    fun store(share: BigInteger) {
        if (shares.size >= n)
            throw IllegalStateException("Too many shares")

        shares.add(share)
    }

    fun shareFor(idx: Int): ShamirShareDto {
        if (idx <= 0 || idx > n) {
            throw IllegalArgumentException("Invalid index")
        }

        val share = gen.shareFor(idx)
        val commitments = gen.commitments().map {
            it.encode(true).toBase64()
        }

        return ShamirShareDto(share, commitments)
    }

    fun computeShare(): BigInteger {
        if (shares.size < n - 1) {
            throw IllegalStateException("Not enough shares")
        }
        
        return NodeKeyGen.aggregateShares(
            shares = shares.toList() + gen.shareFor(peerId),
            q = curve.params.curveOrder
        )
    }

    override fun erase() {
        shares.clear()
        gen.erase()
    }
}