package org.exploit.keeper.service.keygen.session

import org.exploit.gmp.BigInt
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.model.keygen.ShamirShareDto
import org.exploit.keeper.service.keygen.generator.NodeKeyGen
import org.exploit.tss.curve.PointOps
import javax.security.auth.Destroyable

class KeyGenSession<P : PointOps<P>>(
    val curve: KeeperCurve<P>,
    private val peerId: Int,
    private val gen: NodeKeyGen<P>,
    private val n: Int,
    private val oldShare: BigInt? = null
): Destroyable {
    private val shares = mutableListOf<BigInt>()

    @Synchronized
    fun store(share: BigInt) {
        if (shares.size >= n)
            throw IllegalStateException("Too many shares")

        shares.add(share)
    }

    fun shareFor(idx: Int): ShamirShareDto {
        if (idx <= 0 || idx > n) {
            throw IllegalArgumentException("Invalid index")
        }

        val share = gen.shareFor(idx)
        val commitments = gen.commitments().map {
            it.encode(true).toBase64()
        }

        return ShamirShareDto(share, commitments)
    }

    fun computeShare(): BigInt {
        if (shares.size < n - 1) {
            throw IllegalStateException("Not enough shares")
        }

        val pieces = shares + gen.shareFor(peerId) +
                listOfNotNull(oldShare)

        return NodeKeyGen.aggregateShares(
            shares = pieces,
            q = curve.params.curveOrder
        )
    }

    override fun destroy() {
        shares.clear()
        gen.erase()
    }
}