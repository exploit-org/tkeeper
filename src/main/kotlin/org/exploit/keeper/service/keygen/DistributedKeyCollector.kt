package org.exploit.keeper.service.keygen

import io.sentry.Sentry
import jakarta.inject.Singleton
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.service.client.TKeeperClients
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class DistributedKeyCollector(
    private val keyGen: DistributedKeyGen,
    private val peers: TKeeperClients,
    private val config: KeeperConfig,
) {
    fun collect(keyId: String): Mono<Void> {
        return peers.findHealthy(config.peers().size)
            .flatMap {
                collect(keyId, it).then()
            }
    }

    fun collect(keyId: String, clients: List<TKeeperClient>): Mono<List<TKeeperClient>> {
        return Flux.fromIterable(clients)
            .flatMap {
                it.keyGen.share(keyId).toMono()
                    .flatMap { r -> r.successOrThrow() }
                    .doOnNext { share ->
                        keyGen.store(keyId, share)
                    }
                    .thenReturn(it)
            }
            .doOnError {
                Sentry.captureException(it)
            }
            .onErrorResume { e -> Mono.error(IllegalStateException("Couldn't collect shares ", e)) }
            .collectList()
    }
}