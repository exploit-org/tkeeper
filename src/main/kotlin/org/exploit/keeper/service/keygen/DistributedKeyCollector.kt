package org.exploit.keeper.service.keygen

import io.sentry.Sentry
import jakarta.inject.Singleton
import org.exploit.keeper.api.client.BitKeeperClient
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.service.client.BitKeeperClients
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class DistributedKeyCollector(
    private val keyGen: DistributedKeyGen,
    private val peers: BitKeeperClients,
    private val config: KeeperConfig
) {
    fun collect(keyId: String): Mono<Void> {
        return peers.findHealthy(config.peers().size)
            .flatMap {
                collect(keyId, it).then()
            }
    }

    fun collect(keyId: String, clients: List<BitKeeperClient>): Mono<List<BitKeeperClient>> {
        return Flux.fromIterable(clients)
            .flatMap {
                it.keyGen.share(keyId).toMono()
                    .flatMap { r -> r.successOrThrow() }
                    .doOnNext { share ->
                        keyGen.store(keyId, it.peerId, share)
                    }
                    .thenReturn(it)
            }
            .doOnError {
                Sentry.captureException(it)
            }
            .onErrorResume { e -> Mono.error(IllegalStateException("Couldn't collect shares ", e)) }
            .collectList()
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(DistributedKeyCollector::class.java)
    }
}