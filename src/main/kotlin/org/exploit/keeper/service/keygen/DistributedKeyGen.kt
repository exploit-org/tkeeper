package org.exploit.keeper.service.keygen

import jakarta.inject.Singleton
import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.LMKDB
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.model.keygen.ShamirShareDto
import org.exploit.keeper.service.keygen.generator.NodeKeyGen
import org.exploit.keeper.service.keygen.session.KeyGenSession
import org.exploit.keeper.util.KeySerializer
import org.exploit.tss.curve.PointOps
import java.util.concurrent.TimeUnit

@Singleton
class DistributedKeyGen(
    private val config: KeeperConfig,
    private val db: LMKDB
) {
    private val sessions = InMemoryTemporaryMap<String, KeyGenSession<*>>(30, TimeUnit.MINUTES)

    fun <P : PointOps<P>> init(keyId: String, curve: KeeperCurve<P>, overwrite: Boolean) {
        if (sessions.containsKey(keyId))
            throw BadRequestException("Session already exists")

        if (db.private.hasKey(keyId) && !overwrite)
            throw BadRequestException("Key already exists")

        val t = config.threshold()
        val n = config.peers().size + 1

        val keyGen = NodeKeyGen(
            curve = curve.params,
            n = n,
            t = t
        )

        sessions.put(keyId, KeyGenSession(
            curve = curve,
            peerId = config.idx(),
            gen = keyGen,
            n = n
        ))
    }

    fun share(idx: Int, sessionId: String): ShamirShareDto {
        val session = sessions.get(sessionId) ?: throw BadRequestException("Session not found")
        return session.shareFor(idx)
    }

    fun store(keyId: String, peerId: Int, share: ShamirShareDto) {
        val session = sessions.get(keyId)?: throw BadRequestException("Session not found")
        val curveParams = session.curve.params
        val commitments = share.commitments64.map { curveParams.decodePoint(it.decodeBase64()) as PointOps<*> }

        if (!NodeKeyGen.verifyShare(curveParams, peerId, share.share, commitments)) {
            throw BadRequestException("Invalid share")
        }

        session.store(share.share)
    }

    fun compute(keyId: String) {
        try {
            val session = sessions.get(keyId) ?: throw BadRequestException("Session not found")
            val share = session.computeShare().toUnsignedByteArray(session.curve.keySize())

            db.private.save(keyId, KeySerializer.serialize(session.curve.name, share))
            release(keyId)
        } catch (e: Exception) {
            abort(keyId)
            throw IllegalStateException("Failed to compute key", e)
        }
    }

    fun abort(keyId: String) {
        val session = sessions.get(keyId)?: return
        session.destroy()

        sessions.remove(keyId)
        db.private.delete(keyId)
    }

    private fun release(keyId: String) {
        sessions.remove(keyId)?.destroy()
    }
}