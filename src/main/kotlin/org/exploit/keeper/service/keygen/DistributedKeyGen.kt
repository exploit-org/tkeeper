package org.exploit.keeper.service.keygen

import jakarta.inject.Singleton
import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toBigInt
import org.exploit.keeper.model.keygen.ShamirShareDto
import org.exploit.keeper.service.keygen.generator.NodeKeyGen
import org.exploit.keeper.service.keygen.session.KeyGenSession
import org.exploit.keeper.util.KeySerializer
import org.exploit.tss.curve.PointOps
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.util.concurrent.TimeUnit

@Singleton
class DistributedKeyGen(private val db: RocksKeyDB) {
    private val initData by lazy {
        db.readInitData()
    }

    private val sessions = InMemoryTemporaryMap<String, KeyGenSession<*>>(30, TimeUnit.MINUTES)

    fun <P : PointOps<P>> init(keyId: String, curve: KeeperCurve<P>, overwrite: Boolean, refresh: Boolean = false) {
        if (sessions.containsKey(keyId))
            throw BadRequestException("Session already exists")

        if (db.storage.hasKey(keyId) && !overwrite && !refresh)
            throw BadRequestException("Key already exists")

        val t = initData.threshold
        val n = initData.total

        val keyGen = NodeKeyGen(
            curve = curve.params,
            n = n,
            t = t,
            zeroConst = refresh
        )

        val old = if (refresh) {
            val raw = db.storage.get(keyId) ?: throw BadRequestException("Key not found")
            val deserialized = KeySerializer.deserialize(raw)

            if (deserialized.curve != curve.name)
                throw TKeeperException(400, "Curve mismatch: expected ${curve.name}, got ${deserialized.curve}")

            deserialized.ski.toBigInt()
        } else null

        sessions.put(keyId, KeyGenSession(
            curve = curve,
            peerId = initData.peerId,
            gen = keyGen,
            n = n,
            oldShare = old
        ))
    }

    fun share(idx: Int, sessionId: String): ShamirShareDto {
        val session = sessions.get(sessionId) ?: throw BadRequestException("Session not found")
        return session.shareFor(idx)
    }

    fun store(keyId: String, share: ShamirShareDto) {
        val session = sessions.get(keyId)?: throw BadRequestException("Session not found")
        val curveParams = session.curve.params
        val commitments = share.commitments64.map { curveParams.decodePoint(it.decodeBase64()) as PointOps<*> }

        if (!NodeKeyGen.verifyShare(curveParams, initData.peerId, share.share, commitments)) {
            throw BadRequestException("Invalid share")
        }

        session.store(share.share)
    }

    fun compute(keyId: String) {
        try {
            val session = sessions.get(keyId) ?: throw BadRequestException("Session not found")
            val share = session.computeShare().toUnsignedByteArray(session.curve.keySize())

            db.storage.save(keyId, KeySerializer.serialize(session.curve.name, share))
            release(keyId)
        } catch (e: Exception) {
            abort(keyId)
            throw IllegalStateException("Failed to compute key", e)
        }
    }

    fun abort(keyId: String) {
        val session = sessions.get(keyId)?: return
        session.destroy()

        sessions.remove(keyId)
        db.storage.delete(keyId)
    }

    private fun release(keyId: String) {
        sessions.remove(keyId)?.destroy()
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(DistributedKeyGen::class.java)
    }
}