package org.exploit.keeper.service.core

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.dkg.ConsistencyVerdict
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.perform
import org.exploit.keeper.extension.performIndexed
import org.exploit.keeper.model.key.KeyVersion
import org.exploit.keeper.model.keygen.ConsistencyCheck
import org.exploit.keeper.service.client.TKeeperClients
import org.rocksdb.Transaction

@Singleton
class KeeperConsistencyService(
    private val db: RocksKeyDB,
    private val clients: TKeeperClients
) {
    private val initData by lazy { db.readInitData() }

    fun check(keyId: String, clients: List<TKeeperClient>): ConsistencyCheck {
        val versions = readVersions(keyId, clients)

        val actives = versions.values.map { it.activeGen }.toSet()
        val allMissing = actives.size == 1 && actives.first() == null
        if (allMissing) {
            return ConsistencyCheck(ConsistencyVerdict.MISSING, versions = versions)
        }

        val maxSeen = maxSeenGen(versions)

        val minActive = versions.values.mapNotNull { it.activeGen }.minOrNull()
        val maxActive = versions.values.mapNotNull { it.activeGen }.maxOrNull()

        if (minActive != null && maxActive != null && minActive == maxActive) {
            return ConsistencyCheck(
                verdict = ConsistencyVerdict.OK,
                versions = versions
            )
        }

        val canSyncAll = versions.values.all { v ->
            v.activeGen == maxSeen || v.pendingGen == maxSeen
        }

        return if (canSyncAll) {
            ConsistencyCheck(
                verdict = ConsistencyVerdict.SYNC_NEEDED,
                targetGeneration = maxSeen,
                versions = versions
            )
        } else {
            ConsistencyCheck(
                verdict = ConsistencyVerdict.ROTATE_NEEDED,
                targetGeneration = maxSeen,
                versions = versions
            )
        }
    }

    fun tryAutoFix(keyId: String): ConsistencyCheck {
        val peers = clients.findAllHealthy()
        return tryAutoFix(keyId, peers)
    }

    fun tryAutoFix(keyId: String, clients: List<TKeeperClient>): ConsistencyCheck {
        val chk = check(keyId, clients)

        when (chk.verdict) {
            ConsistencyVerdict.MISSING -> return chk

            ConsistencyVerdict.OK -> {
                val active = requireUniformActiveOrNull(chk.versions) ?: return chk
                cleanupStalePendingAboveActive(keyId, clients, chk.versions, active)
                return check(keyId, clients)
            }

            ConsistencyVerdict.SYNC_NEEDED -> {
                val gen = chk.targetGeneration
                    ?: throw TKeeperException(ErrorType.INTERNAL_ERROR,"SYNC_NEEDED without targetGeneration, keyId=$keyId")

                syncAll(keyId, clients, gen)

                val after = check(keyId, clients)

                if (after.verdict == ConsistencyVerdict.OK) {
                    val active = requireUniformActiveOrNull(after.versions) ?: return after
                    cleanupStalePendingAboveActive(keyId, clients, after.versions, active)
                    return check(keyId, clients)
                }

                return after
            }

            ConsistencyVerdict.ROTATE_NEEDED -> {
                val versions = chk.versions
                val majorityActive = majorityActiveOrNull(versions)

                if (majorityActive != null) {
                    rollbackDownToActive(keyId, clients, versions, majorityActive)
                    cleanupStalePendingAboveActive(keyId, clients, versions, majorityActive)
                }

                return check(keyId, clients)
            }
        }
    }

    fun syncAll(keyId: String, clients: List<TKeeperClient>, generation: Int) {
        syncLocal(keyId, generation)
        clients.perform { it.keyGen.sync(keyId, generation) }
    }

    fun syncLocal(keyId: String, generation: Int) {
        db.vault.ops.runInTransaction {
            val pendingKey = db.vault.readPending(it, keyId, generation)
            if (pendingKey != null) {
                db.vault.promotePendingToActive(it, keyId, generation)
                db.meta.promotePendingMetaToActive(it, keyId, generation)
            } else {
                db.meta.dropPendingMeta(it, keyId, generation)
            }
        }
    }

    fun cleanupStalePendingAboveActive(
        keyId: String,
        clients: List<TKeeperClient>,
        versions: Map<Int, KeyVersion>,
        active: Int
    ) {
        val stalePendingGens = versions.values
            .mapNotNull { it.pendingGen }
            .filter { it > active }
            .distinct()

        if (stalePendingGens.isEmpty()) return

        for (pendingGen in stalePendingGens) {
            val someoneActiveAtThat = versions.values.any { it.activeGen == pendingGen }
            if (someoneActiveAtThat) continue

            val peerIds = versions.filterValues { it.pendingGen == pendingGen }.keys.toSet()
            if (peerIds.isEmpty()) continue

            if (peerIds.contains(initData.peerId)) {
                dropPendingLocal(keyId, pendingGen)
            }

            clients.performIndexed { client ->
                client.keyGen.dropPending(keyId, pendingGen)
            }
        }
    }

    fun rollbackDownToActive(
        keyId: String,
        clients: List<TKeeperClient>,
        versions: Map<Int, KeyVersion>,
        targetActive: Int
    ) {
        val abortGenByPeer: Map<Int, Int> = versions
            .filterValues { v -> (v.activeGen ?: Int.MIN_VALUE) > targetActive }
            .mapValues { (_, v) -> v.activeGen!! }

        val localActive = versions[initData.peerId]?.activeGen
        if (localActive != null && localActive > targetActive) {
            db.vault.ops.runInTransaction {
                db.vault.rollbackToGeneration(it, keyId, localActive)
                db.meta.rollbackToLatest(it, keyId, localActive)
                dropPendingLocal(it, keyId, localActive)
            }
        }

        val higherClients = clients.filter { abortGenByPeer.containsKey(it.peerId) }
        if (higherClients.isEmpty()) return

        higherClients.perform { client ->
            val gen = abortGenByPeer[client.peerId]!!
            client.keyGen.abort(keyId, gen)
        }
    }

    private fun readVersions(keyId: String, clients: List<TKeeperClient>): MutableMap<Int, KeyVersion> {
        return clients.performIndexed { it.keyGen.version(keyId) }
            .toMutableMap()
            .apply { put(initData.peerId, db.vault.readLatestVersion(keyId)) }
    }

    private fun dropPendingLocal(tx: Transaction, keyId: String, generation: Int) {
        db.vault.deletePending(tx, keyId, generation)
        db.meta.dropPendingMeta(tx, keyId, generation)
    }

    private fun dropPendingLocal(keyId: String, generation: Int) {
        db.vault.ops.runInTransaction { tx -> dropPendingLocal(tx, keyId, generation) }
    }

    private fun requireUniformActiveOrNull(versions: Map<Int, KeyVersion>): Int? {
        val activeSet = versions.values.map { it.activeGen }.toSet()
        if (activeSet.size != 1) return null

        return activeSet.first()
    }

    private fun maxSeenGen(versions: Map<Int, KeyVersion>): Int {
        return versions.values
            .flatMap { listOf(it.activeGen, it.pendingGen) }
            .filterNotNull()
            .maxOrNull()
            ?: 0
    }

    private fun majorityActiveOrNull(versions: Map<Int, KeyVersion>): Int? {
        val actives = versions.values.mapNotNull { it.activeGen }
        if (actives.isEmpty()) return null

        val counts = actives.groupingBy { it }.eachCount()
        val (winner, cnt) = counts.maxBy { it.value }
        return if (cnt > (versions.size / 2)) winner else null
    }
}