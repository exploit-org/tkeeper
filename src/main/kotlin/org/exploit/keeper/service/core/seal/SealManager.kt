package org.exploit.keeper.service.core.seal

import jakarta.inject.Singleton
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.common.StoreState
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.AutoProviderException
import org.exploit.keeper.exception.NotInitializedException
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.model.request.KeeperInitData
import org.exploit.keeper.model.seal.StatusResponse
import org.exploit.keeper.model.seal.init.SealInitData
import org.exploit.keeper.model.seal.progress.Progress
import org.exploit.keeper.service.core.seal.provider.SealProvider
import org.exploit.keeper.service.key.KeyOps
import java.util.concurrent.atomic.AtomicReference

@Singleton
class SealManager(
    private val provider: SealProvider,
    private val db: RocksKeyDB,
    private val config: KeeperConfig
) {
    private var ops: AtomicReference<KeyOps> = AtomicReference()

    @Volatile
    private var state: AtomicReference<StoreState> =
        if (db.isInitialized())
            AtomicReference(StoreState.SEALED)
        else
            AtomicReference(StoreState.UNINITIALIZED)

    private var progress: AtomicReference<Progress> = AtomicReference(provider.initialProgress())

    fun initialize(initData: KeeperInitData): SealInitData {
        if (db.isInitialized())
            throw TKeeperException(ErrorType.KEEPER_ALREADY_INITIALIZED)

        if (config.peers.any { it.id == initData.peerId })
            throw TKeeperException(ErrorType.INVALID_CONFIG, "Peer id ${initData.peerId} already exists ")

        return provider.initialize().also {
            state.set(StoreState.UNSEALED)
            ops.set(provider.keyOpsOrThrow())

            db.writeSentinel(provider.keyOpsOrThrow())
            db.writeIntegrityKey(provider.keyOpsOrThrow())
            db.writeHmacKey(provider.keyOpsOrThrow())

            db.writeInitData(
                peerId = initData.peerId,
                threshold = initData.threshold,
                total = initData.total
            )
        }
    }

    fun submit(payload64: String): Progress {
        if (!db.isInitialized())
            throw NotInitializedException()

        if (state.get() != StoreState.SEALED)
            throw TKeeperException(ErrorType.KEEPER_ALREADY_UNSEALED)

        if (provider.isAuto)
            throw AutoProviderException()

        val providerProgress = provider.submitPart(payload64)
        progress.set(providerProgress)

        if (!providerProgress.ready)
            return providerProgress

        try {
            if (!db.checkValidKey(provider.keyOpsOrThrow())) {
                seal()
                return provider.initialProgress()
            }
        } catch (e: Exception) {
            seal()
            return provider.initialProgress()
        }

        state.set(StoreState.UNSEALED)
        ops.set(provider.keyOpsOrThrow())
        return providerProgress
    }

    fun seal() {
        provider.seal()
        ops.set(null)
        progress.set(provider.initialProgress())
        state.set(StoreState.SEALED)
    }

    fun status(): StatusResponse =
        StatusResponse(
            sealedBy = provider.id,
            state = state.get() ?: StoreState.UNINITIALIZED,
            progress = progress.get() ?: provider.initialProgress()
        )
}