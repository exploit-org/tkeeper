package org.exploit.keeper.service.core.seal

import jakarta.annotation.PostConstruct
import jakarta.inject.Singleton
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.common.StoreState
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.NotInitializedException
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.model.request.KeeperInitData
import org.exploit.keeper.model.seal.StatusResponse
import org.exploit.keeper.model.seal.init.SealInitData
import org.exploit.keeper.model.seal.progress.Progress
import org.exploit.keeper.model.seal.progress.ReadyProgress
import org.exploit.keeper.service.core.seal.provider.SealProvider
import org.exploit.keeper.service.core.seal.provider.manual.ManualSealProvider
import org.exploit.keeper.service.key.dek.ChaCha20Poly1305DekOps
import org.exploit.keeper.service.key.dek.DekOps
import org.exploit.sodium.ReadOnlyBuffer
import org.exploit.sodium.SecretBox
import org.slf4j.Logger
import org.slf4j.LoggerFactory

@Singleton
class SealManager(
    private val provider: SealProvider,
    private val db: RocksKeyDB,
    private val config: KeeperConfig,
    private val memKey: ReadOnlyBuffer
) {
    fun initialize(initData: KeeperInitData): SealInitData {
        if (db.isInitialized())
            throw TKeeperException(ErrorType.KEEPER_ALREADY_INITIALIZED)

        if (config.peers.any { it.id == initData.peerId })
            throw TKeeperException(ErrorType.INVALID_CONFIG, "Peer id ${initData.peerId} already exists ")

        return provider.initialize().also {
            initializeDatabase(initData)
        }
    }

    fun submit(payload64: String): Progress {
        if (provider !is ManualSealProvider)
            throw TKeeperException(ErrorType.NOT_SUPPORTED_FOR_AUTO_PROVIDER)

        if (!db.isInitialized())
            throw NotInitializedException()

        if (db.state() == StoreState.UNSEALED)
            throw TKeeperException(ErrorType.KEEPER_ALREADY_UNSEALED)

        val providerProgress = provider.submitPart(payload64)

        if (!providerProgress.ready)
            return providerProgress

        unsealWithKekOps()
        return provider.currentProgress()
    }

    fun seal() {
        provider.seal()
        resetOps()
    }

    fun unseal(): Progress {
        if (provider is ManualSealProvider)
            throw TKeeperException(ErrorType.NOT_SUPPORTED_FOR_MANUAL_PROVIDER)

        unsealWithKekOps()

        if (db.state() == StoreState.SEALED)
            return ReadyProgress(false)

        return ReadyProgress(true)
    }

    fun status(): StatusResponse =
        StatusResponse(
            sealedBy = provider.id,
            state = db.state(),
            progress = provider.currentProgress()
        )

    @PostConstruct
    private fun autoInit() {
        if (!db.isInitialized()) {
            LOGGER.info("Not checking auto-unseal because keeper is not initialized")
            return
        }

        val property = System.getProperty(AUTO_UNSEAL_PROPERTY)?.toBoolean() ?: true

        if (provider is ManualSealProvider || !property) {
            LOGGER.info("Auto-unseal is disabled or not supported by this provider")
            return
        }

        unsealWithKekOps()
    }

    private fun initializeDatabase(initData: KeeperInitData) {
        val kekOps = provider.kekOps()
        val secretKey = SecretBox.of(db.writeMasterKey(kekOps), memKey.read(), true)

        val dekOps = ChaCha20Poly1305DekOps(secretKey, memKey::read)
        updateOps(dekOps)

        db.writeSentinel(dekOps)
        db.writeIntegrityKey(dekOps)
        db.writeHmacKey(dekOps)

        db.writeInitData(
            peerId = initData.peerId,
            threshold = initData.threshold,
            total = initData.total
        )
    }

    private fun unsealWithKekOps() {
        val kekOps = provider.kekOps()

        val dekOps = try {
            val mk = SecretBox.of(db.readMasterKey(kekOps), memKey.read(), true)
            ChaCha20Poly1305DekOps(mk, memKey::read)
        } catch (_ : Exception) {
            seal()
            return
        }

        try {
            if (!db.checkValidKey(dekOps)) {
                resetProgress(dekOps)
                return
            }
        } catch (_: Exception) {
            resetProgress(dekOps)
            return
        }

        updateOps(dekOps)
    }

    private fun resetOps() {
        db.ops.set(null)
    }

    private fun updateOps(dekOps: DekOps) {
        db.ops.set(dekOps)
    }

    private fun resetProgress(dekOps: DekOps) {
        seal()
        dekOps.destroy()
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(SealManager::class.java)

        const val AUTO_UNSEAL_PROPERTY = "keeper.auto.unseal"
    }
}