package org.exploit.keeper.service.core

import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.status.KeyStatus
import org.exploit.keeper.db.MetaStore
import org.exploit.keeper.db.MetaStore.Companion.KEYSET_META_VERSION_PREFIX
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.extractCurveAndDestroy
import org.exploit.keeper.extension.objectMapper
import org.exploit.keeper.model.inventory.AssetInventory
import org.exploit.keeper.model.inventory.AssetInventoryItem
import org.exploit.keeper.model.inventory.AssetInventoryPage
import org.exploit.keeper.model.keyset.KeySetMeta
import org.exploit.keeper.service.integrity.KeeperSignatureService
import org.exploit.keeper.util.SignedSerializer
import org.exploit.keeper.util.validation.InputValidator
import org.exploit.tss.util.Hash
import java.nio.charset.StandardCharsets
import java.time.Instant
import java.util.*

@Singleton
class KeeperComplianceService(
    private val db: RocksKeyDB,
    private val keeper: KeeperService,
    private val signatures: KeeperSignatureService
) {
    private val initData by lazy { db.readInitData() }

    fun allowedForApplyOperations(keyId: String): Boolean {
        val currentVersion = db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        val meta = db.meta.loadKeysetMeta(keyId) ?: return (currentVersion == 0)

        if (!meta.enabled)
            return false

        return meta.policy?.apply?.expired()?.not() ?: true
    }

    fun allowedForProcessOperation(logicalId: String, generation: Int): Boolean {
        val currentGen = db.vault.readLatestVersion(logicalId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, logicalId)

        val head = db.meta.loadKeysetMeta(logicalId) ?: return (currentGen == 0)
        if (!head.enabled) return false
        if (generation == currentGen) return true

        val policy = head.policy
        if (policy?.allowHistoricalProcess == false)
            return false

        return policy?.process?.expired()?.not() ?: true
    }

    fun keyStatus(logicalId: String, generation: Int): KeyStatus {
        val currentGen = db.vault.readLatestVersion(logicalId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, logicalId)

        if (generation == 0) return KeyStatus.ACTIVE

        val meta = db.meta.loadVersionedMeta(logicalId, generation)
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, "$logicalId/$generation")

        return keyStatusFrom(meta, generation, currentGen)
    }

    fun loadAssetInventory(
        includeHistorical: Boolean,
        logicalId: String? = null,
        assetOwner: String? = null,
        lastSeen: String? = null,
        limit: Int = 200
    ): AssetInventoryPage {
        keeper.ensureReady()

        val (items, nextCursor, hasMore) = if (includeHistorical) {
            val id = validateLogicalId(logicalId, "logicalId")
                ?: throw TKeeperException(ErrorType.INVALID_CURSOR, "logicalId is required for includeHistorical=true")

            val owner = validateOwner(assetOwner)

            if (owner != null) {
                val head = db.meta.loadKeysetMeta(id)
                if (head?.assetOwner != owner) {
                    Triple(emptyList(), null, false)
                } else {
                    loadInventoryFromVersionedMetaPaged(id, lastSeen, limit)
                }
            } else {
                loadInventoryFromVersionedMetaPaged(id, lastSeen, limit)
            }
        } else {
            val owner = validateOwner(assetOwner)

            when {
                owner != null -> loadInventoryFromOwnerIndexPaged(owner, lastSeen, limit)
                else -> loadInventoryFromHeadMetaPaged(logicalId, lastSeen, limit)
            }
        }

        val inv = AssetInventory(
            generatedAt = Instant.now().epochSecond,
            peerId = initData.peerId,
            threshold = initData.threshold,
            totalPeers = initData.total,
            items = items
        )

        return AssetInventoryPage(inv, nextCursor, hasMore)
    }

    private fun keyStatusFrom(meta: KeySetMeta, generation: Int, currentGen: Int): KeyStatus {
        if (db.destroy.isCommitted(meta.logicalId, generation))
            return KeyStatus.DESTROYED

        if (!meta.enabled) return KeyStatus.DISABLED

        val isCurrent = (generation == currentGen)

        val applyTimeExpired = (meta.policy?.apply?.expired() == true)
        val applyExpired = !isCurrent || applyTimeExpired

        val processExpired = (!isCurrent) && (meta.policy?.process?.expired() == true)

        return when {
            processExpired -> KeyStatus.EXPIRED
            applyExpired -> KeyStatus.APPLY_EXPIRED

            else -> KeyStatus.ACTIVE
        }
    }

    private fun loadInventoryFromOwnerIndexPaged(
        owner: String,
        lastSeen: String?,
        limit: Int
    ): Triple<List<AssetInventoryItem>, String?, Boolean> {
        val cursorLogical = validateLogicalId(lastSeen, "lastSeen")

        val ownerEnc = encodeOwner(owner)
        val prefixStr = "o:idx:$ownerEnc:"
        val cursorKey = cursorLogical?.let { "$prefixStr$it" }

        val page = db.ownerIndex.listByOwner(owner = owner, limit = limit, cursor = cursorKey)
        val ids = page.items

        val out = ArrayList<AssetInventoryItem>(ids.size)
        for (logicalId in ids) {
            val payload = db.meta.loadSignedKeyMeta(logicalId) ?: continue
            val tampered = !signatures.verify(Hash.sha256(payload.data), payload.signature, payload.keyVersion)
            val meta = objectMapper.readValue(payload.data, KeySetMeta::class.java)

            val gen = meta.currentGeneration

            out += AssetInventoryItem(
                logicalId = logicalId,
                status = keyStatus(logicalId, gen),
                currentGeneration = gen,
                curve = db.vault.readKey(logicalId, gen)?.extractCurveAndDestroy(),
                createdAt = meta.createdAt,
                updatedAt = meta.updatedAt,
                policy = meta.policy,
                hasActiveKey = db.vault.hasKey(logicalId),
                lastPendingGeneration = db.vault.findLatestPendingGeneration(logicalId),
                assetOwner = meta.assetOwner,
                tampered = tampered
            )
        }

        val nextCursor = page.next?.takeIf { it.startsWith(prefixStr) }?.substring(prefixStr.length)
        val hasMore = out.size == limit
        return Triple(out, nextCursor, hasMore)
    }

    private fun loadInventoryFromHeadMetaPaged(
        prefixFilter: String?,
        lastSeen: String?,
        limit: Int
    ): Triple<List<AssetInventoryItem>, String?, Boolean> {
        val prefix = MetaStore.KEYSET_META_PREFIX

        val scope = validateLogicalId(prefixFilter, "logicalId")
        val cursor = validateLogicalId(lastSeen, "lastSeen")

        if (scope != null && cursor != null && !cursor.startsWith(scope)) {
            throw TKeeperException(ErrorType.INVALID_CURSOR, "Invalid cursor scope")
        }

        val seekStr = when {
            cursor != null -> prefix + cursor
            scope != null  -> prefix + scope
            else -> prefix
        }

        val out = ArrayList<AssetInventoryItem>(limit)
        var nextCursor: String? = null

        db.meta.ops.newIterator().use {
            it.seek(seekStr.toByteArray(StandardCharsets.UTF_8))

            if (cursor != null && it.isValid) {
                val keyStr = String(it.key(), StandardCharsets.UTF_8)
                if (keyStr == prefix + cursor) it.next()
            }

            while (it.isValid && out.size < limit) {
                val keyStr = String(it.key(), StandardCharsets.UTF_8)
                if (!keyStr.startsWith(prefix)) break

                val logicalId = keyStr.substring(prefix.length)

                if (scope != null && !logicalId.startsWith(scope)) break

                val (meta, tampered) = deserializeMeta(it.value())
                val gen = meta.currentGeneration

                out += AssetInventoryItem(
                    logicalId = logicalId,
                    status = keyStatus(logicalId, gen),
                    currentGeneration = gen,
                    curve = db.vault.readKey(logicalId, gen)?.extractCurveAndDestroy(),
                    createdAt = meta.createdAt,
                    updatedAt = meta.updatedAt,
                    policy = meta.policy,
                    hasActiveKey = db.vault.hasKey(logicalId),
                    lastPendingGeneration = db.vault.findLatestPendingGeneration(logicalId),
                    assetOwner = meta.assetOwner,
                    tampered = tampered
                )

                nextCursor = logicalId
                it.next()
            }
        }

        val hasMore = out.size == limit
        return Triple(out, nextCursor, hasMore)
    }

    private fun loadInventoryFromVersionedMetaPaged(
        logicalId: String,
        lastSeenGenStr: String?,
        limit: Int
    ): Triple<List<AssetInventoryItem>, String?, Boolean> {
        val prefix = KEYSET_META_VERSION_PREFIX
        val scopedPrefixStr = "$prefix${logicalId}__version__"

        val lastSeenGen = validateGenerationCursor(lastSeenGenStr, "lastSeen")

        val out = ArrayList<AssetInventoryItem>(limit)
        var nextCursor: String? = null

        val pendingGen = db.vault.findLatestPendingGeneration(logicalId)
        val currentGen = db.vault.readLatestVersion(logicalId).activeGen ?: 0
        val hasAny = db.vault.hasKey(logicalId)

        db.meta.ops.newIterator().use { it ->
            if (lastSeenGen == null) {
                val upper = (scopedPrefixStr + "\uFFFF").toByteArray(StandardCharsets.UTF_8)
                it.seek(upper)
                if (!it.isValid) it.seekToLast()

                while (it.isValid && !String(it.key(), StandardCharsets.UTF_8).startsWith(scopedPrefixStr)) {
                    it.prev()
                }
            } else {
                val targetKey = MetaStore.KEYSET_META_VERSION.format(logicalId, lastSeenGen)
                    .toByteArray(StandardCharsets.UTF_8)

                it.seek(targetKey)
                if (it.isValid) it.prev() else it.seekToLast()

                while (it.isValid && !String(it.key(), StandardCharsets.UTF_8).startsWith(scopedPrefixStr)) {
                    it.prev()
                }
            }

            while (it.isValid && out.size < limit) {
                val keyStr = String(it.key(), StandardCharsets.UTF_8)
                if (!keyStr.startsWith(scopedPrefixStr)) break

                val pair = parseKeysetMetaVersionKey(keyStr)
                if (pair == null) {
                    it.prev()
                    continue
                }

                val (_, gen) = pair
                val (meta, tampered) = deserializeMeta(it.value())

                out += AssetInventoryItem(
                    logicalId = logicalId,
                    status = keyStatusFrom(meta, gen, currentGen),
                    currentGeneration = gen,
                    curve = db.vault.readKey(logicalId, gen)?.extractCurveAndDestroy(),
                    createdAt = meta.createdAt,
                    updatedAt = meta.updatedAt,
                    policy = meta.policy,
                    hasActiveKey = if (gen == currentGen) hasAny else db.vault.hasKey(logicalId, gen),
                    lastPendingGeneration = pendingGen,
                    assetOwner = meta.assetOwner,
                    tampered = tampered
                )

                nextCursor = gen.toString()
                it.prev()
            }
        }

        val hasMore = out.size == limit
        return Triple(out, nextCursor, hasMore)
    }

    private fun deserializeMeta(signed: ByteArray): Pair<KeySetMeta, Boolean> {
        val signedValue = SignedSerializer.deserialize(signed)
        val tampered = !signatures.verify(Hash.sha256(signedValue.data), signedValue.signature, signedValue.keyVersion)

        val meta = objectMapper.readValue(signedValue.data, KeySetMeta::class.java)

        return meta to tampered
    }

    private fun parseKeysetMetaVersionKey(key: String): Pair<String, Int>? {
        val prefix = KEYSET_META_VERSION_PREFIX
        if (!key.startsWith(prefix)) return null

        val rest = key.removePrefix(prefix)
        val sep = "__version__"
        val idx = rest.lastIndexOf(sep)
        if (idx <= 0) return null

        val logicalId = rest.take(idx)
        val gen = rest.substring(idx + sep.length).toIntOrNull() ?: return null
        return logicalId to gen
    }

    private fun validateOwner(value: String?): String? {
        if (value.isNullOrBlank()) return null
        if (!InputValidator.isValidAssetOwner(value)) {
            throw TKeeperException(ErrorType.INVALID_CURSOR, "Invalid assetOwner")
        }
        return value
    }

    private fun encodeOwner(owner: String): String {
        val bytes = owner.toByteArray(StandardCharsets.UTF_8)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes)
    }

    private companion object {
        fun validateLogicalId(value: String?, field: String): String? {
            if (value.isNullOrBlank()) return null
            if (!InputValidator.isValidKeyId(value)) {
                throw TKeeperException(ErrorType.INVALID_CURSOR, "Invalid $field")
            }
            return value
        }

        fun validateGenerationCursor(value: String?, field: String): Int? {
            if (value.isNullOrBlank()) return null
            val gen = value.toIntOrNull()
                ?: throw TKeeperException(ErrorType.INVALID_CURSOR, "Invalid $field")
            if (gen < 0) throw TKeeperException(ErrorType.INVALID_CURSOR, "Invalid $field")
            return gen
        }
    }
}