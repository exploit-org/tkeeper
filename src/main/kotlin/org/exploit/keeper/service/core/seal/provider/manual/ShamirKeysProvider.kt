package org.exploit.keeper.service.core.seal.provider.manual

import org.exploit.keeper.exception.SealedException
import org.exploit.keeper.model.seal.init.SealInitData
import org.exploit.keeper.model.seal.init.ShamirInitData
import org.exploit.keeper.model.seal.progress.Progress
import org.exploit.keeper.model.seal.progress.ShamirUnsealProgress
import org.exploit.keeper.service.key.kek.ChaCha20Poly1305KekOps
import org.exploit.keeper.service.key.kek.KekOps
import org.exploit.keeper.util.crypto.Shamir
import org.exploit.sodium.ReadOnlyBuffer
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.util.concurrent.atomic.AtomicReference

class ShamirKeysProvider(
    private val total: Int = 5,
    private val threshold: Int = 3
) : ManualSealProvider {
    override val id: String = ID

    private val progress: AtomicReference<Progress> = AtomicReference(initialProgress())

    private val parts = mutableListOf<Shamir.Share>()
    private var ops: AtomicReference<KekOps> = AtomicReference<KekOps>()

    override fun kekOpsOrNull(): KekOps? = ops.get()

    override fun initialize(): SealInitData {
        val secretKey = Shamir.generateSecretKey()
        val split = Shamir.split(secretKey, total, threshold)

        ops.set(ChaCha20Poly1305KekOps(ReadOnlyBuffer(secretKey)))

        return ShamirInitData(
            threshold = threshold,
            total = total,
            shares64 = Shamir.encodeShares(split)
        )
    }

    override fun currentProgress(): Progress {
        return progress.get()
    }

    override fun kekOps(): KekOps {
        return kekOpsOrNull() ?: throw SealedException()
    }

    override fun initialProgress(): Progress =
        ShamirUnsealProgress(threshold = threshold, total = total)

    override fun submitPart(payload64: String): ShamirUnsealProgress {
        parts.add(Shamir.Share.fromBase64(payload64))
        return unseal().also { progress.set(it) }
    }

    override fun seal() {
        ops.set(null)
        progress.set(initialProgress())
        parts.clear()
    }

    override fun unseal(): ShamirUnsealProgress {
        return if (parts.size < threshold) {
            ShamirUnsealProgress(progress = parts.size, total = total, threshold = threshold)
        } else {
            try {
                val secretKey = ReadOnlyBuffer(Shamir.combine(parts))
                ops.set(ChaCha20Poly1305KekOps(secretKey))

                ShamirUnsealProgress(threshold = threshold, progress = threshold, total = total, ready = true)
            } catch (e: Exception) {
                LOGGER.error("Couldn't unseal storage. Invalid key?", e)
                ShamirUnsealProgress(threshold, total, 0, false)
            } finally {
                parts.clear()
            }
        }
    }

    companion object {
        const val ID = "shamir"

        private val LOGGER: Logger = LoggerFactory.getLogger(ShamirKeysProvider::class.java)
    }
}