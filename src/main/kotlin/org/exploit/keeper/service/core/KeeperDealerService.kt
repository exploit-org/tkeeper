package org.exploit.keeper.service.core

import jakarta.inject.Singleton
import org.exploit.ed25519.Ed25519PointOps
import org.exploit.ed25519.rfc8032.Ed25519Clamp
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.dkg.ConsistencyVerdict
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodeBase64
import org.exploit.keeper.extension.crypto.toBigInt
import org.exploit.keeper.extension.perform
import org.exploit.keeper.extension.use
import org.exploit.keeper.model.keygen.import.ImportShare
import org.exploit.keeper.model.keyset.KeySetMeta
import org.exploit.keeper.model.keyset.KeySetPolicy
import org.exploit.keeper.model.request.Store
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.util.KeySerializer
import org.exploit.keeper.util.validation.InputValidator
import org.exploit.tss.curve.PointOps
import org.exploit.tss.shamir.ECShamirKeySplitter
import org.exploit.tss.shamir.model.ECKeySplitResult
import java.time.Instant

@Singleton
class KeeperDealerService(
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val keeper: KeeperService,
    private val consistency: KeeperConsistencyService
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun import(body: ImportShare) {
        keeper.ensureReady()
        val keyId = body.keyId

        db.vault.ops.runInTransaction {
            val v = db.vault.readLatestVersion(it, keyId)
            if (v.activeGen != null || v.pendingGen != null) {
                throw TKeeperException(ErrorType.KEY_ALREADY_EXISTS, keyId)
            }

            body.value.use { v ->
                val serialized = KeySerializer.serialize(body.curve, v)
                db.vault.saveKey(it, keyId, 1, serialized)
                db.meta.setCurrentGeneration(it, keyId, 1, body.policy)
            }
        }
    }

    fun revertShare(keyId: String) {
        db.vault.ops.runInTransaction {
            val v = db.vault.readLatestVersion(it, keyId)
            val active = v.activeGen
            val pending = v.pendingGen

            if (active != null && active > 1)
                return@runInTransaction

            if (active != null && active == 0)
                return@runInTransaction

            if (pending != null && pending > 1)
                return@runInTransaction

            db.vault.deletePending(it, keyId, 1)
            db.meta.dropPendingMeta(it, keyId, 1)

            if (active == 1) {
                db.vault.rollbackToGeneration(it, keyId, 1)
                db.meta.rollbackToLatest(it, keyId, 1)
                return@runInTransaction
            }
        }
    }

    fun store(store: Store) {
        keeper.ensureReady()

        val keyId = store.keyId.trim().lowercase()

        if (!InputValidator.isValidKeyId(keyId))
            throw TKeeperException(ErrorType.INVALID_KEY_ID)

        val remotePeers = clients.findHealthy(initData.total - 1)

        val chk = consistency.tryAutoFix(keyId, remotePeers)
        if (chk.verdict != ConsistencyVerdict.MISSING) {
            throw TKeeperException(ErrorType.KEY_ALREADY_EXISTS, keyId)
        }

        store.value64.decodeBase64().use { seed ->
            val curve = KeeperCurve.fromName(store.curve)

            val result = when (store.curve) {
                CurveName.ED25519 -> clampAndSplit(seed)
                else -> splitKey(curve, seed)
            }

            val sharesByPeerId: Map<Int, ByteArray> = result.shares().associate { s ->
                s.index() to s.share().toByteArray()
            }

            val localShare = sharesByPeerId[initData.peerId]
                ?: throw TKeeperException(ErrorType.SHARE_NOT_FOUND, "${initData.peerId}")

            try {
                storePendingLocal(
                    keyId = keyId,
                    curve = store.curve,
                    share = localShare,
                    policy = store.policy
                )

                remotePeers.perform { client ->
                    val share = sharesByPeerId[client.peerId]
                        ?: throw TKeeperException(ErrorType.SHARE_NOT_FOUND, "${client.peerId}")

                    client.dealer.store(
                        ImportShare(
                            keyId = keyId,
                            curve = store.curve,
                            value = share,
                            policy = store.policy
                        )
                    )
                }

                sync(keyId)
                remotePeers.perform { it.dealer.sync(keyId) }
            } catch (e: Exception) {
                revertCreateSafe(keyId, remotePeers)

                throw TKeeperException(
                    ErrorType.INCONSISTENT_KEEPER,
                    "Trusted-dealer import failed for keyId=${store.keyId}. Run /fix or retry after cleanup.",
                    e
                )
            }
        }
    }

    fun sync(keyId: String) {
        db.vault.ops.runInTransaction {
            val generation = 1

            val v = db.vault.readLatestVersion(it, keyId)
            val active = v.activeGen
            val pending = v.pendingGen

            if (active != null && (active > generation || active == 0)) return@runInTransaction
            if (pending != null && pending > generation) return@runInTransaction

            if (active == generation) {
                db.meta.promotePendingMetaToActive(it, keyId, generation)
                db.vault.deletePending(it, keyId, generation)
                db.meta.dropPendingMeta(it, keyId, generation)
                return@runInTransaction
            }

            if (pending == generation) {
                val raw = db.vault.readPending(it, keyId, generation)
                if (raw != null) {
                    db.vault.promotePendingToActive(it, keyId, generation)
                } else {
                    db.meta.dropPendingMeta(it, keyId, generation)
                    return@runInTransaction
                }

                val promoted = db.meta.promotePendingMetaToActive(it, keyId, generation)
                if (promoted == null) {
                    val head = db.meta.loadKeysetMeta(it, keyId)
                    val policy = head?.policy
                    db.meta.setCurrentGeneration(it, keyId, generation, policy)
                    db.meta.dropPendingMeta(it, keyId, generation)
                }

                db.vault.deletePending(it, keyId, generation)
                db.meta.dropPendingMeta(it, keyId, generation)
            }
        }
    }

    private fun storePendingLocal(
        keyId: String,
        curve: CurveName,
        share: ByteArray,
        policy: KeySetPolicy?,
    ) {
        val serialized = KeySerializer.serialize(curve, share)

        db.vault.ops.runInTransaction {
            db.vault.savePending(it, keyId, 1, serialized)

            val now = Instant.now().epochSecond
            val meta = KeySetMeta(
                logicalId = keyId,
                currentGeneration = 1,
                enabled = true,
                createdAt = now,
                updatedAt = now,
                policy = policy
            )

            db.meta.savePendingKeysetMeta(it, meta)
        }
    }

    private fun revertCreateSafe(keyId: String, peers: List<TKeeperClient>) {
        revertLocalSafe(keyId)

        try {
            peers.perform { it.dealer.revert(keyId) }
        } catch (_: Exception) {
        }
    }

    private fun revertLocalSafe(keyId: String) {
        db.vault.ops.runInTransaction {
            val v = db.vault.readLatestVersion(it, keyId)
            val active = v.activeGen
            val pending = v.pendingGen

            if (active != null && active > 1) return@runInTransaction
            if (active != null && active == 0) return@runInTransaction
            if (pending != null && pending > 1) return@runInTransaction

            db.vault.deletePending(it, keyId, 1)
            db.meta.dropPendingMeta(it, keyId, 1)

            if (active == 1) {
                db.vault.rollbackToGeneration(it, keyId, 1)
                db.meta.rollbackToLatest(it, keyId, 1)
            }
        }
    }

    private fun clampAndSplit(seed: ByteArray): ECKeySplitResult<Ed25519PointOps> {
        val clamped = Ed25519Clamp.toBigInt(seed)
        val splitter = constructKeySplitter(KeeperCurve.ED25519)

        return splitter.splitKey(clamped)
    }

    private fun <P: PointOps<P>> splitKey(curve: KeeperCurve<P>, seed: ByteArray): ECKeySplitResult<P> {
        val splitter = constructKeySplitter(curve)
        return splitter.splitKey(seed.toBigInt())
    }

    private fun <P : PointOps<P>> constructKeySplitter(curve: KeeperCurve<P>): ECShamirKeySplitter<P> {
        return ECShamirKeySplitter(
            curve.params.curveOrder,
            curve.params.g,
            initData.threshold,
            initData.total
        )
    }
}