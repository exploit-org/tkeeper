package org.exploit.keeper.service.core

import jakarta.inject.Singleton
import org.exploit.ed25519.Ed25519PointOps
import org.exploit.ed25519.rfc8032.Ed25519Clamp
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.toBigInt
import org.exploit.keeper.extension.crypto.decodeBase64
import org.exploit.keeper.extension.ignoreExceptions
import org.exploit.keeper.extension.perform
import org.exploit.keeper.extension.use
import org.exploit.keeper.model.keygen.StoreRaw
import org.exploit.keeper.model.request.Store
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.util.KeySerializer
import org.exploit.tss.curve.PointOps
import org.exploit.tss.shamir.ECShamirKeySplitter
import org.exploit.tss.shamir.model.ECKeySplitResult

@Singleton
class KeeperStorageService(
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val keeper: KeeperInitService
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun storeShare(store: StoreRaw) {
        keeper.ensureReady()
        store.value.use {
            storeShare(store.keyId, store.curve, it)
        }
    }

    fun deleteShare(keyId: String) {
        keeper.ensureReady()
        db.storage.delete(keyId)
    }

    fun delete(keyId: String) {
        keeper.ensureReady()
        db.storage.delete(keyId)

        val healthy = clients.findAllHealthy()
        healthy.perform {
            it.keyStore.revert(keyId)
                .ignoreExceptions()
        }
    }

    fun store(store: Store) {
        keeper.ensureReady()

        if (db.storage.hasKey(store.keyId))
            throw TKeeperException(ErrorType.KEY_ALREADY_EXISTS, store.keyId)

        store.value64.decodeBase64().use {
            val curve = KeeperCurve.fromName(store.curve)

            val result = when (store.curve) {
                CurveName.ED25519 -> clampAndSplit(it)
                else -> splitKey(curve, it)
            }

            val thisShare = result.shares().firstOrNull { s -> s.index() == initData.peerId }
                ?: throw TKeeperException(ErrorType.SHARE_NOT_FOUND, "${initData.peerId}")

            storeShare(store.keyId, store.curve, thisShare.share().toByteArray())

            val shares = result.shares().filter { s ->
                s.index() != initData.peerId
            }.associate { share ->
                share.index() to share.share().toByteArray()
            }

            val peers = clients.find(shares.keys)

            try {
                peers.perform { client ->
                    val peerShare = shares[client.peerId]
                        ?: throw TKeeperException(ErrorType.SHARE_NOT_FOUND, "${client.peerId}")

                    client.keyStore.store(
                        StoreRaw(
                            keyId = store.keyId,
                            curve = store.curve,
                            value = peerShare
                        )
                    )
                }
            } catch (e: Exception) {
                revert(store.keyId)
                throw e
            }
        }
    }

    private fun revert(keyId: String) {
        db.storage.delete(keyId)

        val clients = clients.findAll()

        try {
            clients.perform {
                it.keyStore.revert(keyId)
            }
        } catch (ignore: Exception) {
            // not all successful it maybe okay
        }
    }

    private fun clampAndSplit(seed: ByteArray): ECKeySplitResult<Ed25519PointOps> {
        val clamped = Ed25519Clamp.toBigInt(seed)
        val splitter = constructKeySplitter(KeeperCurve.ED25519)

        return splitter.splitKey(clamped)
    }

    private fun <P: PointOps<P>> splitKey(curve: KeeperCurve<P>, seed: ByteArray): ECKeySplitResult<P> {
        val splitter = constructKeySplitter(curve)
        return splitter.splitKey(seed.toBigInt())
    }

    private fun <P : PointOps<P>> constructKeySplitter(curve: KeeperCurve<P>): ECShamirKeySplitter<P> {
        return ECShamirKeySplitter(
            curve.params.curveOrder,
            curve.params.g,
            initData.threshold,
            initData.total
        )
    }

    private fun storeShare(keyId: String, curve: CurveName, value: ByteArray) {
        val serialized = KeySerializer.serialize(curve, value)
        db.storage.save(keyId, serialized)
    }
}