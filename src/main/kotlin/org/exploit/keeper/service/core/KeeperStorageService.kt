package org.exploit.keeper.service.core

import io.sentry.Sentry
import jakarta.inject.Singleton
import org.exploit.ed25519.Ed25519PointOps
import org.exploit.ed25519.rfc8032.Ed25519Clamp
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.*
import org.exploit.keeper.model.request.Store
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.util.KeySerializer
import org.exploit.tss.curve.PointOps
import org.exploit.tss.shamir.ECShamirKeySplitter
import org.exploit.tss.shamir.model.ECKeySplitResult
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class KeeperStorageService(
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val keeper: KeeperInitService
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun storeShare(store: Store) {
        keeper.ensureReady()
        store.value64.decodeBase64().use {
            storeShare(store.keyId, store.curve, it)
        }
    }

    fun deleteShare(keyId: String) {
        keeper.ensureReady()
        db.storage.delete(keyId)
    }

    fun delete(keyId: String): Mono<Void> {
        keeper.ensureReady()
        db.storage.delete(keyId)

        return Flux.fromIterable(clients.findAll())
            .flatMap { it.keyStore.revert(keyId).toMono() }
            .doOnError(Sentry::captureException)
            .onErrorResume { Mono.empty() }
            .then()
    }

    fun store(store: Store): Mono<Void> {
        keeper.ensureReady()

        if (db.storage.hasKey(store.keyId))
            throw TKeeperException(400, "Key with id ${store.keyId} already exists")

        return store.value64.decodeBase64().use {
            val curve = KeeperCurve.fromName(store.curve)

            val result = when (store.curve) {
                CurveName.ED25519 -> clampAndSplit(it)
                else -> splitKey(curve, it)
            }

            val thisShare = result.shares().firstOrNull { it.index() == initData.peerId }
                ?: throw TKeeperException(500, "Share for peer ${initData.peerId} not found in split result")

            storeShare(store.keyId, store.curve, thisShare.share().toByteArray())

            Flux.fromIterable(result.shares())
                .filter { share -> share.index() != initData.peerId }
                .flatMap { share ->
                    clients.find(share.index()).keyStore
                        .store(
                            Store(
                                keyId = store.keyId,
                                curve = store.curve,
                                value64 = share.share().toByteArray().toBase64(),
                            )
                        )
                        .toMono()
                }
                .doOnError(Sentry::captureException)
                .onErrorResume {
                    revert(store.keyId).then(Mono.error(TKeeperException(500, "Failed to store key share")))
                }
                .then()
        }
    }

    private fun revert(keyId: String): Mono<Void> {
        db.storage.delete(keyId)

        return Flux.fromIterable(clients.findAll())
            .flatMap { it.keyStore.revert(keyId).toMono() }
            .onErrorResume { Mono.empty() }
            .then()
    }

    private fun clampAndSplit(seed: ByteArray): ECKeySplitResult<Ed25519PointOps> {
        val clamped = Ed25519Clamp.toBigInt(seed)
        val splitter = constructKeySplitter(KeeperCurve.ED25519)

        return splitter.splitKey(clamped)
    }

    private fun <P: PointOps<P>> splitKey(curve: KeeperCurve<P>, seed: ByteArray): ECKeySplitResult<P> {
        val splitter = constructKeySplitter(curve)
        return splitter.splitKey(seed.toBigInt())
    }

    private fun <P : PointOps<P>> constructKeySplitter(curve: KeeperCurve<P>): ECShamirKeySplitter<P> {
        return ECShamirKeySplitter(
            curve.params.curveOrder,
            curve.params.g,
            initData.threshold,
            initData.total
        )
    }

    private fun storeShare(keyId: String, curve: CurveName, value: ByteArray) {
        val serialized = KeySerializer.serialize(curve, value)
        db.storage.save(keyId, serialized)
    }


    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(KeeperStorageService::class.java)
    }
}