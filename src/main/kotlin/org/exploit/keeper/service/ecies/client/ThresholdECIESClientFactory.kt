package org.exploit.keeper.service.ecies.client

import org.exploit.ecies.ThresholdECIESClient
import org.exploit.ecies.context.ECIESContext
import org.exploit.ecies.context.aggregator.InMemoryPartialDecryptContext
import org.exploit.ecies.context.crypto.InMemoryCryptoContext
import org.exploit.keeper.constant.CipherType
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.ECIESCipher
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.sodium.ReadOnlyBuffer
import org.exploit.sodium.SecretBox
import org.exploit.tss.curve.ec.WeierstrassCurveParams
import org.exploit.tss.curve.ec.WeierstrassPointOps
import kotlin.reflect.KClass

abstract class ThresholdECIESClientFactory<P : WeierstrassPointOps<P>>(
    private val db: RocksKeyDB,
    private val memKey: ReadOnlyBuffer,
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun createClient(keyId: String, publicKeyBytes: ByteArray?, cipherType: CipherType, participants: List<Int>): ThresholdECIESClient<P> {
        val peerId = initData.peerId
        val cipher = ECIESCipher.fromType(cipherType)

        if (!participants.contains(peerId))
            throw TKeeperException(400, "Not a participant")

        val share = db.storage.get(keyId)?.toPrivateKey()
            ?: throw TKeeperException(400, "Such key share doesn't exist")

        val curve = KeeperCurve.fromName(share.curve)
        val expectedOps = opsClazz()

        if (curve.opsClass != expectedOps)
            throw TKeeperException(400, "Unsupported point ops ECIES")

        val curveParams = curve.params as? WeierstrassCurveParams<P>
            ?: throw TKeeperException(400, "Unsupported curve type for ECIES")

        val cryptoContext = InMemoryCryptoContext.builder<P>()
            .curve(curveParams)
            .memKey { memKey.read() }
            .ski(SecretBox.of(share.ski, memKey.read(), true))
            .publicKey(publicKeyBytes?.let { curveParams.decodePoint(publicKeyBytes) as P })
            .idx(peerId)
            .participants(participants)
            .build()

        val context = ECIESContext(cryptoContext, InMemoryPartialDecryptContext())

        return ThresholdECIESClient(context, cipher)
    }

    abstract fun curve(): CurveName

    protected abstract fun opsClazz(): KClass<P>
}