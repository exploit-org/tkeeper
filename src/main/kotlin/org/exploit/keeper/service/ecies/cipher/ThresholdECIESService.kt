package org.exploit.keeper.service.ecies.cipher

import org.exploit.ecies.model.CipherText
import org.exploit.ecies.model.PartialDecrypt
import org.exploit.keeper.constant.CipherType
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.isCipherText
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.ecies.PartialDecryptRequest
import org.exploit.keeper.model.ecies.PartiallyDecrypted
import org.exploit.keeper.model.ecies.dleq.DleqProofDto
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.ecies.client.ThresholdECIESClientFactory
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.proof.model.DleqProof
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

abstract class ThresholdECIESService<P : WeierstrassPointOps<P>>(
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val publicKeyService: PublicKeyService
): ThresholdCipherService {
    private val initData by lazy {
        db.readInitData()
    }

    abstract fun curve(): KeeperCurve<P>

    override fun curveName(): CurveName = curve().name

    override fun encrypt(keyId: String, cipherType: CipherType, plaintext: ByteArray): Mono<CipherText> {
        return publicKeyService.getPublicKey(keyId)
            .map {
                val client = factory().createClient(keyId, it.data, cipherType, listOf(initData.peerId))
                client.encryptor().encrypt(plaintext)
            }
    }

    override fun decrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray): Mono<ByteArray> {
        if (!ciphertext.isCipherText())
            throw TKeeperException(400, "Invalid ciphertext")

        return clients.findThreshold().flatMap { peers ->
            val participants = peers.map { it.peerId } + initData.peerId
            val client = factory().createClient(keyId, null, cipherType, participants)

            val request = PartialDecryptRequest(
                keyId = keyId,
                cipherType = cipherType,
                ciphertext = ciphertext,
                participants = participants
            )

            Flux.fromIterable(peers)
                .flatMap { peer ->
                    peer.ecies.decrypt(request).toMono()
                        .flatMap { it.successOrThrow() }
                        .map { it.unwrap(peer.peerId) }
                }
                .collectList()
                .map { partials ->
                    partials.forEach { client.context().decrypt().storePartialDecrypt(it) }
                    client.combiner().decrypt(CipherText.decode(ciphertext))
                }
                .doFinally {
                    client.destroy()
                }
        }
    }

    override fun partialDecrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray, participants: List<Int>): PartiallyDecrypted {
        val client = factory().createClient(keyId, null, cipherType, participants)

        try {
            return client.decryptor().partialDecrypt(CipherText.decode(ciphertext)).dto()
        } finally {
            client.destroy()
        }
    }

    abstract fun factory(): ThresholdECIESClientFactory<P>

    private fun PartiallyDecrypted.unwrap(peerId: Int): PartialDecrypt<P> {
        val yi = curve().params.decodePoint(yi) as P
        val proof = proof.unwrap()

        return PartialDecrypt(peerId, di, yi, proof)
    }

    private fun DleqProofDto.unwrap(): DleqProof<P> {
        val curveParams = curve().params

        val a1 = curveParams.decodePoint(this.a1) as WeierstrassPointOps<P>
        val a2 = curveParams.decodePoint(this.a2) as WeierstrassPointOps<P>

        return DleqProof(a1, a2, r)
    }
}