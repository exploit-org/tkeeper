package org.exploit.keeper.service.ecies.cipher

import org.exploit.ecies.model.CipherText
import org.exploit.ecies.model.PartialDecrypt
import org.exploit.keeper.constant.cipher.CipherType
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.isCipherText
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.performIndexed
import org.exploit.keeper.model.ecies.PartialDecryptRequest
import org.exploit.keeper.model.ecies.PartiallyDecrypted
import org.exploit.keeper.model.ecies.dleq.DleqProofDto
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.ecies.client.ThresholdECIESClientFactory
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.proof.model.DleqProof
import java.security.GeneralSecurityException

abstract class ThresholdECIESService<P : WeierstrassPointOps<P>>(
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val publicKeyService: PublicKeyService
): ThresholdCipherService {
    private val initData by lazy {
        db.readInitData()
    }

    abstract fun curve(): KeeperCurve<P>

    override fun curveName(): CurveName = curve().name

    override fun encrypt(keyId: String, cipherType: CipherType, plaintext: ByteArray): CipherText {
        val currentVersion = db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        val pub = publicKeyService.getPublicKey(keyId, currentVersion)
        val client = factory().createClient(keyId, pub.data, cipherType,
            listOf(initData.peerId), currentVersion)

        return client.encryptor().encrypt(plaintext)
    }

    override fun decrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray, generation: Int): ByteArray {
        if (!ciphertext.isCipherText())
            throw TKeeperException(ErrorType.INVALID_CIPHERTEXT)

        val peers = clients.findThreshold()

        val participants = peers.map { it.peerId } + initData.peerId
        val client = factory().createClient(keyId, null, cipherType, participants, generation)

        try {
            val request = PartialDecryptRequest(
                keyId = keyId,
                algorithm = cipherType,
                ciphertext = ciphertext,
                participants = participants,
                generation = generation
            )

            val results = peers.performIndexed { it.ecies.decrypt(request) }

            for ((peerId, partial) in results)
                client.context().decrypt().storePartialDecrypt(partial.unwrap(peerId))

            return client.combiner().decrypt(CipherText.decode(ciphertext))
        } catch (_: GeneralSecurityException) {
            throw TKeeperException(ErrorType.INVALID_CIPHERTEXT, "Failed to decrypt ciphertext")
        } finally {
            client.destroy()
        }
    }

    override fun partialDecrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray, participants: List<Int>, generation: Int): PartiallyDecrypted {
        val client = factory().createClient(keyId, null, cipherType, participants, generation)

        try {
            return client.decryptor().partialDecrypt(CipherText.decode(ciphertext)).dto()
        } finally {
            client.destroy()
        }
    }

    abstract fun factory(): ThresholdECIESClientFactory<P>

    private fun PartiallyDecrypted.unwrap(peerId: Int): PartialDecrypt<P> {
        val yi = curve().params.decodePoint(yi) as P
        val proof = proof.unwrap()

        return PartialDecrypt(peerId, di, yi, proof)
    }

    private fun DleqProofDto.unwrap(): DleqProof<P> {
        val curveParams = curve().params

        val a1 = curveParams.decodePoint(this.a1) as WeierstrassPointOps<P>
        val a2 = curveParams.decodePoint(this.a2) as WeierstrassPointOps<P>

        return DleqProof(a1, a2, r)
    }
}