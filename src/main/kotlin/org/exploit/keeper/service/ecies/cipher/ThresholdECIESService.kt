package org.exploit.keeper.service.ecies.cipher

import org.exploit.ecies.model.CipherText
import org.exploit.ecies.model.PartialDecrypt
import org.exploit.keeper.constant.cipher.CipherType
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.isCipherText
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.performSuccessOnly
import org.exploit.keeper.extension.toKeeperList
import org.exploit.keeper.model.Decrypted
import org.exploit.keeper.model.ecies.PartialDecryptRequest
import org.exploit.keeper.model.ecies.PartiallyDecrypted
import org.exploit.keeper.model.ecies.dleq.DleqProofDto
import org.exploit.keeper.model.event.ImposterFoundEvent
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.ecies.client.ThresholdECIESClientFactory
import org.exploit.keeper.service.pub.PublicKeyService
import org.exploit.keeper.service.pub.commits.KeeperCommitmentService
import org.exploit.signalix.manager.EventScope
import org.exploit.tss.curve.ec.WeierstrassPointOps
import org.exploit.tss.proof.dleq.DleqProofValidator
import org.exploit.tss.proof.model.DleqProof
import org.exploit.tss.proof.model.context.DleqContext
import java.security.GeneralSecurityException
import java.util.concurrent.ConcurrentHashMap

@Suppress("UNCHECKED_CAST")
abstract class ThresholdECIESService<P : WeierstrassPointOps<P>>(
    private val commitments: KeeperCommitmentService,
    private val db: RocksKeyDB,
    private val clients: TKeeperClients,
    private val publicKeyService: PublicKeyService,
    private val eventScope: EventScope
): ThresholdCipherService {
    private val initData by lazy {
        db.readInitData()
    }

    private val proofValidator: DleqProofValidator<P> = DleqProofValidator(
        curve().params.curveOrder,
        curve().params.g as P
    )

    abstract fun curve(): KeeperCurve<P>

    override fun curveName(): CurveName = curve().name

    override fun encrypt(keyId: String, cipherType: CipherType, plaintext: ByteArray): CipherText {
        val currentVersion = db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        val pub = publicKeyService.getPublicKey(keyId, currentVersion)
        val client = factory().createClient(keyId, pub.data, cipherType,
            listOf(initData.peerId), currentVersion)

        return client.encryptor().encrypt(plaintext)
    }

    override fun decrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray, generation: Int): Decrypted {
        if (!ciphertext.isCipherText())
            throw TKeeperException(ErrorType.INVALID_CIPHERTEXT)

        val peers = clients.findAllAvailable()

        val participants = peers.map { it.peerId } + initData.peerId
        val client = factory().createClient(keyId, null, cipherType, participants, generation)

        try {
            val request = PartialDecryptRequest(
                keyId = keyId,
                algorithm = cipherType,
                ciphertext = ciphertext,
                participants = participants,
                generation = generation
            )

            val results = peers.performSuccessOnly { it.ecies.decrypt(request) }
                .mapValues { (_, v) -> v.body }

            val imposters = ConcurrentHashMap.newKeySet<Int>()
            val cipherTextDecoded = CipherText.decode(ciphertext)

            var honestCount = 0
            for ((peerId, partial) in results) {
                val partialUnwrapped = partial.unwrap(peerId)

                // tss4j verifies dleq proofs in decrypt method, but we prevalidate it to not fail if fair nodes count is enough
                if (!verifyDleqProof(peerId, keyId, generation, partialUnwrapped, cipherTextDecoded)) {
                    imposters.add(peerId)
                    continue
                }

                honestCount++
                client.context().decrypt().storePartialDecrypt(partial.unwrap(peerId))
            }

            if (imposters.isNotEmpty())
                eventScope.call(ImposterFoundEvent(imposters))

            if (honestCount < initData.threshold - 1) {
                client.destroy()
                throw TKeeperException(ErrorType.NOT_ENOUGH_HONEST_CLIENTS, imposters = imposters)
            }

            val decrypted = client.combiner().decrypt(cipherTextDecoded)
            return Decrypted(decrypted.toBase64(), imposters.toKeeperList())
        } catch (_: GeneralSecurityException) {
            throw TKeeperException(ErrorType.INVALID_CIPHERTEXT, "Failed to decrypt ciphertext")
        } finally {
            client.destroy()
        }
    }

    override fun partialDecrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray, participants: List<Int>, generation: Int): PartiallyDecrypted {
        val client = factory().createClient(keyId, null, cipherType, participants, generation)

        try {
            return client.decryptor().partialDecrypt(CipherText.decode(ciphertext)).dto()
        } finally {
            client.destroy()
        }
    }

    abstract fun factory(): ThresholdECIESClientFactory<P>

    private fun verifyDleqProof(peerId: Int, keyId: String, generation: Int, decrypt: PartialDecrypt<P>, cipherText: CipherText): Boolean {
        val proof = decrypt.proof
        val di = curve().params.decodePoint(decrypt.di) as P
        val Yi = decrypt.Yi
        val derivedYi = commitments.deriveYi(keyId, generation, peerId)

        if (derivedYi != null && (!derivedYi.encode(true).contentEquals(Yi.encode(true))))
            return false

        val context = DleqContext(
            curve().params.decodePoint(cipherText.r) as P,
            decrypt.Yi,
            di
        )

        return try {
            proofValidator.verifyProof(proof, context)
        } catch (_: Exception) {
            false
        }
    }

    private fun PartiallyDecrypted.unwrap(peerId: Int): PartialDecrypt<P> {
        val yi = curve().params.decodePoint(yi) as P
        val proof = proof.unwrap()

        return PartialDecrypt(peerId, di, yi, proof)
    }

    private fun DleqProofDto.unwrap(): DleqProof<P> {
        val curveParams = curve().params

        val a1 = curveParams.decodePoint(this.a1) as WeierstrassPointOps<P>
        val a2 = curveParams.decodePoint(this.a2) as WeierstrassPointOps<P>

        return DleqProof(a1, a2, r)
    }
}