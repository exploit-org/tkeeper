package org.exploit.keeper.service.ecies

import jakarta.inject.Singleton
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.cipher.CipherType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.Decrypted
import org.exploit.keeper.model.Encrypted
import org.exploit.keeper.model.ecies.PartiallyDecrypted
import org.exploit.keeper.service.core.KeeperInitService
import org.exploit.keeper.service.ecies.cipher.ThresholdCipherService

@Singleton
class ThresholdECIESManager(
    private val keeperManager: KeeperInitService,
    private val db: RocksKeyDB,
    private val ciphers: List<ThresholdCipherService>
) {
    fun encrypt(keyId: String, cipherType: CipherType, plaintext: ByteArray): Encrypted {
        val curveName = extractKeyCurve(keyId)

        return ciphers.firstOrNull { it.curveName() == curveName }
            ?.encrypt(keyId, cipherType, plaintext)
            ?.let { Encrypted(it.encode().toBase64()) }
            ?: throw TKeeperException(ErrorType.UNSUPPORTED_CURVE, curveName.name)
    }

    fun decrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray): Decrypted {
        val curveName = extractKeyCurve(keyId)

        return ciphers.firstOrNull { it.curveName() == curveName }
            ?.decrypt(keyId, cipherType, ciphertext)
            ?.let { Decrypted(it.toBase64()) }
            ?: throw TKeeperException(ErrorType.UNSUPPORTED_CURVE, curveName.name)
    }

    fun partialDecrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray, participants: List<Int>): PartiallyDecrypted {
        val curveName = extractKeyCurve(keyId)

        return ciphers.firstOrNull { it.curveName() == curveName }
            ?.partialDecrypt(keyId, cipherType, ciphertext, participants)
            ?: throw TKeeperException(ErrorType.UNSUPPORTED_CURVE, curveName.name)
    }

    private fun extractKeyCurve(keyId: String): CurveName {
        keeperManager.ensureReady()

        return db.storage.get(keyId)?.toPrivateKey()
            ?.also { it.destroy() }
            ?.curve
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
    }
}