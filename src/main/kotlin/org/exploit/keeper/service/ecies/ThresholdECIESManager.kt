package org.exploit.keeper.service.ecies

import jakarta.inject.Singleton
import org.exploit.keeper.constant.cipher.CipherType
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.extension.extractCurveAndDestroy
import org.exploit.keeper.model.Decrypted
import org.exploit.keeper.model.Encrypted
import org.exploit.keeper.model.ecies.PartiallyDecrypted
import org.exploit.keeper.service.core.KeeperComplianceService
import org.exploit.keeper.service.core.KeeperService
import org.exploit.keeper.service.ecies.cipher.ThresholdCipherService

@Singleton
class ThresholdECIESManager(
    private val db: RocksKeyDB,
    private val keeper: KeeperService,
    private val compliance: KeeperComplianceService,
    private val ciphers: List<ThresholdCipherService>
) {
    fun encrypt(keyId: String, cipherType: CipherType, plaintext: ByteArray): Encrypted {
        keeper.ensureReady()

        if (!compliance.allowedForApplyOperations(keyId))
            throw TKeeperException(ErrorType.KEY_APPLY_OPS_FORBIDDEN, keyId)

        val currentVersion = db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        val curveName = extractKeyCurve(keyId, currentVersion)

        return ciphers.firstOrNull { it.curveName() == curveName }
            ?.encrypt(keyId, cipherType, plaintext)
            ?.let { Encrypted(it.encode().toBase64(), currentVersion) }
            ?: throw TKeeperException(ErrorType.UNSUPPORTED_CURVE, curveName.name)
    }

    fun decrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray, generation: Int? = null): Decrypted {
        keeper.ensureReady()

        val version = generation ?: db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        if (!compliance.allowedForProcessOperation(keyId, version))
            throw TKeeperException(ErrorType.KEY_PROCESS_OPS_FORBIDDEN, keyId)

        val curveName = extractKeyCurve(keyId, version)

        return ciphers.firstOrNull { it.curveName() == curveName }
            ?.decrypt(keyId, cipherType, ciphertext, version)
            ?.let { Decrypted(it.toBase64()) }
            ?: throw TKeeperException(ErrorType.UNSUPPORTED_CURVE, curveName.name)
    }

    fun partialDecrypt(keyId: String, cipherType: CipherType, ciphertext: ByteArray, participants: List<Int>, generation: Int): PartiallyDecrypted {
        val curveName = extractKeyCurve(keyId, generation)

        return ciphers.firstOrNull { it.curveName() == curveName }
            ?.partialDecrypt(keyId, cipherType, ciphertext, participants, generation)
            ?: throw TKeeperException(ErrorType.UNSUPPORTED_CURVE, curveName.name)
    }

    private fun extractKeyCurve(keyId: String, generation: Int): CurveName {
        return db.vault.readKey(keyId, generation)
            ?.extractCurveAndDestroy()
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
    }
}