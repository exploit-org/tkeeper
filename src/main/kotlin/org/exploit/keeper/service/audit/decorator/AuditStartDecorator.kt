package org.exploit.keeper.service.audit.decorator

import com.fasterxml.jackson.databind.ObjectMapper
import com.linecorp.armeria.common.HttpRequest
import com.linecorp.armeria.common.HttpResponse
import com.linecorp.armeria.server.DecoratingHttpServiceFunction
import com.linecorp.armeria.server.HttpService
import com.linecorp.armeria.server.ServiceRequestContext
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.controller.support.ControllerSupport
import org.exploit.keeper.extension.http.AUDIT_ATTRIBUTE_KEY
import org.exploit.keeper.extension.http.auditId
import org.exploit.keeper.model.audit.acc.AccumulatedAuditData
import org.exploit.keeper.model.audit.ctx.Http
import org.exploit.keeper.service.audit.AuditContextService
import org.exploit.keeper.service.audit.AuditService
import org.exploit.keeper.service.core.KeeperService
import org.exploit.keeper.util.path.AntPathMatcher
import java.util.*

class AuditStartDecorator(
    private val support: ControllerSupport,
    private val mapper: ObjectMapper,
    private val audit: AuditService,
    private val keeper: KeeperService,
    private val config: KeeperConfig,
    private val auditCtx: AuditContextService
) : DecoratingHttpServiceFunction {
    private val ignore = listOf(
        AntPathMatcher("/ui/**"),
        AntPathMatcher("/v1/keeper/control/**"),
        AntPathMatcher("/v1/keeper/ping"),
        AntPathMatcher("/v1/keeper/system/**"),
        AntPathMatcher("/v1/health/**"),
        AntPathMatcher("/v1/keeper/alerts")
    )

    override fun serve(delegate: HttpService, ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {
        if (!config.audit.enabled)
            return delegate.serve(ctx, req)

        if (ctx.config().route().patternString() == "/**")
            return delegate.serve(ctx, req)

        val path = ctx.path()

         if (ignore.any { it.matches(path) })
             return delegate.serve(ctx, req)

        keeper.ensureReady()

        if (!audit.allowRequest())
            return support.auditNotAvailable(mapper)

        var rid = ctx.auditId()

        if (rid == null) {
            rid = UUID.randomUUID().toString()
            ctx.setAttr(AUDIT_ATTRIBUTE_KEY, rid)

            val event = ctx.path().toEvent()

            val http = Http(
                method = req.method().name,
                path = ctx.path(),
                remoteAddress = ctx.remoteAddress().toString()
            )

            auditCtx.begin(
                AccumulatedAuditData(
                    id = rid,
                    event = event,
                    http = http
                )
            )
        }

        return delegate.serve(ctx, req)
    }

    private fun String.toEvent(): String {
        val trimmed = this.trim('/')
        if (trimmed.isEmpty())
            return "event"

        val parts = trimmed.split('/')
            .asSequence()
            .filter { it.isNotBlank() && it != "v1" }
            .toList()

        return if (parts.isEmpty()) "event" else "event." + parts.joinToString(".")
    }
}