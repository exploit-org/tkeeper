package org.exploit.keeper.service.audit.device.socket

import org.exploit.keeper.config.audit.AuditSocketConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.service.audit.device.AuditDevice
import java.io.Closeable
import java.io.FileInputStream
import java.net.InetSocketAddress
import java.net.Socket
import java.security.KeyStore
import java.util.concurrent.locks.ReentrantLock
import javax.net.ssl.*
import kotlin.concurrent.withLock

class SocketAuditDevice(private val cfg: AuditSocketConfig) : AuditDevice, Closeable {
    private val lock = ReentrantLock()

    @Volatile
    private var socket: Socket? = null

    override fun sendLog(ndjson: ByteArray) {
        lock.withLock {
            val s = socket ?: connectOrThrow()

            try {
                val out = s.getOutputStream()
                out.write(ndjson)
                out.flush()
            } catch (e: Exception) {
                safeClose()

                val s2 = connectOrThrow()

                try {
                    val out2 = s2.getOutputStream()
                    out2.write(ndjson)
                    out2.flush()
                } catch (e2: Exception) {
                    safeClose()
                    throw TKeeperException(ErrorType.AUDIT_FAILED, cause = e2)
                }
            }
        }
    }

    override fun isAvailable(): Boolean = lock.withLock {
        try {
            val s = socket?.takeIf { it.isConnected && !it.isClosed && !it.isOutputShutdown }
                ?: run {
                    try { connectOrThrow() } catch (_: Exception) { return@withLock false }
                }

            if (s is SSLSocket) {
                try {
                    val sess = s.session
                    if (sess == null || !sess.isValid) {
                        try { s.startHandshake() } catch (_: Exception) {
                            safeClose()
                            return@withLock false
                        }
                    }
                } catch (_: Exception) {
                    safeClose()
                    return@withLock false
                }
            }

            try {
                s.getOutputStream()
                true
            } catch (_: Exception) {
                safeClose()
                false
            }
        } catch (_: Exception) {
            false
        }
    }

    override fun close() {
        lock.withLock {
            safeClose()
        }
    }

    private fun connectOrThrow(): Socket {
        return try {
            val sock = cfg.tls?.let { connectTls(it) }
                ?: connectPlain()

            socket = sock
            sock
        } catch (e: Exception) {
            throw TKeeperException(ErrorType.AUDIT_FAILED)
        }
    }

    private fun connectPlain(): Socket {
        val s = Socket()
        applySocketOptions(s)
        s.connect(InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMillis)
        return s
    }

    private fun connectTls(tlsCfg: AuditSocketConfig.TlsConfig): SSLSocket {
        val ctx = buildSslContext(tlsCfg)
        val factory = ctx.socketFactory as SSLSocketFactory
        val s = factory.createSocket() as SSLSocket

        applySocketOptions(s)

        val params = s.sslParameters
        params.protocols = tlsCfg.protocols
            .map { it.trim() }
            .filter { it.isNotEmpty() }
            .toTypedArray()

        if (tlsCfg.verifyHostname) {
            params.endpointIdentificationAlgorithm = "HTTPS"
        }

        s.sslParameters = params

        s.connect(InetSocketAddress(cfg.host, cfg.port), cfg.connectTimeoutMillis)
        s.startHandshake()
        return s
    }

    private fun applySocketOptions(s: Socket) {
        s.tcpNoDelay = cfg.tcpNoDelay
        s.keepAlive = cfg.keepAlive

        val linger = cfg.soLingerSeconds
        if (linger > 0) {
            s.setSoLinger(true, linger)
        }

        s.soTimeout = cfg.readTimeoutMillis
    }

    private fun safeClose() {
        try {
            socket?.close()
        } catch (_: Exception) {
        } finally {
            socket = null
        }
    }

    private fun buildSslContext(tls: AuditSocketConfig.TlsConfig): SSLContext {
        val trustManagers: Array<TrustManager> = when {
            tls.spkiPins != null -> {
                val pins = tls.spkiPins
                    .map { it.trim() }
                    .filter { it.isNotEmpty() }
                    .toSet()
                arrayOf(SpkiPinningTrustManager(systemX509(), pins))
            }

            tls.trust != null -> {
                val t = tls.trust
                when (t.mode.lowercase()) {
                    "system" -> systemTrustManagers()
                    "truststore" -> {
                        val path = requireNotNull(t.path)
                        val pwd = requireNotNull(t.password).toCharArray()
                        trustStoreManagers(path, pwd, t.type)
                    }
                    else -> systemTrustManagers()
                }
            }

            else -> systemTrustManagers()
        }

        val keyManagers: Array<KeyManager>? = if (tls.client != null) {
            val c = tls.client

            if (c.keystorePath != null) {
                val path = c.keystorePath
                val pass = (c.keystorePassword ?: "").toCharArray()
                clientKeyManagers(path, pass, c.keystoreType)
            } else {
                null
            }
        } else null

        val ctx = SSLContext.getInstance("TLS")
        ctx.init(keyManagers, trustManagers, null)
        return ctx
    }

    private fun systemTrustManagers(): Array<TrustManager> {
        val tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
        tmf.init(null as KeyStore?)

        return tmf.trustManagers
    }

    private fun systemX509(): X509TrustManager =
        systemTrustManagers().filterIsInstance<X509TrustManager>().first()

    private fun trustStoreManagers(path: String, password: CharArray, type: String): Array<TrustManager> {
        val ks = KeyStore.getInstance(type)

        FileInputStream(path).use {
            ks.load(it, password)
        }

        val tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
        tmf.init(ks)

        return tmf.trustManagers
    }

    private fun clientKeyManagers(path: String, password: CharArray, type: String): Array<KeyManager> {
        val ks = KeyStore.getInstance(type)

        FileInputStream(path).use {
            ks.load(it, password)
        }

        val kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
        kmf.init(ks, password)

        return kmf.keyManagers
    }
}

