package org.exploit.keeper.service.audit

import jakarta.inject.Singleton
import org.exploit.keeper.constant.audit.BodyHashAlg
import org.exploit.keeper.constant.audit.Purpose
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.model.audit.AuditEvent
import org.exploit.keeper.model.audit.acc.AccumulatedAuditData
import org.exploit.keeper.model.audit.ctx.Dig
import org.exploit.keeper.model.audit.ctx.Digest
import org.exploit.keeper.service.audit.crypto.KeeperMacService
import java.time.Instant
import java.util.concurrent.ConcurrentHashMap

@Singleton
class AuditContextService(
    private val db: RocksKeyDB,
    private val hmac: KeeperMacService
) {
    private val initData by lazy {
        db.readInitData()
    }

    private val map = ConcurrentHashMap<String, AccumulatedAuditData>()

    fun begin(acc: AccumulatedAuditData) {
        map[acc.id] = acc
        pruneIfHuge()
    }

    fun get(id: String): AccumulatedAuditData? = map[id]

    fun updateIfPresent(id: String, action: (AccumulatedAuditData) -> Unit) {
        map[id]?.let {
            action(it)
        }
    }

    fun finish(id: String): AuditEvent? =
        map.remove(id)?.let { assemble(it) }

    private fun assemble(a: AccumulatedAuditData): AuditEvent {
        val now = Instant.now()

        return AuditEvent(
            id = a.id,
            peerId = initData.peerId,
            integrityKeyVersion = db.readIntegrityKeyVersion(),
            timestamp = now.toEpochMilli(),
            event = a.event!!,
            auth = a.auth,
            context = a.ctx,
            request = a.http,
            crypto = a.crypto,
            digest = dig(a),
            outcome = a.out
        )
    }

    private fun dig(a: AccumulatedAuditData): Dig? {
        if (a.reqBody == null)
            return null

        try {
            val purpose = Purpose.BODY_HASH
            val versionOpt = if (a.macVersion < 0) null else a.macVersion

            val macBytes = hmac.mac(purpose, a.reqBody!!, versionOpt)
            val mac64 = macBytes.toBase64()

            return Dig(
                purpose = purpose,
                hmacKeyVersion = hmac.effectiveVersion(versionOpt),
                bodyHash = Digest(BodyHashAlg.HMAC_SHA256, mac64)
            )
        } finally {
            a.reqBody!!.fill(0)
        }
    }

    private fun pruneIfHuge() {
        if (map.size > 10000) {
            val iterator = map.entries.iterator()
            repeat(2000) { if (iterator.hasNext()) iterator.next().let { e -> iterator.remove() } }
        }
    }
}