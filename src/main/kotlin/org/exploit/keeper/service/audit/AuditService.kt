package org.exploit.keeper.service.audit

import jakarta.inject.Singleton
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.wait
import org.exploit.keeper.model.audit.AuditEvent
import org.exploit.keeper.service.audit.device.AuditDevice
import org.exploit.keeper.service.audit.encoder.AuditEncoder
import org.exploit.keeper.util.executor.JavaExecutor
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.util.concurrent.CompletableFuture
import java.util.concurrent.TimeUnit
import java.util.concurrent.TimeoutException

@Singleton
class AuditService(
    private val config: KeeperConfig,
    private val encoder: AuditEncoder,
    private val devices: List<AuditDevice>
) {
    fun allowRequest(): Boolean {
        if (!config.audit.enabled)
            return false

        return devices.any { it.isAvailable() } && devices.isNotEmpty()
    }

    fun log(e: AuditEvent) {
        val encoded = encoder.toSignedNdjson(e)
        val results = ArrayList<CompletableFuture<AuditResult>>()

        if (devices.stream().count() == 0L) {
            throw TKeeperException(ErrorType.AUDIT_FAILED, "No devices configured")
        }

        for (device in devices)
            results.add(auditFuture(device, encoded))

        val executed = results.wait()
        val pass = executed.any { it.success }
        val failedDevices = executed.filter { !it.success }

        val details = failedDevices.joinToString(", ") {
            if (it.timeout)
                "${it.device.javaClass.simpleName} (timeout)"
            else
                it.device.javaClass.simpleName
        }

        if (!pass)
            throw TKeeperException(ErrorType.AUDIT_FAILED, details)

        if (failedDevices.isNotEmpty()) {
            val message = "Some audit devices failed: $details"
            LOGGER.warn(message)
        }
    }

    private fun auditFuture(device: AuditDevice, log: ByteArray): CompletableFuture<AuditResult> {
        val future = CompletableFuture.supplyAsync({
            try {
                device.sendLog(log)
                AuditResult(true, device)
            } catch (ex: Exception) {
                LOGGER.error("Failed to send audit log to device: ${device.javaClass.simpleName}", ex)
                AuditResult(false, device)
            }
        }, JavaExecutor.virtual()).orTimeout(500L, TimeUnit.MILLISECONDS)

        return future.exceptionally {
            if (it is TimeoutException || it.cause is TimeoutException)
                AuditResult(false, device, timeout = true)
            else
                AuditResult(false, device)
        }
    }

    private data class AuditResult(val success: Boolean, val device: AuditDevice, val timeout: Boolean = false)

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(AuditService::class.java)
    }
}