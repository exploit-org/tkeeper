package org.exploit.keeper.service.audit.encoder

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature
import jakarta.inject.Singleton
import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.model.audit.AuditEvent
import org.exploit.keeper.model.audit.SignedLine
import java.util.*

@Singleton
class JacksonAuditEncoder(private val db: RocksKeyDB): AuditEncoder {
    override fun toSignedNdjson(ev: AuditEvent): ByteArray {
        val payload = encodeForSigning(ev)
        val integrityKeyPair = db.readIntegrityKeyPair()

        try {
            val sig = Ed25519Provider.getInstance().sign(payload, integrityKeyPair)
                .encode()

            val wire = SignedLine(
                event = ev,
                signature = Base64.getEncoder().encodeToString(sig)
            )

            return AUDIT_MAPPER.writeValueAsBytes(wire) + "\n".toByteArray()
        } finally {
            integrityKeyPair.erase()
        }
    }

    override fun encodeForSigning(ev: AuditEvent): ByteArray {
        return AUDIT_MAPPER.writeValueAsBytes(ev)
    }

    private companion object {
        val AUDIT_MAPPER: ObjectMapper = ObjectMapper()
            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
            .enable(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)
    }
}