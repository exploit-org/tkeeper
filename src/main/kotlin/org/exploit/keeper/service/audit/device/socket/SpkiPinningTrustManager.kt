package org.exploit.keeper.service.audit.device.socket

import java.security.MessageDigest
import java.security.cert.X509Certificate
import java.util.*
import javax.net.ssl.SSLPeerUnverifiedException
import javax.net.ssl.X509TrustManager

class SpkiPinningTrustManager(
    private val delegate: X509TrustManager,
    private val pins: Set<String>
) : X509TrustManager {
    override fun getAcceptedIssuers(): Array<X509Certificate> = delegate.acceptedIssuers

    override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {
        delegate.checkClientTrusted(chain, authType)
        if (!matches(chain)) {
            throw SSLPeerUnverifiedException("Client certificate pin mismatch")
        }
    }

    override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {
        delegate.checkServerTrusted(chain, authType)
        if (!matches(chain)) {
            throw SSLPeerUnverifiedException("Server certificate pin mismatch")
        }
    }

    private fun matches(chain: Array<X509Certificate>): Boolean {
        for (cert in chain) {
            val spki = cert.publicKey.encoded
            val sha256 = MessageDigest.getInstance("SHA-256").digest(spki)
            val b64 = Base64.getEncoder().encodeToString(sha256)

            if (b64 in pins)
                return true
        }
        return false
    }
}