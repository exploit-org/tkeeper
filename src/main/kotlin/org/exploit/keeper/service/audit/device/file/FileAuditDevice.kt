package org.exploit.keeper.service.audit.device.file

import org.exploit.keeper.config.audit.AuditFileConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.service.audit.device.AuditDevice
import org.exploit.keeper.service.audit.device.file.compress.Compressor
import org.exploit.keeper.service.audit.device.file.compress.GZIPCompressor
import org.exploit.keeper.service.audit.device.file.compress.NoopCompressor
import java.io.Closeable
import java.nio.file.AtomicMoveNotSupportedException
import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.time.Instant
import java.util.concurrent.locks.ReentrantLock
import kotlin.concurrent.withLock

class FileAuditDevice(private val cfg: AuditFileConfig) : AuditDevice, Closeable {
    private val lock = ReentrantLock()
    private val namer = FileNamer(cfg.directory, cfg.prefix, cfg.extension)
    private val rotator = RotationPolicy(cfg.maxFileSizeBytes, cfg.rollEvery)
    private val retention = RetentionManager(cfg.directory, namer, cfg.maxFiles, cfg.retentionDays)
    private val compressor: Compressor = if (cfg.gzip) GZIPCompressor else NoopCompressor

    private var sink: FileSink? = null
    private var createdAt: Instant = Instant.EPOCH
    private var bytesWritten: Long = 0

    init {
        ensureDir()
        openOrCreateCurrent()
    }

    override fun sendLog(ndjson: ByteArray) {
        lock.withLock {
            val now = Instant.now()

            if (rotator.shouldRoll(bytesWritten, createdAt, now)) {
                roll(now)
            }

            val data = ensureNdjsonLine(ndjson)
            try {
                sink!!.write(data, fsync = cfg.fsync)
                bytesWritten += data.size
            } catch (e: Exception) {
                throw TKeeperException(ErrorType.AUDIT_FAILED, "Failed to write audit log to ${namer.current()}", e)
            }
        }
    }

    override fun isAvailable(): Boolean = lock.withLock {
        try {
            if (sink == null)
                return@withLock false

            if (!Files.isDirectory(cfg.directory) || !Files.isWritable(cfg.directory))
                return@withLock false

            val current = namer.current()
            if (!Files.exists(current) || !Files.isWritable(current))
                return@withLock false

            val usable = runCatching { Files.getFileStore(current).usableSpace }.getOrElse { 0L }
            usable > 4096L
        } catch (_: Exception) {
            false
        }
    }

    override fun close() {
        lock.withLock {
            try { sink?.close() } catch (_: Exception) {}
            sink = null
        }
    }

    private fun openOrCreateCurrent() {
        val current = namer.current()
        try {
            if (!Files.exists(current)) {
                Files.createDirectories(cfg.directory)
                Files.createFile(current)
            }
            sink = FileSink(current)
            createdAt = Files.getLastModifiedTime(current).toInstant()
            bytesWritten = try { Files.size(current) } catch (_: Exception) { 0L }
        } catch (e: Exception) {
            throw TKeeperException(ErrorType.AUDIT_FAILED, "Failed to open current audit file: $current", e)
        }
    }

    private fun roll(now: Instant) {
        try { sink?.close() } catch (_: Exception) {}

        val current = namer.current()
        val rolled = namer.rolled(now)

        try {
            try {
                Files.move(current, rolled, StandardCopyOption.ATOMIC_MOVE)
            } catch (_: AtomicMoveNotSupportedException) {
                Files.move(current, rolled, StandardCopyOption.REPLACE_EXISTING)
            }
        } catch (e: Exception) {
            throw TKeeperException(ErrorType.AUDIT_FAILED, "Failed to rotate audit file $current -> $rolled", e)
        }

        try {
            compressor.compress(rolled)
        } catch (_: Exception) {}

        try {
            retention.apply(now)
        } catch (_: Exception) {}

        openOrCreateCurrent()
        createdAt = now
        bytesWritten = 0
    }

    private fun ensureNdjsonLine(src: ByteArray): ByteArray {
        if (src.isEmpty() || src.last() == '\n'.code.toByte())
            return src

        val out = ByteArray(src.size + 1)
        System.arraycopy(src, 0, out, 0, src.size)
        out[out.lastIndex] = '\n'.code.toByte()

        return out
    }

    private fun ensureDir() {
        try {
            Files.createDirectories(cfg.directory)
            require(Files.isWritable(cfg.directory)) { "Directory not writable: ${cfg.directory}" }
        } catch (e: Exception) {
            throw TKeeperException(ErrorType.AUDIT_FAILED, "Failed to prepare audit directory: ${cfg.directory}", e)
        }
    }
}