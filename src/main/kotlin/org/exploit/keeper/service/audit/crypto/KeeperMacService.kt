package org.exploit.keeper.service.audit.crypto

import jakarta.inject.Singleton
import org.bouncycastle.crypto.digests.SHA256Digest
import org.bouncycastle.crypto.macs.HMac
import org.bouncycastle.crypto.params.KeyParameter
import org.exploit.keeper.db.RocksKeyDB
import java.nio.ByteBuffer
import java.nio.charset.StandardCharsets
import java.security.MessageDigest

@Singleton
class KeeperMacService(private val db: RocksKeyDB) {
    fun mac(purpose: String, data: ByteArray, version: Int? = null): ByteArray {
        val ver = effectiveVersion(version)
        val master = db.readHmacKey(ver)

        return mac(master, purpose, data, ver)
    }

    fun mac(master: ByteArray, purpose: String, data: ByteArray, version: Int): ByteArray {
        val info = buildInfo(purpose, version)
        val prk = hkdfExtractZeroSalt(master)
        val dkey = hkdfExpand(prk, info, 32)

        val framed = frame(info, data)
        val mac = hmacSha256(dkey, framed)

        wipe(framed, dkey, prk, info, master)
        return mac
    }

    fun verify(mac: ByteArray, data: ByteArray, purpose: String, requestedVersion: Int? = null): Boolean {
        return MessageDigest.isEqual(mac, mac(purpose, data, requestedVersion))
    }

    fun verify(mac: ByteArray, master: ByteArray, data: ByteArray, purpose: String, requestedVersion: Int): Boolean {
        return MessageDigest.isEqual(mac, mac(master, purpose, data, requestedVersion))
    }

    fun effectiveVersion(requested: Int?): Int =
        requested ?: db.readHmacKeyVersion()

    private fun buildInfo(purpose: String, version: Int): ByteArray {
        val s = "purpose=$purpose\nversion=$version\n"
        return s.toByteArray(StandardCharsets.UTF_8)
    }

    private fun frame(info: ByteArray, body: ByteArray): ByteArray {
        val bb = ByteBuffer.allocate(2 + info.size + 4 + body.size)

        bb.putShort(info.size.toShort())
        bb.put(info)
        bb.putInt(body.size)
        bb.put(body)

        return bb.array()
    }

    private fun hkdfExtractZeroSalt(ikm: ByteArray): ByteArray {
        val h = HMac(SHA256Digest())
        h.init(KeyParameter(ZERO_SALT))
        h.update(ikm, 0, ikm.size)
        val out = ByteArray(h.macSize)
        h.doFinal(out, 0)
        return out
    }

    private fun hkdfExpand(prk: ByteArray, info: ByteArray, outLen: Int): ByteArray {
        val h = HMac(SHA256Digest())
        val hashLen = h.macSize
        val n = (outLen + hashLen - 1) / hashLen
        require(n <= 255) { "HKDF expand too large" }

        val okm = ByteArray(outLen)
        var t = ByteArray(0)
        var pos = 0
        for (i in 1..n) {
            h.reset()
            h.init(KeyParameter(prk))
            if (t.isNotEmpty()) h.update(t, 0, t.size)
            if (info.isNotEmpty()) h.update(info, 0, info.size)
            h.update(byteArrayOf(i.toByte()), 0, 1)

            val block = ByteArray(hashLen)
            h.doFinal(block, 0)

            val toCopy = minOf(block.size, outLen - pos)
            System.arraycopy(block, 0, okm, pos, toCopy)
            pos += toCopy

            t.fill(0)
            t = block
        }
        t.fill(0)
        return okm
    }

    private fun hmacSha256(key: ByteArray, data: ByteArray): ByteArray {
        val h = HMac(SHA256Digest())

        h.init(KeyParameter(key))
        h.update(data, 0, data.size)

        val out = ByteArray(h.macSize)
        h.doFinal(out, 0)

        return out
    }

    private fun wipe(vararg xs: ByteArray?) {
        xs.forEach { arr -> arr?.fill(0) }
    }

    private companion object {
        val ZERO_SALT = ByteArray(32)
    }
}