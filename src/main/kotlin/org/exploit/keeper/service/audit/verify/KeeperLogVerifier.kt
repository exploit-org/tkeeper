package org.exploit.keeper.service.audit.verify

import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodeBase64OrNull
import org.exploit.keeper.model.VerifyResult
import org.exploit.keeper.model.audit.SignedLine
import org.exploit.keeper.service.audit.encoder.JacksonAuditEncoder
import org.exploit.keeper.service.integrity.KeeperSignatureService

@Singleton
class KeeperLogVerifier(
    private val encoder: JacksonAuditEncoder,
    private val signer: KeeperSignatureService
) {
    fun verifyLine(line: SignedLine): VerifyResult {
        val event = line.event
        val encodedEvent = encoder.encodeForSigning(event)

        val signature = line.signature.decodeBase64OrNull()
            ?: throw TKeeperException(ErrorType.INVALID_SCHNORR_SIGNATURE)

        val keyVersion = event.integrityKeyVersion

        return VerifyResult(
            valid = signer.verify(encodedEvent, signature, keyVersion),
        )
    }

    fun verifyLines(lines: List<SignedLine>): Map<String, VerifyResult> {
        return lines.associate { it.event.id to verifyLine(it) }
    }
}