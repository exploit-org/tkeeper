package org.exploit.keeper.service.seal.provider

import org.exploit.keeper.exception.SealedException
import org.exploit.keeper.model.seal.init.InitData
import org.exploit.keeper.model.seal.init.ShamirInitData
import org.exploit.keeper.model.seal.progress.Progress
import org.exploit.keeper.model.seal.progress.ShamirUnsealProgress
import org.exploit.keeper.service.key.AesKeyOps
import org.exploit.keeper.service.key.KeyOps
import org.exploit.keeper.util.crypto.Shamir
import java.util.concurrent.atomic.AtomicReference
import javax.crypto.spec.SecretKeySpec

class ShamirKeysProvider(
    private val total: Int = 5,
    private val threshold: Int = 3
) : SealProvider {
    override val id: String = ID

    override val isAuto: Boolean = false

    private val parts = mutableListOf<Shamir.Share>()
    private var ops: AtomicReference<AesKeyOps> = AtomicReference<AesKeyOps>()

    override fun keyOpsOrNull(): AesKeyOps? = ops.get()

    override fun initialize(): InitData {
        val secretKey = Shamir.generateSecretKey()
        val split = Shamir.split(secretKey, total, threshold)

        try {
            ops.set(AesKeyOps(SecretKeySpec(secretKey, "AES")))

            return ShamirInitData(
                threshold = threshold,
                total = total,
                shares64 = Shamir.encodeShares(split)
            )
        } finally {
            secretKey.fill(0)
        }
    }

    override fun keyOpsOrThrow(): KeyOps {
        return keyOpsOrNull() ?: throw SealedException()
    }

    override fun initialProgress(): Progress = ShamirUnsealProgress(threshold = threshold, total = total)

    override fun submitPart(payload64: String): ShamirUnsealProgress {
        parts.add(Shamir.Share.fromBase64(payload64))
        return unseal()
    }

    override fun seal() {
        parts.clear()
        ops.set(null)
    }

    override fun unseal(): ShamirUnsealProgress {
        return if (parts.size < threshold) {
            ShamirUnsealProgress(progress = parts.size, total = total, threshold = threshold)
        } else {
            try {
                val dekBytes = Shamir.combine(parts)
                val secretKey = SecretKeySpec(dekBytes, "AES")
                ops.set(AesKeyOps(secretKey))

                ShamirUnsealProgress(threshold = threshold, progress = threshold, total = total, ready = true)
            } finally {
                parts.clear()
            }
        }
    }

    companion object {
        const val ID = "shamir"
    }
}