package org.exploit.keeper.service.seal

import jakarta.inject.Singleton
import org.exploit.keeper.constant.StoreState
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.AlreadyUnsealedException
import org.exploit.keeper.exception.AutoProviderException
import org.exploit.keeper.exception.NotInitializedException
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.model.request.KeeperInitData
import org.exploit.keeper.model.seal.StatusResponse
import org.exploit.keeper.model.seal.init.SealInitData
import org.exploit.keeper.model.seal.progress.Progress
import org.exploit.keeper.service.key.KeyOps
import org.exploit.keeper.service.seal.provider.SealProvider
import java.util.concurrent.atomic.AtomicReference

@Singleton
class SealManager(private val provider: SealProvider, private val db: RocksKeyDB) {
    private var ops: AtomicReference<KeyOps> = AtomicReference()

    @Volatile
    private var state: AtomicReference<StoreState> =
        if (db.isInitialized())
            AtomicReference(StoreState.SEALED)
        else
            AtomicReference(StoreState.UNINITIALIZED)

    private var progress: AtomicReference<Progress> = AtomicReference(provider.initialProgress())

    fun initialize(initData: KeeperInitData): SealInitData {
        if (db.isInitialized())
            throw TKeeperException(400, "Already initialized")

        return provider.initialize().also {
            state.set(StoreState.UNSEALED)
            ops.set(provider.keyOpsOrThrow())

            db.writeSentinel(provider.keyOpsOrThrow())
            db.writeIntegrityKey(provider.keyOpsOrThrow())

            db.writeInitData(
                peerId = initData.peerId,
                threshold = initData.threshold,
                total = initData.total
            )
        }
    }

    fun submit(payload64: String): Progress {
        if (!db.isInitialized())
            throw NotInitializedException()

        if (state.get() != StoreState.SEALED)
            throw AlreadyUnsealedException()

        if (provider.isAuto)
            throw AutoProviderException()

        val providerProgress = provider.submitPart(payload64)
        progress.set(providerProgress)

        if (!providerProgress.ready)
            return providerProgress

        try {
            if (!db.checkValidKey(provider.keyOpsOrThrow())) {
                seal()
                return provider.initialProgress()
            }
        } catch (e: Exception) {
            seal()
            return provider.initialProgress()
        }

        state.set(StoreState.UNSEALED)
        ops.set(provider.keyOpsOrThrow())
        return providerProgress
    }

    fun seal() {
        provider.seal()
        ops.set(null)
        progress.set(provider.initialProgress())
        state.set(StoreState.SEALED)
    }

    fun status(): StatusResponse =
        StatusResponse(
            sealedBy = provider.id,
            state = state.get() ?: StoreState.UNINITIALIZED,
            progress = progress.get() ?: provider.initialProgress()
        )
}