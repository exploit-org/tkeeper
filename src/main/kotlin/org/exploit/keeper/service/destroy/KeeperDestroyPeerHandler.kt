package org.exploit.keeper.service.destroy

import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.destroy.DestroySessionState
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.model.destroy.KeyDestroyIntent
import org.exploit.keeper.model.destroy.KeyDestroySession
import java.time.Instant

@Singleton
class KeeperDestroyPeerHandler(private val db: RocksKeyDB) {
    fun prepare(intent: KeyDestroyIntent) {
        val now = Instant.now().epochSecond

        if (now >= intent.expiresAt)
            throw TKeeperException(ErrorType.INVALID_EXPIRATION_TIME, intent.sessionId)

        val sessionId = intent.sessionId

        val activeGen = db.vault.readLatestVersion(intent.logicalId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, intent.logicalId)

        if (activeGen - intent.generation < 2 || intent.generation > activeGen)
            throw TKeeperException(ErrorType.DESTROY_FORBIDDEN, "Destroy generation not eligible")

        if (db.vault.findLatestPendingGeneration(intent.logicalId) != null)
            throw TKeeperException(ErrorType.DESTROY_FORBIDDEN, "Pending generation exists")

        db.destroy.ops.runInTransaction {
            val existingSid = db.destroy.findActiveSessionId(it, intent.logicalId, intent.generation)

            if (existingSid != null) {
                db.destroy.expireIfNeeded(it, existingSid)
                val still = db.destroy.loadSession(it, existingSid)
                if (still != null && still.state.isRunning()) {
                    return@runInTransaction
                }
            }

            val s = db.destroy.createIfAbsentRunning(sessionId, intent)
            if (!s.state.isRunning() && s.state != DestroySessionState.COMMITTED)
                throw TKeeperException(ErrorType.DESTROY_FORBIDDEN, "Session not runnable")
        }
    }

    fun commit(sessionId: String) {
        db.destroy.ops.runInTransaction {
            val s0 = db.destroy.expireIfNeeded(it, sessionId)
                ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND, sessionId)

            if (s0.state == DestroySessionState.COMMITTED) return@runInTransaction
            if (!s0.state.isRunning()) throw TKeeperException(ErrorType.DESTROY_FORBIDDEN, "Session not running")

            val logicalId = s0.intent.logicalId
            val gen = s0.intent.generation

            if (db.vault.findLatestPendingGeneration(it, logicalId) != null)
                throw TKeeperException(ErrorType.DESTROY_FORBIDDEN, "Pending generation exists")

            if (db.vault.hasKey(it, logicalId, gen)) {
                db.vault.deleteKey(it, logicalId, gen)
            }

            db.meta.upsertNotNullKeysetMeta(it, logicalId, gen) { m ->
                m.copy(destroyed = true)
            }

            val now = Instant.now().epochSecond
            db.destroy.updateSession(it, sessionId) { s -> s.copy(state = DestroySessionState.COMMITTED, updatedAt = now) }
        }
    }

    fun abort(sessionId: String) {
        db.destroy.ops.runInTransaction {
            val s = db.destroy.loadSession(it, sessionId) ?: return@runInTransaction
            if (s.state.isFinal()) return@runInTransaction

            val now = Instant.now().epochSecond
            db.destroy.updateSession(it, sessionId) { s -> s.copy(state = DestroySessionState.ABORTED, updatedAt = now) }
        }
    }

    fun status(sessionId: String): KeyDestroySession? {
        return db.destroy.ops.runInTransaction {
            db.destroy.expireIfNeeded(it, sessionId)
            db.destroy.loadSession(it, sessionId)
        }
    }
}