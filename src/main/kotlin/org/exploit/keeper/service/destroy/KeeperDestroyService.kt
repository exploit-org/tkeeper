package org.exploit.keeper.service.destroy

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.dkg.ConsistencyVerdict
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.perform
import org.exploit.keeper.extension.performSuccessOnly
import org.exploit.keeper.model.destroy.KeyDestroyIntent
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperConsistencyService
import java.time.Instant
import java.util.*

@Singleton
class KeeperDestroyService(
    private val db: RocksKeyDB,
    private val config: KeeperConfig,
    private val clients: TKeeperClients,
    private val consistency: KeeperConsistencyService,
    private val handler: KeeperDestroyPeerHandler
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun destroy(keyId: String, generation: Int) {
        if (generation <= 0)
            throw TKeeperException(ErrorType.DESTROY_FORBIDDEN, "Bad generation")

        val peers = clients.findAllHealthy()
        val check = consistency.tryAutoFix(keyId, peers)

        if (check.verdict != ConsistencyVerdict.OK)
            throw TKeeperException(ErrorType.INCONSISTENT_KEEPER, keyId)

        val sid = UUID.randomUUID().toString()
        val expiresAt = Instant.now().plusSeconds(config.session.destroy.expire.seconds)
            .epochSecond

        val intent = KeyDestroyIntent(
            sessionId = sid,
            logicalId = keyId,
            generation = generation,
            expiresAt = expiresAt
        )

        prepare(intent, peers)
        commit(sid, peers)
    }

    private fun prepare(intent: KeyDestroyIntent, peers: List<TKeeperClient>) {
        handler.prepare(intent)

        try {
            peers.perform { it.destroy.prepare(intent) }
        } catch (e: Exception) {
            abort(intent.sessionId, peers)
        }
    }

    private fun commit(sid: String, peers: List<TKeeperClient>) {
        handler.commit(sid)
        val okPeers = peers.performSuccessOnly {
            it.destroy.commit(sid)
        }

        val successCount = okPeers.size + 1

        if (successCount == initData.total)
            return

        if (successCount >= initData.threshold)
            throw TKeeperException(ErrorType.WARNING, WARNING_MESSAGE)

        abort(sid, peers)
        throw TKeeperException(ErrorType.INTERNAL_ERROR, "Less than threshold peers could commit: $successCount.")
    }

    private fun abort(sid: String, peers: List<TKeeperClient>) {
        handler.abort(sid)

        try {
            peers.perform { it.destroy.abort(sid) }
        } catch (_: Exception) {}
    }

    private companion object {
        const val WARNING_MESSAGE = "Key is not recoverable, but not vanished on all peers. Check health of peers and run operation again."
    }
}