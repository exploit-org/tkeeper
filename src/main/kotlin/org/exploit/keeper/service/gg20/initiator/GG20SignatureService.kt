package org.exploit.keeper.service.gg20.initiator

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.extension.toUni
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.service.SignatureService
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.keeper.util.ErrorHandlers
import org.exploit.signalix.manager.EventScope
import org.exploit.threshield.curve.PointOps
import reactor.core.publisher.Mono.defer
import reactor.core.publisher.Mono.just

@Singleton
class GG20SignatureService(
    private val clients: BitKeeperClients,
    private val peerInitializer: GG20PeerInitializer,
    private val commitmentBroadcaster: GG20CommitmentBroadcaster,
    private val mtaInitiator: GG20MtAInitiator,
    private val offlinePhaseCollector: GG20OfflinePhaseCollector,
    private val finalizer: GG20SignatureFinalizer,
    private val eventScope: EventScope
): SignatureService {
    override fun <P : PointOps<P>> sign(sessionId: String, keyId: String, message: ByteArray, curve: KeeperCurve<P>): Uni<TSSResult> {
        return clients.findAvailable()
            .flatMap { peerInitializer.init(it, sessionId, keyId, message, curve) }
            .flatMap { commitmentBroadcaster.broadcast(it, sessionId) }
            .flatMap { mtaInitiator.startMtA(it, sessionId) }
            .flatMap { offlinePhaseCollector.collect(it, sessionId) }
            .flatMap { defer { finalizer.completeSignature(it, sessionId).map { TSSResult.success(it) } } }
            .doOnNext { eventScope.call(SessionCleanEvent(sessionId, SessionType.GG20)) }
            .doOnError { ErrorHandlers.handleAbort(sessionId, SessionType.GG20, eventScope, it) }
            .onErrorResume { just(TSSResult.failed()) }
            .toUni()
    }
}