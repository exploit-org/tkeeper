package org.exploit.keeper.service.gg20

import jakarta.annotation.PreDestroy
import jakarta.inject.Singleton
import jakarta.ws.rs.BadRequestException
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.datatype.InMemoryTemporaryMap
import org.exploit.keeper.db.LMKDB
import org.exploit.keeper.extension.toBigInt
import org.exploit.keeper.service.ThresholdSessionFactory
import org.exploit.threshield.curve.PointOps
import org.exploit.threshield.curve.jce.ECCurveParams
import org.exploit.threshield.curve.jce.ECPointOps
import org.exploit.threshield.ecdsa.GG20Client
import org.exploit.threshield.ecdsa.constant.GG20
import org.exploit.threshield.ecdsa.context.GG20Context
import org.exploit.threshield.ecdsa.context.aggregator.InMemoryAggregatorContext
import org.exploit.threshield.ecdsa.context.crypto.CryptoContext
import org.exploit.threshield.ecdsa.context.init.InitContext
import org.exploit.threshield.ecdsa.context.integrity.InMemoryIntegrityContext
import org.exploit.threshield.ecdsa.context.mta.MtAContext
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.util.concurrent.TimeUnit

@Singleton
class GG20SessionFactory(
    private val keyDb: LMKDB,
    private val config: KeeperConfig
): ThresholdSessionFactory<GG20Client> {
    private val sessionMap = InMemoryTemporaryMap<String, GG20Client>(
        config.session().gg20().expire().seconds, TimeUnit.SECONDS
    )

    override fun <P: PointOps<P>> createSession(
        sessionId: String, keyId: String,
        message: ByteArray, participants: List<Int>,
        curve: KeeperCurve<P>
    ): GG20Client {
        if (!participants.contains(config.idx()))
            throw BadRequestException("Service is not participant")

        if (curve.params !is ECCurveParams)
            throw BadRequestException("Curve is not supported")

        val curveParams = curve.params
        val keyShare = keyDb.private.get(keyId)?.toBigInt() ?: throw BadRequestException("Key not found")

        val relatedFullPublicKey = keyDb.public.get(keyId)?.toPointOps(curveParams)
            ?: throw IllegalStateException("Public Key not found for $keyId")

        val initContext = InitContext.inMemoryBuilder()
            .message(message)
            .additionalContext(ByteArray(0))
            .build()

        val cryptoContext = CryptoContext.inMemoryBuilder()
            .idx(config.idx())
            .ski(keyShare)
            .publicKey(relatedFullPublicKey)
            .curve(curveParams)
            .participants(participants)
            .build()

        val context = GG20Context.newBuilder()
            .init(initContext)
            .mta(MtAContext.inMemory())
            .aggregator(InMemoryAggregatorContext())
            .integrity(InMemoryIntegrityContext())
            .crypto(cryptoContext)
            .build()

        return GG20Client(sessionId, context, GG20.CommitmentGenerator.SECP256k1)
            .apply { init() }
            .also {
                sessionMap.put(sessionId, it)
            }
    }

    override fun <P : PointOps<P>> session(sessionId: String): GG20Client =
        sessionMap.get(sessionId) ?: throw BadRequestException("Session not found")

    override fun clear(sessionId: String) {
        sessionMap.remove(sessionId)
    }

    override fun type(): SessionType {
        return SessionType.GG20
    }

    @PreDestroy
    private fun destroy() {
        sessionMap.close()
    }

    private fun ByteArray.toPointOps(curveParams: ECCurveParams): ECPointOps {
        return ECPointOps(curveParams.x9ECParameters.curve.decodePoint(this))
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(GG20SessionFactory::class.java)
    }
}