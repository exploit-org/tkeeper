package org.exploit.keeper.service.gg20

import jakarta.inject.Singleton
import org.exploit.keeper.extension.dto
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.gg20.commitment.GG20GammaCommitmentDto
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.threshield.curve.jce.ECCurveParams
import org.exploit.threshield.ecdsa.commitment.GammaCommitment
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class GG20CommitmentHandler(private val sessionFactory: GG20SessionFactory, private val clients: BitKeeperClients) {
    fun broadcastGammaCommitment(sessionId: String): Mono<Void> {
        val session = sessionFactory.session(sessionId)
        val commitment = session.context().crypto().ephemeral().commitment
        val r = session.context().crypto().ephemeral().r_i
        val dto = GG20GammaCommitmentDto(r, commitment.dto())

        val peers = clients.forBroadcast(session.context().crypto().participants())

        return Flux.fromIterable(peers)
            .flatMap { it.gg20.storeCommitment(sessionId, dto).toMono() }
            .then()
    }

    fun storeCommitment(sessionId: String, idx: Int, commitment: GG20GammaCommitmentDto) {
        val session = sessionFactory.session(sessionId)

        val point = commitment.point.let {
            (session.context().crypto().curve() as ECCurveParams)
                .x9ECParameters
                .curve
                .createPoint(it.x, it.y)
        }

        session.context().integrity().storeGammaCommitment(idx, GammaCommitment(point, commitment.r))
    }
}