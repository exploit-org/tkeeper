package org.exploit.keeper.service.exception

import com.fasterxml.jackson.databind.ObjectMapper
import com.linecorp.armeria.common.HttpRequest
import com.linecorp.armeria.common.HttpResponse
import com.linecorp.armeria.server.DecoratingHttpServiceFunction
import com.linecorp.armeria.server.HttpService
import com.linecorp.armeria.server.ServerErrorHandler
import com.linecorp.armeria.server.ServiceRequestContext
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.controller.support.ControllerSupport
import org.exploit.keeper.exception.TKeeperException
import org.exploit.tss.exception.IdentifiableAbortException
import org.slf4j.Logger
import org.slf4j.LoggerFactory

class KeeperExceptionHandler(
    private val support: ControllerSupport,
    private val objectMapper: ObjectMapper
) : DecoratingHttpServiceFunction, ServerErrorHandler {

    override fun serve(delegate: HttpService, ctx: ServiceRequestContext, req: HttpRequest): HttpResponse {
        val res = delegate.serve(ctx, req)

        return res.recover(Throwable::class.java) { t ->
            handle(ctx, t)
        }
    }

    override fun onServiceException(ctx: ServiceRequestContext, cause: Throwable): HttpResponse? {
        return handle(ctx, cause)
    }

    private fun handle(ctx: ServiceRequestContext, t: Throwable): HttpResponse {
        return when (t) {
            is TKeeperException -> {
                auditedResponse(
                    ctx = ctx,
                    httpStatusCode = t.errorType.statusCode,
                    errorType = t.errorType,
                    details = t.details
                )
            }

            is IdentifiableAbortException -> {
                LOGGER.error("Identifiable abort exception from peer ${t.peerId}: ${ctx.path()}", t)
                auditedResponse(
                    ctx = ctx,
                    httpStatusCode = ErrorType.IDENTIFIABLE_ABORT.statusCode,
                    errorType = ErrorType.IDENTIFIABLE_ABORT,
                    details = t.peerId.toString()
                )
            }

            else -> {
                LOGGER.error("Unhandled exception in KeeperExceptionHandler at ${ctx.path()}", t)
                auditedResponse(
                    ctx = ctx,
                    httpStatusCode = ErrorType.INTERNAL_ERROR.statusCode,
                    errorType = ErrorType.INTERNAL_ERROR
                )
            }
        }
    }

    private fun auditedResponse(
        ctx: ServiceRequestContext,
        httpStatusCode: Int,
        errorType: ErrorType,
        details: String? = null
    ): HttpResponse {
        val audited = try {
            support.finishAndAudit(ctx, httpStatusCode, errorType, details)
        } catch (e: Exception) {
            false
        }

        if (audited)
            return support.writeError(objectMapper, errorType, details)

        return support.auditFailed(objectMapper)
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(KeeperExceptionHandler::class.java)
    }
}