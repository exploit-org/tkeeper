package org.exploit.keeper.service.client

import jakarta.annotation.PostConstruct
import jakarta.inject.Singleton
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.succeed
import org.exploit.keeper.service.core.KeeperInitService
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.util.concurrent.CompletableFuture
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.AtomicInteger

@Singleton
class TKeeperClients(
    private val db: RocksKeyDB,
    private val clients: List<TKeeperClient>,
    private val initManager: KeeperInitService
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun findAll(): List<TKeeperClient> =
        clients

    fun findAllHealthy(): List<TKeeperClient> =
        this.findHealthy(clients.size)

    fun find(idx: Int): TKeeperClient? =
        clients.firstOrNull { it.peerId == idx }

    fun find(participants: Collection<Int>): List<TKeeperClient> =
        clients.filter { it.peerId in participants }

    fun findThreshold(): List<TKeeperClient> {
        return findHealthy(initData.threshold - 1)
    }

    fun findHealthy(required: Int): List<TKeeperClient> {
        require(required >= 0) { "required must be >= 0" }

        if (required == 0)
            return emptyList()

        if (required > clients.size)
            throw TKeeperException(ErrorType.NOT_ENOUGH_CONFIGURED_CLIENTS)

        val picked = ConcurrentLinkedQueue<TKeeperClient>()
        val found = AtomicInteger(0)
        val result = CompletableFuture<List<TKeeperClient>>()

        val checks = clients.map { client ->
            client.health.status().succeed().whenComplete { ok, _ ->
                if (ok != null && !result.isDone) {
                    picked.add(client)

                    if (found.incrementAndGet() == required) {
                        result.complete(picked.asSequence().take(required).toList())
                    }
                }
            }
        }

        CompletableFuture.allOf(*checks.toTypedArray()).whenComplete { _, _ ->
            if (!result.isDone) {
                result.completeExceptionally(
                    TKeeperException(ErrorType.NOT_ENOUGH_HEALTHY_CLIENTS)
                )
            }
        }

        return result.join()
    }

    fun findPublicKey(idx: Int): Ed25519PublicKey? =
        clients.firstOrNull { it.peerId == idx }?.publicKey?.get()

    fun forBroadcast(participants: List<Int>, exclude: Int? = initData.peerId): List<TKeeperClient> =
        clients.filter { it.peerId in participants && it.peerId != exclude }

    @PostConstruct
    private fun validateConfig() {
        LOGGER.info("Naively validating TKeeper client configuration...")

        if (!initManager.initialized()) {
            LOGGER.warn("TKeeper clients are not initialized. Skipping validation.")
            return
        }

        if (clients.any { it.peerId == initData.peerId }) {
            throw IllegalArgumentException(
                "Node list includes current node (id=${
                    initData.peerId
                }). A node should not reference itself as a peer."
            )
        }

        val ids = clients.map { it.peerId }
        val duplicateIds = ids.groupingBy { it }.eachCount().filter { it.value > 1 }

        if (duplicateIds.isNotEmpty()) {
            throw IllegalArgumentException(
                "Duplicate node IDs found: ${
                    duplicateIds.keys.joinToString(", ")
                }. Each node must have a unique ID."
            )
        }

        val urls = clients.map { it.url }
        val duplicateUrls = urls.groupingBy { it }.eachCount().filter { it.value > 1 }

        if (duplicateUrls.isNotEmpty()) {
            throw IllegalArgumentException("Duplicate node URLs found: ${duplicateUrls.keys.joinToString(", ")}. Each node must have a unique URL.")
        }

        val expectedPeers = initData.total - 1
        if (clients.size < expectedPeers) {
            throw IllegalArgumentException(
                "Insufficient peers configured: expected $expectedPeers (total=${
                    initData.total
                }, threshold=${initData.threshold}), found ${clients.size}."
            )
        }
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(TKeeperClients::class.java)
    }
}