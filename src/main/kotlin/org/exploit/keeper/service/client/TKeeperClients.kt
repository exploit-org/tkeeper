package org.exploit.keeper.service.client

import io.quarkus.runtime.configuration.ConfigurationException
import jakarta.annotation.PostConstruct
import jakarta.inject.Singleton
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.service.core.KeeperInitService
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class TKeeperClients(
    private val db: RocksKeyDB,
    private val clients: List<TKeeperClient>,
    private val initManager: KeeperInitService
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun findAll(): List<TKeeperClient> =
        clients

    fun find(idx: Int): TKeeperClient =
        clients.firstOrNull { it.peerId == idx }
            ?: throw IllegalArgumentException("Client with service ID $idx not found")

    fun findHealthy(required: Int): Mono<List<TKeeperClient>> =
        Flux.fromIterable(clients)
            .flatMap { client ->
                client.central.health().toMono()
                    .filter { it.body.ready }
                    .map { client }
                    .onErrorResume { Mono.empty() }
            }
            .take(required.toLong())
            .collectList()
            .handle { clients, sink ->
                if (clients.size < required) {
                    sink.error(TKeeperException(503, "Not enough healthy or initialized & unsealed clients available"))
                } else {
                    sink.next(clients)
                }
            }

    fun findThreshold(): Mono<List<TKeeperClient>> {
        return findHealthy(initData.threshold - 1)
    }

    fun forBroadcast(participants: List<Int>, exclude: Int? = initData.peerId): List<TKeeperClient> =
        clients.filter { it.peerId in participants && it.peerId != exclude }

    @PostConstruct
    private fun validateConfig() {
        LOGGER.info("Naively validating TKeeper client configuration...")

        if (!initManager.initialized()) {
            LOGGER.warn("TKeeper clients are not initialized. Skipping validation.")
            return
        }

        if (clients.any { it.peerId == initData.peerId }) {
            throw ConfigurationException(
                "Node list includes current node (id=${
                    initData.peerId
                }). A node should not reference itself as a peer."
            )
        }

        val ids = clients.map { it.peerId }
        val duplicateIds = ids.groupingBy { it }.eachCount().filter { it.value > 1 }

        if (duplicateIds.isNotEmpty()) {
            throw ConfigurationException(
                "Duplicate node IDs found: ${
                    duplicateIds.keys.joinToString(", ")
                }. Each node must have a unique ID."
            )
        }

        val urls = clients.map { it.url }
        val duplicateUrls = urls.groupingBy { it }.eachCount().filter { it.value > 1 }

        if (duplicateUrls.isNotEmpty()) {
            throw ConfigurationException("Duplicate node URLs found: ${duplicateUrls.keys.joinToString(", ")}. Each node must have a unique URL.")
        }

        val expectedPeers = initData.total - 1
        if (clients.size < expectedPeers) {
            throw ConfigurationException(
                "Insufficient peers configured: expected $expectedPeers (total=${
                    initData.total
                }, threshold=${initData.threshold}), found ${clients.size}."
            )
        }
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(TKeeperClients::class.java)
    }
}