package org.exploit.keeper.service.client

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toMono
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Singleton
class TKeeperClients(
    private val db: RocksKeyDB,
    private val clients: List<TKeeperClient>
) {
    private val initData by lazy {
        db.readInitData()
    }

    fun findAll(): List<TKeeperClient> =
        clients

    fun find(idx: Int): TKeeperClient =
        clients.firstOrNull { it.peerId == idx }
            ?: throw IllegalArgumentException("Client with service ID $idx not found")

    fun findHealthy(required: Int): Mono<List<TKeeperClient>> =
        Flux.fromIterable(clients)
            .flatMap { client ->
                client.central.health().toMono()
                    .filter { it.body.ready }
                    .map { client }
                    .onErrorResume { Mono.empty() }
            }
            .take(required.toLong())
            .collectList()
            .handle { clients, sink ->
                if (clients.size < required) {
                    sink.error(TKeeperException(503, "Not enough healthy or initialized & unsealed clients available"))
                } else {
                    sink.next(clients)
                }
            }

    fun findThreshold(): Mono<List<TKeeperClient>> {
        return findHealthy(initData.threshold - 1)
    }

    fun forBroadcast(participants: List<Int>, exclude: Int? = initData.peerId): List<TKeeperClient> =
        clients.filter { it.peerId in participants && it.peerId != exclude }
}