package org.exploit.keeper.service.dkg

import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.toBigInt
import org.exploit.keeper.model.keygen.ShamirShareDto
import org.exploit.keeper.service.dkg.generator.NodeKeyGen
import org.exploit.keeper.service.dkg.session.KeyGenSession
import org.exploit.keeper.util.KeySerializer
import org.exploit.keeper.util.temporary.InMemoryTemporaryMap
import org.exploit.tss.curve.PointOps
import java.util.concurrent.TimeUnit

@Singleton
class DistributedKeyGen(private val db: RocksKeyDB) {
    private val initData by lazy {
        db.readInitData()
    }

    private val sessions = InMemoryTemporaryMap<String, KeyGenSession<*>>(30, TimeUnit.MINUTES)

    fun <P : PointOps<P>> init(keyId: String, curve: KeeperCurve<P>, overwrite: Boolean, refresh: Boolean = false) {
        if (sessions.containsKey(keyId))
            throw TKeeperException(ErrorType.SESSION_ALREADY_EXISTS)

        if (db.storage.hasKey(keyId) && !overwrite && !refresh)
            throw TKeeperException(ErrorType.KEY_ALREADY_EXISTS, keyId)

        val t = initData.threshold
        val n = initData.total

        val keyGen = NodeKeyGen(
            curve = curve.params,
            n = n,
            t = t,
            zeroConst = refresh
        )

        val old = if (refresh) {
            val raw = db.storage.get(keyId) ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
            val deserialized = KeySerializer.deserialize(raw)

            if (deserialized.curve != curve.name)
                throw TKeeperException(ErrorType.CURVE_MISMATCH, "Expected ${curve.name}, got ${deserialized.curve}")

            deserialized.ski.toBigInt()
        } else null

        sessions.put(keyId, KeyGenSession(
            curve = curve,
            peerId = initData.peerId,
            gen = keyGen,
            n = n,
            oldShare = old
        )
        )
    }

    fun share(idx: Int, sessionId: String): ShamirShareDto {
        val session = sessions.get(sessionId) ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)
        return session.shareFor(idx)
    }

    fun store(keyId: String, share: ShamirShareDto) {
        val session = sessions.get(keyId)?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)
        val curveParams = session.curve.params
        val commitments = share.commitments.map { curveParams.decodePoint(it) as PointOps<*> }

        if (!NodeKeyGen.verifyShare(curveParams, initData.peerId, share.share, commitments)) {
            throw TKeeperException(ErrorType.INVALID_SHARE)
        }

        session.store(share.share)
    }

    fun compute(keyId: String) {
        try {
            val session = sessions.get(keyId) ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)
            val share = session.computeShare().toUnsignedByteArray(session.curve.keySize())

            db.storage.save(keyId, KeySerializer.serialize(session.curve.name, share))
            release(keyId)
        } catch (e: Exception) {
            abort(keyId)
            throw IllegalStateException("Failed to compute key", e)
        }
    }

    fun abort(keyId: String) {
        val session = sessions.get(keyId)?: return
        session.destroy()

        sessions.remove(keyId)
        db.storage.delete(keyId)
    }

    private fun release(keyId: String) {
        sessions.remove(keyId)?.destroy()
    }
}