package org.exploit.keeper.service.dkg

import jakarta.inject.Singleton
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.dkg.KeyGenMode
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodePointSafeIdentity
import org.exploit.keeper.extension.crypto.toBigInt
import org.exploit.keeper.model.key.KeyVersion
import org.exploit.keeper.model.keygen.DkgCommitments
import org.exploit.keeper.model.keygen.ShamirShareDto
import org.exploit.keeper.model.keygen.WrappedKeyGenSession
import org.exploit.keeper.model.keyset.KeySetMeta
import org.exploit.keeper.model.keyset.KeySetPolicy
import org.exploit.keeper.service.dkg.generator.NodeKeyGen
import org.exploit.keeper.service.dkg.session.KeyGenSession
import org.exploit.keeper.util.KeySerializer
import org.exploit.keeper.util.temporary.InMemoryTemporaryMap
import org.exploit.tss.curve.PointOps
import org.rocksdb.Transaction
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import java.time.Instant
import java.util.concurrent.TimeUnit

@Singleton
class DistributedKeyGen(config: KeeperConfig, private val db: RocksKeyDB) {
    private val initData by lazy {
        db.readInitData()
    }

    private val sessions = InMemoryTemporaryMap<String, WrappedKeyGenSession>(config.session.dkg.expire.seconds, TimeUnit.SECONDS)

    fun versions(keyId: String): KeyVersion = db.vault.readLatestVersion(keyId)

    fun <P : PointOps<P>> init(
        keyId: String,
        curve: KeeperCurve<P>,
        mode: KeyGenMode,
        policy: KeySetPolicy?,
        targetGeneration: Int,
        assetOwner: String? = null
    ) {
        if (sessions.containsKey(keyId))
            throw TKeeperException(ErrorType.SESSION_ALREADY_EXISTS)

        val existingRaw = db.vault.readCurrentKey(keyId)
        val hasExisting = existingRaw != null

        when (mode) {
            KeyGenMode.CREATE -> {
                if (hasExisting) throw TKeeperException(ErrorType.KEY_ALREADY_EXISTS, keyId)
            }
            KeyGenMode.ROTATE, KeyGenMode.REFRESH -> {
                if (!hasExisting) throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
            }
        }

        val t = initData.threshold
        val n = initData.total

        val zeroConst = mode == KeyGenMode.REFRESH

        val keyGen = NodeKeyGen(
            curve = curve.params,
            n = n,
            t = t,
            zeroConst = zeroConst
        )

        val oldShare = if (mode == KeyGenMode.REFRESH) {
            val raw = existingRaw ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
            val deserialized = KeySerializer.deserialize(raw)

            if (deserialized.curve != curve.name)
                throw TKeeperException(
                    ErrorType.CURVE_MISMATCH,
                    "Expected ${curve.name}, got ${deserialized.curve}"
                )

            deserialized.ski.toBigInt()
        } else null

        val oldAggCommits: List<PointOps<P>>? = if (mode == KeyGenMode.REFRESH) {
            val currentGen = db.vault.readLatestVersion(keyId).activeGen
                ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

            val old = db.commits.readActive(keyId, currentGen)
                ?: throw TKeeperException(ErrorType.CONSISTENCY_CHECK_FAILED, "Missing commits for $keyId/$currentGen")

            if (old.curve != curve.name)
                throw TKeeperException(ErrorType.CURVE_MISMATCH, "Expected ${curve.name}, got ${old.curve}")

            old.commitments.map { curve.params.decodePointSafeIdentity(it) }
        } else null

        val session = KeyGenSession(
            curve = curve,
            peerId = initData.peerId,
            gen = keyGen,
            n = n,
            oldShare = oldShare,
            oldAggCommits = oldAggCommits,
            zeroConst = zeroConst
        )

        sessions.put(
            keyId,
            WrappedKeyGenSession(
                mode = mode,
                curve = curve,
                session = session,
                targetGeneration = targetGeneration,
                policy = policy,
                assetOwner = assetOwner
            )
        )
    }

    fun share(idx: Int, sessionId: String): ShamirShareDto {
        val wrapper = sessions.get(sessionId)
            ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)

        return wrapper.session.shareFor(idx)
    }

    fun store(keyId: String, peerId: Int, share: ShamirShareDto) {
        val wrapper = sessions.get(keyId) ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)

        val curveParams = wrapper.curve.params
        val zeroConst = wrapper.mode == KeyGenMode.REFRESH

        if (!NodeKeyGen.verifyShare(curveParams, initData.peerId, share.share, share.commitments, zeroConst))
            throw TKeeperException(ErrorType.INVALID_SHARE)

        wrapper.session.store(peerId, share.share, share.commitments)
    }

    fun compute(keyId: String) {
        val wrapper = sessions.get(keyId) ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)

        try {
            val result = wrapper.session.computeResult()
            val shareBigInt = result.share
            val commits = result.aggCommitments
            val commitsEncoded = commits.map { it.encode(true) }

            val curve = wrapper.curve
            val shareBytes = shareBigInt.toUnsignedByteArray(curve.keySize())
            val serialized = KeySerializer.serialize(curve.name, shareBytes)

            val gen = wrapper.targetGeneration

            db.vault.ops.runInTransaction {
                db.vault.savePending(it, keyId, gen, serialized)
                db.commits.savePending(it, keyId, gen, DkgCommitments(curve.name, commitsEncoded))

                val now = Instant.now().epochSecond
                val head = db.meta.loadKeysetMeta(keyId)
                val meta = (head ?: KeySetMeta(
                    logicalId = keyId,
                    currentGeneration = gen,
                    enabled = true,
                    createdAt = now,
                    updatedAt = now,
                    policy = wrapper.policy,
                    assetOwner = wrapper.assetOwner
                )).copy(
                    currentGeneration = gen,
                    updatedAt = now,
                    policy = wrapper.policy,
                    assetOwner = wrapper.assetOwner
                )

                db.meta.savePendingKeysetMeta(it, meta)
            }
        } catch (e: Exception) {
            LOGGER.error("Exception during key generation for $keyId", e)
            val gen = wrapper.targetGeneration
            abort(keyId, gen)

            throw IllegalStateException("Failed to compute key", e)
        }
    }

    fun complete(keyId: String) {
        val wrapper = sessions.get(keyId) ?: throw TKeeperException(ErrorType.SESSION_NOT_FOUND)
        val gen = wrapper.targetGeneration

        try {
            db.vault.ops.runInTransaction {
                db.vault.promotePendingToActive(it,keyId, gen)
                db.commits.promotePendingToActiveIfPresent(it, keyId, gen)

                val promoted = db.meta.promotePendingMetaToActive(it, keyId, gen)
                if (promoted == null) {
                    db.meta.setCurrentGeneration(it,keyId, gen, wrapper.policy)
                    db.meta.dropPendingMeta(it,keyId, gen)
                }
            }
        } finally {
            release(keyId)
        }
    }

    fun dropPending(keyId: String, generation: Int) {
        db.vault.ops.runInTransaction {
            dropPending(it, keyId, generation)
        }
    }

    fun dropPending(tx: Transaction, keyId: String, generation: Int) {
        db.vault.deletePending(tx, keyId, generation)
        db.meta.dropPendingMeta(tx, keyId, generation)
        db.commits.deletePending(tx, keyId, generation)
    }

    fun sync(keyId: String, generation: Int) {
        db.vault.ops.runInTransaction {
            val v = db.vault.readLatestVersion(it, keyId)

            if (v.activeGen == generation) {
                db.meta.promotePendingMetaToActive(it, keyId, generation)
                db.vault.deletePending(it, keyId, generation)
                db.meta.dropPendingMeta(it, keyId, generation)
                db.commits.deletePending(it, keyId, generation)

                return@runInTransaction
            }

            val pendingKey = db.vault.readPending(it, keyId, generation)
            if (pendingKey != null) {
                db.vault.promotePendingToActive(it, keyId, generation)
                db.commits.promotePendingToActiveIfPresent(it, keyId, generation)
            } else {
                db.commits.deletePending(it, keyId, generation)
                db.meta.dropPendingMeta(it, keyId, generation)
                return@runInTransaction
            }

            db.meta.promotePendingMetaToActive(it, keyId, generation)

            db.commits.deletePending(it, keyId, generation)
            db.vault.deletePending(it, keyId, generation)
            db.meta.dropPendingMeta(it, keyId, generation)
        }
    }

    fun abort(keyId: String) {
        val wrapper = sessions.get(keyId) ?: return
        abort(keyId, wrapper.targetGeneration)
    }

    fun abortSession(keyId: String) {
        val wrapper = sessions.remove(keyId) ?: return
        wrapper.session.destroy()
    }

    fun abort(keyId: String, generation: Int) {
        val wrapper = sessions.remove(keyId)
        wrapper?.session?.destroy()

        db.vault.ops.runInTransaction {
            dropPending(it, keyId, generation)
            val v = db.vault.readLatestVersion(it, keyId)

            if (v.activeGen == generation) {
                db.commits.deleteActive(it, keyId, generation)
                db.vault.rollbackToGeneration(it, keyId, generation)
                db.meta.rollbackToLatest(it, keyId, generation)
            }
        }
    }

    private fun release(keyId: String) {
        val wrapper = sessions.remove(keyId) ?: return
        wrapper.session.destroy()
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(DistributedKeyGen::class.java)
    }
}