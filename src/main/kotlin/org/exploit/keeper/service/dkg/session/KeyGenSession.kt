package org.exploit.keeper.service.dkg.session

import org.exploit.gmp.BigInt
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.extension.crypto.decodePointSafeIdentity
import org.exploit.keeper.model.keygen.KeyGenResult
import org.exploit.keeper.model.keygen.ShamirShareDto
import org.exploit.keeper.service.dkg.generator.NodeKeyGen
import org.exploit.tss.curve.EllipticCurveParams
import org.exploit.tss.curve.PointOps
import java.util.concurrent.ConcurrentHashMap
import javax.security.auth.Destroyable

class KeyGenSession<P : PointOps<P>>(
    val curve: KeeperCurve<P>,
    private val peerId: Int,
    private val gen: NodeKeyGen<P>,
    private val n: Int,
    private val oldShare: BigInt? = null,
    private val oldAggCommits: List<PointOps<P>>? = null,
    private val zeroConst: Boolean = false
) : Destroyable {
    private val shares = mutableListOf<BigInt>()
    private val commitsByPeer = ConcurrentHashMap<Int, List<PointOps<P>>>()

    @Synchronized
    fun store(peerId: Int, share: BigInt, commits: List<ByteArray>) {
        if (shares.size >= n) throw IllegalStateException("Too many shares")
        if (commits.size != gen.commitments().size) throw IllegalStateException("Bad commits size")

        val commitments = commits.map { curve.params.decodePointSafeIdentity(it) }

        if (commitsByPeer.putIfAbsent(peerId, commitments) != null)
            throw IllegalStateException("Duplicate commits from peerId=$peerId")

        shares.add(share)
    }

    fun shareFor(idx: Int): ShamirShareDto {
        if (idx <= 0 || idx > n) {
            throw IllegalArgumentException("Invalid index")
        }

        val share = gen.shareFor(idx)
        val commitments = gen.commitments().map {
            it.encode(true)
        }

        return ShamirShareDto(share, commitments)
    }

    fun computeResult(): KeyGenResult<P> {
        if (shares.size < n - 1) throw IllegalStateException("Not enough shares")
        if (commitsByPeer.size < n - 1) throw IllegalStateException("Not enough commitments")

        val q = curve.params.curveOrder

        val myShare = gen.shareFor(peerId)
        val pieces = shares + myShare + listOfNotNull(oldShare)
        val finalShare = NodeKeyGen.aggregateShares(pieces, q)

        val all = ArrayList<List<PointOps<P>>>(n)
        all.add(gen.commitments())
        all.addAll(commitsByPeer.values)

        val t = gen.commitments().size
        val deltaAgg = ArrayList<PointOps<P>>(t)

        for (k in 0 until t) {
            var sum = curve.params.infinity as PointOps<P>
            for (peerCommits in all) {
                sum = sum.add(peerCommits[k] as P).normalize()
            }
            deltaAgg.add(sum)
        }

        val fullAgg = if (oldAggCommits != null) {
            if (oldAggCommits.size != deltaAgg.size) throw IllegalStateException("Old commits size mismatch")
            deltaAgg.indices.map { k ->
                (oldAggCommits[k]).add(deltaAgg[k] as P).normalize() as PointOps<P>
            }
        } else deltaAgg

        val Yi = computeYi(curve.params, fullAgg, peerId, zeroConst = false)
        return KeyGenResult(finalShare, fullAgg, Yi)
    }

    private fun computeYi(
        params: EllipticCurveParams<P>,
        aggCommits: List<PointOps<P>>,
        idx: Int,
        zeroConst: Boolean
    ): PointOps<P> {
        val q = params.curveOrder
        val x = BigInt.valueOf(idx.toLong()).mod(q)

        var pow = BigInt.ONE
        var rhs = params.infinity as PointOps<P>

        for ((k, Ck) in aggCommits.withIndex()) {
            if (!zeroConst || k != 0) {
                rhs = rhs.add((Ck).mul(pow)).normalize()
            }
            pow = pow.multiply(x).mod(q)
        }

        return rhs.normalize()
    }

    override fun destroy() {
        shares.clear()
        commitsByPeer.clear()
        gen.erase()
    }
}