package org.exploit.keeper.service.dkg.starter

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.constant.dkg.ConsistencyVerdict
import org.exploit.keeper.constant.dkg.KeyGenMode
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.perform
import org.exploit.keeper.model.keygen.ConsistencyCheck
import org.exploit.keeper.model.keygen.InitKeyGen
import org.exploit.keeper.model.keyset.KeySetPolicy
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperConsistencyService
import org.exploit.keeper.service.core.KeeperService
import org.exploit.keeper.service.dkg.DistributedKeyCollector
import org.exploit.keeper.service.dkg.DistributedKeyGen
import org.slf4j.Logger
import org.slf4j.LoggerFactory

@Singleton
class DKGenerator(
    private val consistency: KeeperConsistencyService,
    private val config: KeeperConfig,
    private val peers: TKeeperClients,
    private val keyGen: DistributedKeyGen,
    private val collector: DistributedKeyCollector,
    private val keeper: KeeperService
) {
    fun generateKey(keyId: String, curve: KeeperCurve<*>, mode: KeyGenMode, policy: KeySetPolicy?, assetOwner: String? = null) {
        keeper.ensureReady()
        policy?.validate()

        val clients = peers.findHealthy(config.peers.size)

        val fixed = consistency.tryAutoFix(keyId, clients)
        val targetGen = pickTargetGeneration(keyId, mode, fixed)

        var afterPersistenceStarted = false

        try {
            keyGen.init(keyId, curve, mode, policy, targetGen, assetOwner)
            clients.perform { it.keyGen.init(InitKeyGen(keyId, curve.name, targetGen, mode, policy, assetOwner)) }

            collector.collect(keyId, clients)
            clients.perform { it.keyGen.collect(keyId) }

            keyGen.compute(keyId)
            afterPersistenceStarted = true
            clients.perform { it.keyGen.compute(keyId) }

            keyGen.complete(keyId)
            clients.perform { it.keyGen.complete(keyId) }
        } catch (e: Exception) {
            if (!afterPersistenceStarted) {
                abortSessionsOnly(keyId, clients)
                throw e
            }

            abortSessionsOnly(keyId, clients)

            throw TKeeperException(
                ErrorType.INCONSISTENT_KEEPER,
                "Safe abort failed for keyId=$keyId, targetGen=$targetGen. Run /v1/keeper/consistency/fix after healthcheck",
                e
            )
        }
    }

    private fun pickTargetGeneration(keyId: String, mode: KeyGenMode, chk: ConsistencyCheck): Int {
        val versions = chk.versions

        fun uniformActiveOrThrow(): Int {
            val set = versions.values.map { it.activeGen }.toSet()
            if (set.size != 1 || set.first() == null) {
                throw TKeeperException(
                    ErrorType.CONSISTENCY_CHECK_FAILED,
                    "Uniform active expected for keyId=$keyId, actives=$set"
                )
            }
            return set.first()!!
        }

        fun maxSeenOrZero(): Int =
            versions.values
                .flatMap { listOf(it.activeGen, it.pendingGen) }
                .filterNotNull()
                .maxOrNull() ?: 0

        return when (mode) {
            KeyGenMode.CREATE -> when (chk.verdict) {
                ConsistencyVerdict.MISSING -> 1
                else -> throw TKeeperException(ErrorType.KEY_ALREADY_EXISTS, keyId)
            }

            KeyGenMode.ROTATE -> when (chk.verdict) {
                ConsistencyVerdict.MISSING -> throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
                ConsistencyVerdict.OK -> uniformActiveOrThrow() + 1
                ConsistencyVerdict.SYNC_NEEDED -> throw TKeeperException(ErrorType.CONSISTENCY_CHECK_FAILED, keyId)
                ConsistencyVerdict.ROTATE_NEEDED -> maxSeenOrZero() + 1
            }

            KeyGenMode.REFRESH -> when (chk.verdict) {
                ConsistencyVerdict.OK -> uniformActiveOrThrow() + 1
                ConsistencyVerdict.MISSING -> throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)
                else -> throw TKeeperException(ErrorType.ROTATE_NEEDED, "$keyId; verdict=${chk.verdict}")
            }
        }
    }

    private fun abortSessionsOnly(keyId: String, clients: List<TKeeperClient>) {
        keyGen.abortSession(keyId)

        try {
            clients.perform { it.keyGen.abortSession(keyId) }
        } catch (e: Exception) {
            LOGGER.error("Failed to abort remote keygen sessions for keyId=$keyId", e)
        }
    }

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(DKGenerator::class.java)
    }
}