package org.exploit.keeper.service.dkg.starter

import jakarta.inject.Singleton
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.extension.perform
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperInitService
import org.exploit.keeper.service.dkg.DistributedKeyCollector
import org.exploit.keeper.service.dkg.DistributedKeyGen
import org.slf4j.Logger
import org.slf4j.LoggerFactory

@Singleton
class DKGenerator(
    private val config: KeeperConfig,
    private val peers: TKeeperClients,
    private val keyGen: DistributedKeyGen,
    private val collector: DistributedKeyCollector,
    private val keeper: KeeperInitService
) {
    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(DKGenerator::class.java)
    }

    fun generateKey(keyId: String, curve: KeeperCurve<*>, overwrite: Boolean, refresh: Boolean) {
        keeper.ensureReady()

        val clients = peers.findHealthy(config.peers.size)

        try {
            keyGen.init(keyId, curve, overwrite, refresh)
            clients.perform { it.keyGen.init(keyId, curve.name, overwrite, refresh) }

            collector.collect(keyId, clients)
            clients.perform { it.keyGen.collect(keyId) }

            keyGen.compute(keyId)
            clients.perform { it.keyGen.compute(keyId) }
        } catch (e: Exception) {
            abort(keyId, clients)
            throw e
        }
    }

    private fun abort(keyId: String, clients: List<TKeeperClient>) {
        keyGen.abort(keyId)

        try {
            clients.perform { it.keyGen.abort(keyId) }
        } catch (e: Exception) {
            LOGGER.error("Failed to abort remote key generation for keyId=$keyId", e)
        }
    }
}