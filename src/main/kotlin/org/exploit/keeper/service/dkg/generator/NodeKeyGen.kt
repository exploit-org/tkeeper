package org.exploit.keeper.service.dkg.generator

import org.exploit.crypto.stereotype.Sensitive
import org.exploit.gmp.BigInt
import org.exploit.tss.curve.EllipticCurveParams
import org.exploit.tss.curve.PointOps
import org.exploit.tss.util.ZKRandom
import java.util.*

class NodeKeyGen<P : PointOps<P>>(
    private val curve: EllipticCurveParams<P>,
    private val n: Int, t: Int,
    zeroConst: Boolean = false
) : Sensitive {

    private val coef: Array<BigInt>
    private var commitments: List<PointOps<P>>? = null

    init {
        require(t in 1..n) { "bad t" }

        val q = curve.curveOrder
        coef = Array(t) { BigInt(q.bitLength(), ZKRandom.getRandom()).mod(q) }

        if (zeroConst) coef[0] = BigInt.ZERO

        val g = curve.g
        val tmp = ArrayList<PointOps<P>>(t)
        for (ak in coef) tmp.add(g.mul(ak))

        commitments = Collections.unmodifiableList(tmp)
    }

    fun commitments(): List<PointOps<P>> =
        commitments ?: error("Commitments have been erased")

    fun shareFor(idx: Int): BigInt {
        require(idx in 1..n) { "idx out of range" }

        val q = curve.curveOrder
        val x = BigInt.valueOf(idx.toLong())
        var pow = BigInt.ONE
        var s = BigInt.ZERO

        for (ak in coef) {
            s = s.add(ak.multiply(pow)).mod(q)
            pow = pow.multiply(x).mod(q)
        }
        return s
    }

    override fun erase() {
        coef.forEach { it.destroy() }
        commitments = null
    }

    companion object {
        fun <P : PointOps<P>> verifyShare(
            curve: EllipticCurveParams<P>,
            idx: Int,
            share: BigInt,
            commits: List<PointOps<P>>,
            zeroConst: Boolean = false
        ): Boolean {
            val q = curve.curveOrder
            val x = BigInt.valueOf(idx.toLong())
            val s = share.mod(q)

            val lhs = curve.g.mul(s).normalize()

            var pow = BigInt.ONE
            var rhs = curve.infinity

            for ((k, ck) in commits.withIndex()) {
                if (!zeroConst || k != 0)
                    rhs = rhs.add(ck.mul(pow))

                pow = pow.multiply(x).mod(q)
            }

            return lhs == rhs.normalize()
        }

        fun aggregateShares(shares: List<BigInt>, q: BigInt): BigInt =
            shares.fold(BigInt.ZERO) { acc, s -> acc.add(s).mod(q) }
    }
}