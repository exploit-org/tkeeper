package org.exploit.keeper.service.pub

import jakarta.inject.Singleton
import org.exploit.gmp.BigInt
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.tss.curve.PointOps

@Singleton
class PublicKeyRestorer(private val db: RocksKeyDB) {
    private val initData by lazy {
        db.readInitData()
    }

    fun <P : PointOps<P>> combine(curve: KeeperCurve<P>, shares: Map<Int, PointOps<P>>): PointOps<*> {
        require(shares.size >= initData.threshold) {
            "Not enough shares (required ${initData.threshold})"
        }

        val n = curve.params.curveOrder

        val lambdas: Map<Int, BigInt> = shares.keys.associateWith { i ->
            shares.keys.filter { it != i }.fold(BigInt.ONE) { acc, j ->
                val num = BigInt.ZERO.subtract(BigInt.valueOf(j.toLong())).mod(n)
                val den = BigInt.valueOf(i.toLong()).subtract(BigInt.valueOf(j.toLong())).mod(n)

                acc.multiply(num.multiply(den.modInverse(n))).mod(n)
            }
        }

        val inf = curve.params.infinity
        var result = inf

        for ((i, share) in shares) {
            val l = lambdas[i]!!
            result = result.add(share.mul(l))
        }

        result = result.normalize()

        return result
    }
}