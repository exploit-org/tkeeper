package org.exploit.keeper.service.pub.commits

import jakarta.inject.Singleton
import org.exploit.gmp.BigInt
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodePointSafeIdentity
import org.exploit.keeper.model.keygen.DkgCommitments
import org.exploit.tss.curve.EllipticCurveParams
import org.exploit.tss.curve.PointOps

@Singleton
class KeeperCommitmentService(private val db: RocksKeyDB) {
    fun <P: PointOps<P>> deriveYi(keyId: String, gen: Int, idx: Int, curve: KeeperCurve<P>): PointOps<P>? {
        require(idx >= 1) { "idx must be >= 1" }

        val commits = db.commits.readActive(keyId, gen)
            ?: return null

        if (commits.curve != curve.name)
            throw TKeeperException(ErrorType.CURVE_MISMATCH)

        return deriveYi(curve.params, commits, idx)
    }

    fun deriveYi(keyId: String, gen: Int, idx: Int): PointOps<*>? {
        require(idx >= 1) { "idx must be >= 1" }

        val commits = db.commits.readActive(keyId, gen)
            ?: return null

        val curve = KeeperCurve.fromName(commits.curve)

        return deriveYi(curve.params, commits, idx)
    }

    private fun <P : PointOps<P>> deriveYi(
        params: EllipticCurveParams<P>,
        commits: DkgCommitments,
        idx: Int
    ): P {
        val q = params.curveOrder
        val x = BigInt.valueOf(idx.toLong()).mod(q)

        var pow = BigInt.ONE
        var acc = params.infinity

        for (raw in commits.commitments) {
            val Ck = params.decodePointSafeIdentity(raw)
            acc = acc.add(Ck.mul(pow)).normalize()
            pow = pow.multiply(x).mod(q)
        }

        return acc.normalize()
    }
}