package org.exploit.keeper.service.pub.commits

import jakarta.inject.Singleton
import org.exploit.gmp.BigInt
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodePointSafeIdentity
import org.exploit.keeper.model.keygen.DkgCommitments
import org.exploit.keeper.util.TKeeperTweak
import org.exploit.tss.curve.PointOps

@Singleton
class KeeperCommitmentService(private val db: RocksKeyDB) {
    fun <P: PointOps<P>> deriveYi(keyId: String, gen: Int, idx: Int, curve: KeeperCurve<P>, tweak: String? = null): PointOps<P>? {
        require(idx >= 1) { "idx must be >= 1" }

        val commits = db.commits.readActive(keyId, gen)
            ?: return null

        if (commits.curve != curve.name)
            throw TKeeperException(ErrorType.CURVE_MISMATCH)

        return deriveYi(curve, keyId, commits, idx, tweak)
    }

    fun deriveYi(keyId: String, gen: Int, idx: Int, tweak: String? = null): PointOps<*>? {
        require(idx >= 1) { "idx must be >= 1" }

        val commits = db.commits.readActive(keyId, gen)
            ?: return null

        val curve = KeeperCurve.fromName(commits.curve)

        return deriveYi(curve, keyId, commits, idx, tweak)
    }

    private fun <P : PointOps<P>> deriveYi(
        curve: KeeperCurve<P>,
        keyId: String,
        commits: DkgCommitments,
        idx: Int,
        tweak: String?
    ): P {
        val params = curve.params
        val q = params.curveOrder
        val x = BigInt.valueOf(idx.toLong()).mod(q)

        var pow = BigInt.ONE
        var acc = params.infinity

        for (raw in commits.commitments) {
            val Ck = params.decodePointSafeIdentity(raw)
            acc = acc.add(Ck.mul(pow)).normalize()
            pow = pow.multiply(x).mod(q)
        }

        var yi = acc.normalize()

        if (tweak != null) {
            val curveId = curve.name
            val keyIdBytes = keyId.toByteArray()

            val t = TKeeperTweak.tweakScalar(
                curve = curveId,
                keyId = keyIdBytes,
                tweak = tweak,
                order = q
            )

            yi = yi.add(params.g.mul(t)).normalize()
        }

        return yi
    }
}