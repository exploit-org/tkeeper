package org.exploit.keeper.service.pub

import jakarta.inject.Singleton
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.RawPublicKeyDto
import org.exploit.keeper.model.key.PubKeyShare
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.pub.share.PublicKeyRestorer
import org.exploit.keeper.service.pub.share.PublicKeyShareCalculator
import org.exploit.tss.curve.PointOps
import reactor.core.publisher.Mono

@Singleton
class DistributedPublicKeyService(
    private val clients: TKeeperClients,
    private val restorer: PublicKeyRestorer,
    private val calculator: PublicKeyShareCalculator,
): PublicKeyService {
    override fun getPublicKey(keyId: String): Mono<RawPublicKeyDto> {
        val share = calculator.pubKeyShare(keyId)
        val curve = KeeperCurve.fromName(share.curve)

        return clients.findThreshold()
            .flatMapIterable { it }
            .flatMap { it.public.getPublicKeyShare(keyId).toMono()
                .flatMap { r -> r.successOrThrow() }
                .map { dto -> unwrap(it.peerId, dto, curve) }
            }
            .collectList()
            .map {
                val combined = restorer.combine(curve, (it + share).toCollectorMap())
                RawPublicKeyDto(combined.encode(true))
            }
    }

    private fun unwrap(idx: Int, dto: RawPublicKeyDto, curve: KeeperCurve<*>): PubKeyShare<*> {
        val point = curve.params.decodePoint(dto.data)
        return PubKeyShare(idx, curve.name, point)
    }

    private fun List<PubKeyShare<*>>.toCollectorMap(): Map<Int, PointOps<*>> {
        return this.associateBy { it.peerId }.mapValues { it.value.share }
    }
}