package org.exploit.keeper.service.pub

import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.performAndReturnDead
import org.exploit.keeper.model.RawPublicKeyDto
import org.exploit.keeper.model.common.Round
import org.exploit.keeper.model.key.PubKeyShare
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperService
import org.exploit.tss.curve.PointOps

@Singleton
class DistributedPublicKeyService(
    private val db: RocksKeyDB,
    private val keeper: KeeperService,
    private val clients: TKeeperClients,
    private val restorer: PublicKeyRestorer,
    private val calculator: PublicKeyShareCalculator,
): PublicKeyService {
    override fun fetchRound(keyId: String, version: Int?, tweak: String?, lastRound: Round<RawPublicKeyDto>?): Round<RawPublicKeyDto> {
        keeper.ensureReady()

        val deadNodes = lastRound?.dead ?: emptySet()
        val targetGeneration = version ?: db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        val share = calculator.pubKeyShare(keyId, targetGeneration, tweak)
        val curve = KeeperCurve.fromName(share.curve)

        val clients = clients.findThreshold(exclude = deadNodes)

        val (shareMap, dead) = clients.performAndReturnDead {
            it.public.getPublicKeyShare(keyId, targetGeneration, tweak)
        }

        if (dead.isNotEmpty())
            return Round(null, dead = dead + deadNodes, restart = true)

        val collectorMap = shareMap.mapValues { (peerId, response) ->
            unwrap(peerId, response.body, curve).share
        }.toMutableMap()

        collectorMap[share.peerId] = share.share

        val combined = restorer.combine(curve, collectorMap as Map<Int, PointOps<*>>)

        return Round(RawPublicKeyDto(combined.encode(true)))
    }

    override fun getPublicKey(keyId: String, version: Int?, tweak: String?, lastRound: Round<RawPublicKeyDto>?): RawPublicKeyDto {
        val round = fetchRound(keyId, version, tweak, lastRound)

        if (round.restart)
            return getPublicKey(keyId, version, tweak,round)

        return requireNotNull(round.value)
    }

    private fun unwrap(idx: Int, dto: RawPublicKeyDto, curve: KeeperCurve<*>): PubKeyShare<*> {
        val point = curve.params.decodePoint(dto.data)
        return PubKeyShare(idx, curve.name, point)
    }
}