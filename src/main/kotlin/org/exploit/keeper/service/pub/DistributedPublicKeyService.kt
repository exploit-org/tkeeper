package org.exploit.keeper.service.pub

import jakarta.inject.Singleton
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toBase64
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.PublicKeyDto
import org.exploit.keeper.model.key.PubKeyShare
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.keeper.service.misc.CurvePointDecoder
import org.exploit.keeper.service.pub.share.PublicKeyRestorer
import org.exploit.keeper.service.pub.share.PublicKeyShareCalculator
import org.exploit.threshield.curve.PointOps
import reactor.core.publisher.Mono

@Singleton
class DistributedPublicKeyService(
    private val clients: BitKeeperClients,
    private val restorer: PublicKeyRestorer,
    private val calculator: PublicKeyShareCalculator,
    private val pointDecoder: CurvePointDecoder
): PublicKeyService {
    override fun getPublicKey(keyId: String): Mono<PublicKeyDto> {
        val share = calculator.pubKeyShare(keyId)
        val curve = KeeperCurve.fromName(share.curve)

        return clients.findThreshold()
            .flatMapIterable { it }
            .flatMap { it.public.getPublicKeyShare(keyId).toMono()
                .map { dto -> unwrap(it.peerId, dto, curve) }
            }
            .collectList()
            .map {
                val combined = restorer.combine(curve, (it + share).toCollectorMap())
                PublicKeyDto(combined.encode(true).toBase64())
            }
    }

    private fun unwrap(idx: Int, dto: PublicKeyDto, curve: KeeperCurve<*>): PubKeyShare<*> {
        val point = pointDecoder.decode(curve.params, dto.data64.decodeBase64())
        return PubKeyShare(idx, curve.name, point)
    }

    private fun List<PubKeyShare<*>>.toCollectorMap(): Map<Int, PointOps<*>> {
        return this.associateBy { it.peerId }.mapValues { it.value.share }
    }
}