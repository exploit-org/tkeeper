package org.exploit.keeper.service.pub

import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.KeeperCurve
import org.exploit.keeper.db.RocksKeyDB
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.succeed
import org.exploit.keeper.extension.wait
import org.exploit.keeper.model.RawPublicKeyDto
import org.exploit.keeper.model.key.PubKeyShare
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.core.KeeperService
import org.exploit.tss.curve.PointOps
import java.util.concurrent.CompletableFuture

@Singleton
class DistributedPublicKeyService(
    private val db: RocksKeyDB,
    private val keeper: KeeperService,
    private val clients: TKeeperClients,
    private val restorer: PublicKeyRestorer,
    private val calculator: PublicKeyShareCalculator,
): PublicKeyService {
    override fun getPublicKey(keyId: String, version: Int?): RawPublicKeyDto {
        keeper.ensureReady()

        val targetGeneration = version ?: db.vault.readLatestVersion(keyId).activeGen
            ?: throw TKeeperException(ErrorType.KEY_NOT_FOUND, keyId)

        val share = calculator.pubKeyShare(keyId, targetGeneration)
        val curve = KeeperCurve.fromName(share.curve)

        val clients = clients.findThreshold()
        val shares = ArrayList<CompletableFuture<PubKeyShare<*>>>()

        for (client in clients) {
            shares.add(client.public.getPublicKeyShare(keyId, targetGeneration).succeed().thenApply {
                unwrap(client.peerId, it, curve)
            })
        }

        val fetched = shares.wait() + share
        val combined = restorer.combine(curve, fetched.toCollectorMap())

        return RawPublicKeyDto(combined.encode(true))
    }

    private fun unwrap(idx: Int, dto: RawPublicKeyDto, curve: KeeperCurve<*>): PubKeyShare<*> {
        val point = curve.params.decodePoint(dto.data)
        return PubKeyShare(idx, curve.name, point)
    }

    private fun List<PubKeyShare<*>>.toCollectorMap(): Map<Int, PointOps<*>> {
        return this.associateBy { it.peerId }.mapValues { it.value.share }
    }
}