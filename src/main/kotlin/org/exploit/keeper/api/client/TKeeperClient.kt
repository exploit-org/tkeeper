package org.exploit.keeper.api.client

import org.exploit.crypto.Hash
import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.jettyx.Jettyx
import org.exploit.keeper.api.*
import org.exploit.keeper.api.auth.KeeperAuthenticator
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toSchnorrSignature
import org.exploit.keeper.util.cache.CachedValue
import org.exploit.tss.exception.IdentifiableAbortException

class TKeeperClient(val peerId: Int, auth: KeeperAuthenticator, val url: String, publicClient: Jettyx, internalClient: Jettyx) {
    private val publicKey: CachedValue<Ed25519PublicKey> = CachedValue(
        expireAfterMillis = 60 * 60 * 1000,
        compute = {
            Ed25519PublicKey(integrity.publicKey().data)
        }
    )

    val keyStore: KeyStoreApi by lazy {
        internalClient.newApiClient(url, auth).create(KeyStoreApi::class.java)
    }

    val frost: FrostApi by lazy {
        internalClient.newApiClient(url, auth).create(FrostApi::class.java)
    }

    val gg20: GG20Api by lazy {
        internalClient.newApiClient(url, auth).create(GG20Api::class.java)
    }

    val central: CentralApi by lazy {
        publicClient.newApiClient(url, auth).create(CentralApi::class.java)
    }

    val keyGen: KeyGenApi by lazy {
        internalClient.newApiClient(url, auth).create(KeyGenApi::class.java)
    }

    val public: PublicKeyApi by lazy {
        internalClient.newApiClient(url, auth).create(PublicKeyApi::class.java)
    }

    val ecies: ECIESApi by lazy {
        internalClient.newApiClient(url, auth).create(ECIESApi::class.java)
    }

    private val integrity: IntegrityApi by lazy {
        internalClient.newApiClient(url, auth).create(IntegrityApi::class.java)
    }

    fun verifySignature(signature: String, path: String, timestamp: Long): Boolean {
        try {
            if (System.currentTimeMillis() - timestamp > 30 * 1000)
                return false

            val sig = signature.decodeBase64()
                .toSchnorrSignature()

            val payload = Hash.sha256("${peerId}:$path:$timestamp".toByteArray())

            return Ed25519Provider.getInstance().verify(payload, sig, publicKey.get())
        } catch (e: Exception) {
            throw IdentifiableAbortException(peerId, "Signature verification failed", e)
        }
    }
}