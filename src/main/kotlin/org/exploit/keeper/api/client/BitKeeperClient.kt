package org.exploit.keeper.api.client

import org.exploit.crypto.Hash
import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.jettyx.Jettyx
import org.exploit.keeper.api.*
import org.exploit.keeper.api.auth.KeeperAuthenticator
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toSchnorrSignature
import org.exploit.threshield.exception.IdentifiableAbortException

class BitKeeperClient(val peerId: Int, private val publicKey: Ed25519PublicKey, auth: KeeperAuthenticator, url: String, jettyx: Jettyx) {
    val frost: FrostApi by lazy {
        jettyx.newApiClient(url, auth).create(FrostApi::class.java)
    }

    val gg20: GG20Api by lazy {
        jettyx.newApiClient(url, auth).create(GG20Api::class.java)
    }

    val health: CentralApi by lazy {
        jettyx.newApiClient(url, auth).create(CentralApi::class.java)
    }

    val keyGen: KeyGenApi by lazy {
        jettyx.newApiClient(url, auth).create(KeyGenApi::class.java)
    }

    val public: PublicKeyApi by lazy {
        jettyx.newApiClient(url, auth).create(PublicKeyApi::class.java)
    }

    fun verifySignature(signature: String, path: String, timestamp: Long): Boolean {
        try {
            if (System.currentTimeMillis() - timestamp > 30 * 1000)
                return false

            val sig = signature.decodeBase64()
                .toSchnorrSignature()

            val payload = Hash.sha256("$peerId:$path:$timestamp".toByteArray())

            return Ed25519Provider.getInstance().verify(payload, sig, publicKey)
        } catch (e: Exception) {
            throw IdentifiableAbortException(peerId, "Signature verification failed", e)
        }
    }
}