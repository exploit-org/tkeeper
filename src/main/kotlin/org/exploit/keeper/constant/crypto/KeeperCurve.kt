package org.exploit.keeper.constant.crypto

import org.exploit.ed25519.Ed25519CurveParams
import org.exploit.ed25519.Ed25519PointOps
import org.exploit.secp256k1.Secp256k1CurveParams
import org.exploit.secp256k1.Secp256k1PointOps
import org.exploit.tss.curve.EllipticCurveParams
import org.exploit.tss.curve.PointOps
import kotlin.reflect.KClass

sealed class KeeperCurve<P : PointOps<P>>(
    val params: EllipticCurveParams<P>,
    val opsClass: KClass<P>
) {
    data object SECP256K1 : KeeperCurve<Secp256k1PointOps>(Secp256k1CurveParams(), Secp256k1PointOps::class) {
        override fun keySize(): Int = 32

        override fun createPointOps(bytes: ByteArray): Secp256k1PointOps =
            params.decodePoint(bytes) as Secp256k1PointOps

        override fun supportedSessions(): List<SessionType> {
            return listOf(SessionType.GG20, SessionType.FROST)
        }

        override fun supportedSignatureTypes(): List<SignatureType> {
            return listOf(SignatureType.SCHNORR, SignatureType.SEC1R65SCHNORR, SignatureType.ECDSA)
        }

        override val name: CurveName = CurveName.SECP256K1
    }

    data object ED25519: KeeperCurve<Ed25519PointOps>(Ed25519CurveParams(), Ed25519PointOps::class) {
        override fun keySize(): Int = 32

        override fun createPointOps(bytes: ByteArray): Ed25519PointOps =
            params.decodePoint(bytes) as Ed25519PointOps

        override fun supportedSessions(): List<SessionType> {
            return listOf(SessionType.FROST)
        }

        override fun supportedSignatureTypes(): List<SignatureType> {
            return listOf(SignatureType.SCHNORR)
        }

        override val name: CurveName = CurveName.ED25519
    }

    abstract fun keySize(): Int

    abstract fun createPointOps(bytes: ByteArray): P

    abstract fun supportedSessions(): List<SessionType>

    abstract fun supportedSignatureTypes(): List<SignatureType>

    abstract val name: CurveName

    companion object {
        fun <P: PointOps<P>> fromName(name: CurveName): KeeperCurve<*> {
            return when(name) {
                CurveName.SECP256K1 -> SECP256K1
                CurveName.ED25519 -> ED25519
            }
        }
    }
}