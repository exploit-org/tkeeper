package org.exploit.keeper.util.jackson

import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.JsonParser
import com.fasterxml.jackson.core.JsonToken
import com.fasterxml.jackson.databind.*
import com.fasterxml.jackson.databind.node.ObjectNode
import org.exploit.gmp.BigInt
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.crypto.ContextKind
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.model.signature.BIP340Context
import org.exploit.keeper.model.signature.SignatureContext
import org.exploit.keeper.model.signature.TaprootContext

object JacksonCustomizer {
    object BigIntHexSerializer : JsonSerializer<BigInt>() {
        override fun serialize(value: BigInt?, gen: JsonGenerator, serializers: SerializerProvider?) {
            if (value == null) {
                gen.writeNull()
                return
            }

            var hex = value.toJavaInt().abs().toString(16)
            if (value.signum() < 0) {
                hex = "-$hex"
            }

            gen.writeString(hex)
        }

        override fun handledType(): Class<BigInt> {
            return BigInt::class.java
        }
    }

    object BigIntHexDeserializer : JsonDeserializer<BigInt>() {
        override fun deserialize(p: JsonParser, ctxt: DeserializationContext): BigInt? {
            if (p.currentToken() === JsonToken.VALUE_NULL) {
                return null
            }

            var text: String
            if (p.currentToken().isNumeric) {
                text = p.numberValue.toString()
                return BigInt(text, 10)
            } else {
                text = p.valueAsString.trim()
            }

            val negative = text.startsWith("-")
            if (negative) {
                text = text.substring(1)
            }
            if (text.startsWith("0x") || text.startsWith("0X")) {
                text = text.substring(2)
            }
            if (text.isEmpty()) {
                throw ctxt.weirdStringException(text, BigInt::class.java, "empty hexadecimal value")
            }

            val result = BigInt(text, 16)
            return if (negative) result.negate() else result
        }

        override fun handledType(): Class<*> {
            return BigInt::class.java
        }
    }

    object SignatureContextDeserializer: JsonDeserializer<SignatureContext>() {
        override fun deserialize(p0: JsonParser, p1: DeserializationContext): SignatureContext {
            val codec = p0.codec as ObjectMapper
            val tree: ObjectNode = codec.readTree(p0)

            val kindRaw = tree.get("kind")?.asText()
                ?: throw TKeeperException(ErrorType.INVALID_SIGNATURE_CONTEXT_KIND)

            val kind = ContextKind.fromString(kindRaw)
                ?: throw TKeeperException(ErrorType.INVALID_SIGNATURE_CONTEXT_KIND, kindRaw)

            return when(kind) {
                ContextKind.BIP340 -> BIP340Context()
                ContextKind.TAPROOT -> {
                    val merkleRoot64 = tree.get("merkleRoot64")

                    if (merkleRoot64 == null || merkleRoot64.isNull)
                        return TaprootContext(null)

                    TaprootContext(merkleRoot64.asText())
                }
            }
        }
    }
}