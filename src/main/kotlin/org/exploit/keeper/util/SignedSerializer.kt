package org.exploit.keeper.util

import org.exploit.keeper.model.SignedPayload
import java.nio.ByteBuffer
import java.nio.ByteOrder

object SignedSerializer {
    private const val SIG_LEN = 64
    private const val MAGIC = 0x53474E44

    fun serialize(data: ByteArray, keyVersion: Int, signature: ByteArray): ByteArray {
        require(signature.size == SIG_LEN) { "Signature must be $SIG_LEN bytes, got ${signature.size}" }

        val out = ByteArray(4 + 4 + 4 + data.size + SIG_LEN)
        val bb = ByteBuffer.wrap(out).order(ByteOrder.BIG_ENDIAN)

        bb.putInt(MAGIC)
        bb.putInt(keyVersion)
        bb.putInt(data.size)
        bb.put(data)
        bb.put(signature)

        return out
    }

    fun deserialize(bytes: ByteArray): SignedPayload {
        if (bytes.size < 4 + 4 + 4 + SIG_LEN)
            throw IllegalArgumentException("Too short: ${bytes.size}")

        val bb = ByteBuffer.wrap(bytes).order(ByteOrder.BIG_ENDIAN)

        val magic = bb.int
        require(magic == MAGIC) {
            "Invalid magic"
        }

        val keyVersion = bb.int
        val dataLen = bb.int

        require(dataLen >= 0) { "Negative data length" }
        require(dataLen <= bb.remaining() - SIG_LEN) { "Invalid data length: $dataLen" }

        val data = ByteArray(dataLen)
        bb.get(data)

        val signature = ByteArray(SIG_LEN)
        bb.get(signature)

        if (bb.hasRemaining())
            throw IllegalArgumentException("Trailing bytes (${bb.remaining()})")

        return SignedPayload(data, keyVersion, signature)
    }
}