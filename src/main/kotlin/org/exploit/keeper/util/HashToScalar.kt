package org.exploit.keeper.util

import org.exploit.gmp.BigInt
import org.exploit.tss.util.Bytes
import java.security.MessageDigest

object HashToScalar {
    private val OVERSIZE_DST_PREFIX = "H2C-OVERSIZE-DST-".toByteArray(Charsets.US_ASCII)

    fun expandMessageXmd(hashAlg: String, sInBytes: Int, msg: ByteArray?, dst: ByteArray?, lenInBytes: Int): ByteArray {
        val m = msg ?: ByteArray(0)
        var d = dst ?: ByteArray(0)

        require(lenInBytes >= 0) { "lenInBytes < 0" }
        if (lenInBytes == 0) return ByteArray(0)

        val md = MessageDigest.getInstance(hashAlg)
        val bInBytes = md.digestLength
        require(bInBytes > 0) { "Cannot determine digest length for $hashAlg" }

        if (d.size > 255)
            d = hash(hashAlg, Bytes.concat(OVERSIZE_DST_PREFIX, d))

        require(d.size <= 255) { "DST too long (must be <= 255 after oversize handling)" }

        val ell = (lenInBytes + bInBytes - 1) / bInBytes
        require(ell <= 255) { "ell > 255" }
        require(lenInBytes <= 65535) { "lenInBytes > 65535" }
        require(lenInBytes <= 255 * bInBytes) { "lenInBytes > 255 * bInBytes" }

        val dstPrime = Bytes.concat(d, i2osp(d.size, 1))
        val zPad = ByteArray(sInBytes)
        val lIBStr = i2osp(lenInBytes, 2)

        val msgPrime = Bytes.concat(zPad, m, lIBStr, i2osp(0, 1), dstPrime)
        val b0 = hash(hashAlg, msgPrime)

        var bPrev = hash(hashAlg, Bytes.concat(b0, i2osp(1, 1), dstPrime))

        val uniform = ByteArray(ell * bInBytes)
        System.arraycopy(bPrev, 0, uniform, 0, bInBytes)

        for (i in 2..ell) {
            val x = strXor(b0, bPrev)
            val bi = hash(hashAlg, Bytes.concat(x, i2osp(i, 1), dstPrime))
            System.arraycopy(bi, 0, uniform, (i - 1) * bInBytes, bInBytes)
            bPrev = bi
        }

        return uniform.copyOfRange(0, lenInBytes)
    }

    fun hashToScalarXmd(
        hashAlg: String,
        dst: ByteArray,
        msg: ByteArray,
        order: BigInt,
        lenInBytes: Int = 48
    ): BigInt {
        val sInBytes = when (hashAlg) {
            "SHA-256" -> 64
            "SHA-512" -> 128
            else -> throw IllegalArgumentException("Unsupported hashAlg for auto sInBytes: $hashAlg")
        }

        val uniform = expandMessageXmd(hashAlg, sInBytes, msg, dst, lenInBytes)
        return BigInt(1, uniform).mod(order)
    }

    private fun hash(hashAlg: String, input: ByteArray): ByteArray {
        val md = MessageDigest.getInstance(hashAlg)
        md.update(input)
        return md.digest()
    }

    private fun i2osp(v: Int, size: Int): ByteArray {
        require(size in 1..4) { "i2osp size must be 1..4" }

        val out = ByteArray(size)
        for (i in 0 until size) {
            val shift = 8 * (size - 1 - i)
            out[i] = ((v ushr shift) and 0xFF).toByte()
        }
        return out
    }

    private fun strXor(a: ByteArray, b: ByteArray): ByteArray {
        require(a.size == b.size) { "strXor: size mismatch" }
        val out = ByteArray(a.size)
        for (i in a.indices) {
            out[i] = (a[i].toInt() xor b[i].toInt()).toByte()
        }
        return out
    }
}