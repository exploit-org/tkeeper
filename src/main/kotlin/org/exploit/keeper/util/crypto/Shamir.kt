package org.exploit.keeper.util.crypto

import org.exploit.gmp.BigInt
import org.exploit.gmp.util.PrimeNumberGenerator
import java.security.SecureRandom
import java.util.*
import javax.security.auth.Destroyable

object Shamir {
    private const val SECRET_SIZE = 32
    private val random = SecureRandom()

    data class Share(val x: BigInt, val y: BigInt, val prime: BigInt) : Destroyable {
        fun toBase64(): String {
            val enc = Base64.getEncoder()
            val xB64 = enc.encodeToString(x.toUnsignedByteArray(unsignedSize(x)))
            val yB64 = enc.encodeToString(y.toUnsignedByteArray(unsignedSize(prime)))
            val pB64 = enc.encodeToString(prime.toUnsignedByteArray(unsignedSize(prime)))
            return listOf(xB64, yB64, pB64).joinToString(":")
        }

        override fun destroy() {
            y.destroy()
        }

        companion object {
            fun fromBase64(data: String): Share {
                val dec = Base64.getDecoder()
                val parts = data.split(":")
                require(parts.size == 3) { "Invalid share format" }

                val x = BigInt(1, dec.decode(parts[0]))
                val y = BigInt(1, dec.decode(parts[1]))
                val prime = BigInt(1, dec.decode(parts[2]))

                return Share(x, y, prime)
            }
        }
    }

    fun generateSecretKey(): ByteArray =
        ByteArray(SECRET_SIZE).also { random.nextBytes(it) }

    fun split(secret: ByteArray, n: Int, k: Int): List<Share> {
        require(secret.size == SECRET_SIZE) { "Secret must be exactly $SECRET_SIZE bytes" }
        require(n > 0) { "n must be positive" }
        require(k in 1..n) { "Threshold k must satisfy 1 <= k <= n" }

        val secretInt = BigInt(1, secret)

        val prime = PrimeNumberGenerator.generate(secretInt.bitLength() + 1).also {
            require(it.isProbablePrime(80)) { "PrimeNumberGenerator returned a non-prime modulus" }
        }

        val coeffs = List(k - 1) { BigInt(prime.bitLength(), random).mod(prime) }

        return (1..n).map { i ->
            val x = BigInt(i.toString())
            var y = secretInt

            coeffs.forEachIndexed { idx, a ->
                y = y.add(a.multiply(x.pow(idx + 1))).mod(prime)
            }

            Share(x, y, prime)
        }
    }

    fun combine(shares: List<Share>): ByteArray {
        require(shares.isNotEmpty()) { "Shares list must not be empty" }

        require(shares.all { !it.x.isDestroyed() && !it.y.isDestroyed() && !it.prime.isDestroyed() }) {
            "One or more shares contain destroyed BigInt values"
        }

        val prime = shares[0].prime
        require(shares.all { it.prime == prime }) { "Shares use different primes" }

        val xs = shares.map { it.x }
        require(xs.distinct().size == xs.size) { "Duplicate x in shares" }

        var secret = BigInt.ZERO

        for (i in shares.indices) {
            val xi = shares[i].x
            val yi = shares[i].y

            var num = BigInt.ONE
            var den = BigInt.ONE

            for (j in shares.indices) {
                if (i == j) continue
                val xj = shares[j].x
                num = num.multiply(xj).mod(prime)
                den = den.multiply(xj.subtract(xi)).mod(prime)
            }

            val lagrange = num.multiply(den.modInverse(prime)).mod(prime)
            secret = secret.add(yi.multiply(lagrange)).mod(prime)
        }

        return secret.toUnsignedByteArray(SECRET_SIZE)
    }

    fun encodeShares(shares: List<Share>): List<String> = shares.map { it.toBase64() }
    fun decodeShares(data: List<String>): List<Share> = data.map { Share.fromBase64(it) }

    private fun unsignedSize(v: BigInt): Int =
        ((v.bitLength() + 7) / 8).coerceAtLeast(1)
}