package org.exploit.keeper.util.crypto

import org.exploit.gmp.BigInt
import org.exploit.gmp.util.PrimeNumberGenerator
import java.security.SecureRandom
import java.util.*
import javax.security.auth.Destroyable

object Shamir {
    private val random = SecureRandom()

    data class Share(val x: BigInt, val y: BigInt, val prime: BigInt): Destroyable {
        fun toBase64(): String {
            val encoder = Base64.getEncoder()
            val xB64 = encoder.encodeToString(x.toByteArray())
            val yB64 = encoder.encodeToString(y.toByteArray())
            val pB64 = encoder.encodeToString(prime.toByteArray())
            return listOf(xB64, yB64, pB64).joinToString(":")
        }

        override fun destroy() {
            x.destroy()
            y.destroy()
            prime.destroy()
        }

        companion object {
            fun fromBase64(data: String): Share {
                val decoder = Base64.getDecoder()
                val parts = data.split(":")
                require(parts.size == 3) { "Invalid share format" }

                val x = BigInt(1, decoder.decode(parts[0]))
                val y = BigInt(1, decoder.decode(parts[1]))
                val prime = BigInt(1, decoder.decode(parts[2]))

                return Share(x, y, prime)
            }
        }
    }

    fun split(secret: ByteArray, n: Int, k: Int): List<Share> {
        require(k in 1..n) { "Threshold k must satisfy 1 <= k <= n" }

        val secretInt = BigInt(1, secret)

        val prime = PrimeNumberGenerator.generate(secretInt.bitLength() + 1)
        val coeffs = List(k - 1) { BigInt(prime.bitLength(), random).mod(prime) }

        return (1..n).map { i ->
            val x = BigInt.valueOf(i.toLong())
            var y = secretInt
            coeffs.forEachIndexed { idx, a ->
                y = y.add(a.multiply(x.pow(idx + 1))).mod(prime)
            }
            Share(x, y, prime)
        }
    }

    fun combine(shares: List<Share>): ByteArray {
        require(shares.isNotEmpty()) { "Shares list must not be empty" }

        val prime = shares[0].prime

        var secret = BigInt.ZERO

        for (i in shares.indices) {
            val (xi, yi) = shares[i]
            var num = BigInt.ONE
            var den = BigInt.ONE

            for (j in shares.indices) {
                if (i == j) continue
                val xj = shares[j].x
                num = num.multiply(xj).mod(prime)
                den = den.multiply(xj.subtract(xi)).mod(prime)
            }

            val lagrangeCoeff = num.multiply(den.modInverse(prime)).mod(prime)
            secret = secret.add(yi.multiply(lagrangeCoeff)).mod(prime)
        }

        val secretBytes = secret.toByteArray()

        return if (secretBytes.size > 1 && secretBytes[0] == 0.toByte()) {
            secretBytes.copyOfRange(1, secretBytes.size)
        } else {
            secretBytes
        }
    }

    fun generateSecretKey(): ByteArray {
        val key = ByteArray(32)
        random.nextBytes(key)
        return key
    }

    fun encodeShares(shares: List<Share>): List<String> = shares.map { it.toBase64() }

    fun decodeShares(data: List<String>): List<Share> = data.map { Share.fromBase64(it) }
}