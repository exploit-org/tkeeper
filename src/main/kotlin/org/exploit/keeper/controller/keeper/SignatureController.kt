package org.exploit.keeper.controller.keeper

import io.smallrye.mutiny.Uni
import jakarta.validation.constraints.NotNull
import jakarta.ws.rs.POST
import jakarta.ws.rs.Path
import jakarta.ws.rs.container.ContainerRequestContext
import org.exploit.keeper.constant.Permission
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toUni
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.VerifyResult
import org.exploit.keeper.model.request.Sign
import org.exploit.keeper.model.request.Verify
import org.exploit.keeper.service.auth.policy.MachinePolicyChecker
import org.exploit.keeper.service.core.KeeperInitService
import org.exploit.keeper.service.signature.instance.SessionManagerResolver
import org.exploit.keeper.service.signature.verify.manager.SignatureVerifyManager

@Path("/v1/keeper")
class SignatureController(
    private val resolver: SessionManagerResolver,
    private val keeper: KeeperInitService,
    private val policyChecker: MachinePolicyChecker,
    private val ctx: ContainerRequestContext,
    private val verifyManager: SignatureVerifyManager
) {
    @POST
    @Path("/sign")
    fun sign(@NotNull body: Sign): Uni<TSSResult> {
        policyChecker.ensureHasPermission(ctx, Permission.keySign(body.keyId))
        keeper.ensureReady()

        val manager = resolver.findByKeyId(body.type, body.keyId)
            ?: throw TKeeperException(400, "Session manager not found for ${body.type} -> ${body.keyId}")

        return manager.sign(body)
    }

    @POST
    @Path("/sign/verify")
    fun verify(@NotNull body: Verify): Uni<VerifyResult> {
        policyChecker.ensureHasPermission(ctx, Permission.keyVerify(body.keyId))
        keeper.ensureReady()

        return verifyManager.verify(body)
            .map { VerifyResult(it) }
            .toUni()
    }
}