package org.exploit.keeper.controller.keeper

import io.quarkus.arc.All
import io.smallrye.mutiny.Uni
import jakarta.validation.constraints.NotNull
import jakarta.ws.rs.BadRequestException
import jakarta.ws.rs.POST
import jakarta.ws.rs.Path
import jakarta.ws.rs.container.ContainerRequestContext
import org.exploit.keeper.constant.Permission
import org.exploit.keeper.exception.BitKeeperException
import org.exploit.keeper.exception.SealedException
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.VerifyResult
import org.exploit.keeper.model.request.Sign
import org.exploit.keeper.model.request.Verify
import org.exploit.keeper.service.auth.policy.MachinePolicyChecker
import org.exploit.keeper.service.core.KeeperSealService
import org.exploit.keeper.service.signature.instance.SessionManagerResolver
import org.exploit.keeper.service.signature.verify.SignatureVerifier

@Path("/v1/keeper")
class SignatureController(
    private val resolver: SessionManagerResolver,
    private val keeper: KeeperSealService,
    private val policyChecker: MachinePolicyChecker,
    private val ctx: ContainerRequestContext,

    @All
    private val verifiers: MutableList<SignatureVerifier>
) {
    @POST
    @Path("/sign")
    fun sign(@NotNull body: Sign): Uni<TSSResult> {
        policyChecker.ensureHasPermission(ctx, Permission.keySign(body.keyId))

        if (!keeper.initialized() || keeper.sealed())
            throw SealedException()

        val manager = resolver.findManager(body.type, body.curve)
            ?: throw BitKeeperException(400, "Session manager not found for ${body.type} -> ${body.curve}")

        return manager.sign(body)
    }

    @POST
    @Path("/sign/verify")
    fun verify(@NotNull body: Verify): Uni<VerifyResult> {
        policyChecker.ensureHasPermission(ctx, Permission.keyVerify(body.keyId))

        if (!keeper.initialized() || keeper.sealed())
            throw SealedException()

        val sigType = body.sigType ?: body.curve.fallbackSigType
        val verifier = verifiers.find { it.curve() == body.curve && it.type() == sigType}
            ?: throw BadRequestException()

        val data = body.data64.decodeBase64()
        val signature = verifier.createSignature(body.signature64.decodeBase64())

        return verifier.verify(body.keyId, data, signature)
            .map { VerifyResult(it) }
    }
}