package org.exploit.keeper.controller.keeper

import jakarta.validation.constraints.NotNull
import jakarta.ws.rs.*
import jakarta.ws.rs.container.ContainerRequestContext
import org.exploit.keeper.constant.Permission
import org.exploit.keeper.model.request.Unseal
import org.exploit.keeper.model.seal.StatusResponse
import org.exploit.keeper.model.seal.init.InitData
import org.exploit.keeper.model.seal.progress.Progress
import org.exploit.keeper.service.auth.policy.MachinePolicyChecker
import org.exploit.keeper.service.core.KeeperSealService

@Path("/v1/keeper/system")
class SystemController(
    private val keeper: KeeperSealService,
    private val ctx: ContainerRequestContext,
    private val policyChecker: MachinePolicyChecker
) {
    @POST
    @Path("/init")
    fun init(): InitData {
        policyChecker.ensureHasPermission(ctx, Permission.systemInit())
        return keeper.initialize()
    }

    @GET
    @Path("/status")
    fun status(): StatusResponse {
        policyChecker.ensureHasPermission(ctx, Permission.systemStatus())
        return keeper.status()
    }

    @PUT
    @Path("/unseal")
    fun unseal(@NotNull req: Unseal): Progress {
        policyChecker.ensureHasPermission(ctx, Permission.systemUnseal())

        val payloads = buildList {
            req.payload64?.let { add(it) }
            addAll(req.payloads64)
        }

        if (payloads.isEmpty()) {
            throw BadRequestException("At least one payload64 must be provided")
        }

        for (payload in payloads) {
            val progress = keeper.submit(payload)

            if (progress.ready) {
                return progress
            }
        }

        return keeper.status().progress
    }

    @PUT
    @Path("/seal")
    fun seal() {
        policyChecker.ensureHasPermission(ctx, Permission.systemSeal())
        keeper.seal()
    }
}