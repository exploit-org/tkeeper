package org.exploit.keeper.controller.keeper

import jakarta.validation.constraints.NotNull
import jakarta.ws.rs.*
import jakarta.ws.rs.container.ContainerRequestContext
import jakarta.ws.rs.core.Response
import org.exploit.keeper.constant.Permission
import org.exploit.keeper.constant.StoreState
import org.exploit.keeper.model.request.KeeperInitData
import org.exploit.keeper.model.request.Unseal
import org.exploit.keeper.model.seal.StatusResponse
import org.exploit.keeper.model.seal.init.SealInitData
import org.exploit.keeper.model.seal.progress.Progress
import org.exploit.keeper.service.auth.policy.MachinePolicyChecker
import org.exploit.keeper.service.core.KeeperInitService

@Path("/v1/keeper/system")
class SystemController(
    private val keeper: KeeperInitService,
    private val ctx: ContainerRequestContext,
    private val policyChecker: MachinePolicyChecker
) {
    @POST
    @Path("/init")
    fun init(body: KeeperInitData): SealInitData {
        policyChecker.ensureHasPermission(ctx, Permission.systemInit())
        body.validate()

        return keeper.initialize(body)
    }

    @GET
    @Path("/status")
    fun status(): StatusResponse {
        policyChecker.ensureHasPermission(ctx, Permission.systemStatus())
        return keeper.status()
    }

    @GET
    @Path("/health")
    fun health(): Response {
        return Response.noContent().build()
    }

    @GET
    @Path("/ready")
    fun ready(): Response {
        val status = keeper.status().state

        return if (status == StoreState.UNSEALED)
            Response.noContent().build()
        else
            Response.status(503).build()
    }

    @PUT
    @Path("/unseal")
    fun unseal(@NotNull req: Unseal): Progress {
        policyChecker.ensureHasPermission(ctx, Permission.systemUnseal())

        val payloads = buildList {
            req.payload64?.let { add(it) }
            addAll(req.payloads64)
        }

        if (payloads.isEmpty()) {
            throw BadRequestException("At least one payload64 must be provided")
        }

        for (payload in payloads) {
            val progress = keeper.submit(payload)

            if (progress.ready) {
                return progress
            }
        }

        return keeper.status().progress
    }

    @PUT
    @Path("/seal")
    fun seal() {
        policyChecker.ensureHasPermission(ctx, Permission.systemSeal())
        keeper.seal()
    }
}