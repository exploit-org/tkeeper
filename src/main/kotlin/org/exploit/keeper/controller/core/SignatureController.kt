package org.exploit.keeper.controller.core

import io.quarkus.arc.All
import io.smallrye.mutiny.Uni
import jakarta.ws.rs.BadRequestException
import jakarta.ws.rs.POST
import jakarta.ws.rs.Path
import jakarta.ws.rs.container.ContainerRequestContext
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.Permission
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.exception.SealedException
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.unwrap
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.VerifyResult
import org.exploit.keeper.model.request.Sign
import org.exploit.keeper.model.request.Verify
import org.exploit.keeper.service.auth.policy.MachinePolicyChecker
import org.exploit.keeper.service.core.KeeperSealService
import org.exploit.keeper.service.signature.frost.initiator.FrostSignatureService
import org.exploit.keeper.service.signature.gg20.initiator.GG20SignatureService
import org.exploit.keeper.service.signature.verify.SignatureVerifier

@Path("/v1/keeper")
class SignatureController(
    private val gg20: GG20SignatureService,
    private val frost: FrostSignatureService,
    private val keeper: KeeperSealService,
    private val policyChecker: MachinePolicyChecker,
    private val ctx: ContainerRequestContext,

    @All
    private val verifiers: MutableList<SignatureVerifier>
) {
    @POST
    @Path("/sign")
    fun sign(body: Sign): Uni<TSSResult> {
        if (!keeper.initialized() || keeper.sealed())
            throw SealedException()

        policyChecker.ensureHasPermission(ctx, Permission.keySign(body.keyId))

        return when (body.type) {
            SessionType.GG20 -> gg20.sign(
                sessionId = body.sessionId,
                keyId = body.keyId,
                operations = body.operations.unwrap(),
                curve = KeeperCurve.fromName(body.curve)
            )

            SessionType.FROST -> frost.sign(
                sessionId = body.sessionId,
                keyId = body.keyId,
                operations = body.operations.unwrap(),
                curve = KeeperCurve.fromName(body.curve)
            )
        }
    }

    @POST
    @Path("/sign/verify")
    fun verify(body: Verify): Uni<VerifyResult> {
        if (!keeper.initialized() || keeper.sealed())
            throw SealedException()

        val verifier = verifiers.find { it.curve() == body.curve } ?: throw BadRequestException()
        val data = body.data64.decodeBase64()
        val signature = verifier.createSignature(body.signature64.decodeBase64())

        return verifier.verify(body.keyId, data, signature)
            .map { VerifyResult(it) }
    }
}