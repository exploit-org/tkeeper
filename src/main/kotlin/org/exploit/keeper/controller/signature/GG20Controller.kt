package org.exploit.keeper.controller.signature

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import jakarta.validation.constraints.NotNull
import jakarta.ws.rs.*
import org.exploit.gmp.BigInt
import org.exploit.keeper.api.auth.KeeperAuthenticator
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.exception.BitKeeperException
import org.exploit.keeper.extension.toUni
import org.exploit.keeper.extension.unwrap
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.Value
import org.exploit.keeper.model.gg20.commitment.GG20GammaCommitmentDto
import org.exploit.keeper.model.gg20.commitment.GG20OfflinePhaseData
import org.exploit.keeper.model.gg20.mta.GG20MtAComputeRequest
import org.exploit.keeper.model.gg20.mta.GG20MtAResult
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.keeper.service.signature.instance.SessionManagerResolver

@Singleton
@Path("/v1/gg20")
class GG20Controller(
    private val resolver: SessionManagerResolver
) {
    @POST
    @Path("/init")
    fun init(@NotNull session: InitSession) {
        manager(session.curve).createSession(
            sessionId = session.sessionId,
            keyId = session.keyId,
            operations = session.operations.unwrap(),
            participants = session.participants,
            publicKey = session.publicKey
        )
    }

    @POST
    @Path("/commitment")
    fun storeCommitment(
        @NotNull @QueryParam("sessionId") sessionId: String,
        @NotNull @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) peerId: Int,
        @NotNull body: GG20GammaCommitmentDto
    ) {
        manager(sessionId).respondent.commitment
            .storeCommitment(sessionId, peerId, body)
    }

    @POST
    @Path("/commitment/broadcast")
    fun broadcast(
        @NotNull @QueryParam("sessionId") sessionId: String
    ): Uni<Void> =
        manager(sessionId).respondent
            .commitment
            .broadcastGammaCommitment(sessionId)
            .toUni()

    @POST
    @Path("/mta/exchange")
    fun exchange(@NotNull @QueryParam("sessionId") sessionId: String): Uni<Void> =
        manager(sessionId).respondent.mta
            .exchange(sessionId)
            .toUni()

    @POST
    @Path("/mta/compute")
    fun compute(
        @NotNull @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) idx: Int,
        @NotNull body: GG20MtAComputeRequest
    ): GG20MtAResult =
        manager(body.sessionId)
            .respondent.mta
            .compute(idx, body)

    @POST
    @Path("/prephase")
    fun storeOfflinePhase(
        @NotNull @QueryParam("sessionId") sessionId: String,
        @NotNull @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) idx: Int,
        @NotNull body: GG20OfflinePhaseData
    ) {
        manager(sessionId).respondent.offlinePhase
            .store(sessionId, idx, body)
    }

    @POST
    @Path("/prephase/broadcast")
    fun broadcastOfflinePhase(@NotNull @QueryParam("sessionId") sessionId: String): Uni<Void> =
        manager(sessionId).respondent
            .offlinePhase
            .broadcast(sessionId)
            .toUni()

    @GET
    @Path("/signature/s")
    fun computeS(@NotNull @QueryParam("sessionId") sessionId: String): Value<BigInt> =
        manager(sessionId).respondent.sigPart
            .computePartialS(sessionId, finalize = true)

    @POST
    @Path("/abort")
    fun abort(@NotNull @QueryParam("sessionId") sessionId: String) {
        manager(sessionId).clear(sessionId)
    }

    private fun manager(curve: CurveName): GG20SessionManager<*> =
        resolver.findManager(SessionType.GG20, curve) as? GG20SessionManager<*>
            ?: throw BitKeeperException(400, "GG20 Session manager not found for $curve")

    private fun manager(sessionId: String): GG20SessionManager<*> =
        resolver.findBySessionId(SessionType.GG20, sessionId) as? GG20SessionManager<*>
            ?: throw BitKeeperException(400, "GG20 Session manager not found for $sessionId")
}