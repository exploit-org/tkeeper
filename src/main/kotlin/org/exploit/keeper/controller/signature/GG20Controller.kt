package org.exploit.keeper.controller.signature

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import jakarta.ws.rs.*
import org.exploit.keeper.api.auth.KeeperAuthenticator
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.toUni
import org.exploit.keeper.extension.unwrap
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.Value
import org.exploit.keeper.model.gg20.commitment.GG20GammaCommitmentDto
import org.exploit.keeper.model.gg20.commitment.GG20OfflinePhaseData
import org.exploit.keeper.model.gg20.mta.GG20MtAComputeRequest
import org.exploit.keeper.model.gg20.mta.GG20MtAResult
import org.exploit.keeper.service.signature.gg20.*
import java.math.BigInteger

@Singleton
@Path("/v1/gg20")
class GG20Controller(
    private val factory: GG20SessionFactory,
    private val commitmentHandler: GG20CommitmentHandler,
    private val mtAHandler: GG20MtAHandler,
    private val offlinePhase: GG20OfflinePhaseHandler,
    private val signaturePartHandler: GG20SignaturePartHandler
) {
    @POST
    @Path("/init")
    fun init(session: InitSession) {
        val curve = KeeperCurve.fromName(session.curve)

        factory.createSession(
            sessionId = session.sessionId,
            keyId = session.keyId,
            operations = session.operations.unwrap(),
            participants = session.participants,
            curve = curve,
            publicKey = session.publicKey
        )
    }

    @POST
    @Path("/commitment")
    fun storeCommitment(
        @QueryParam("sessionId") sessionId: String,
        @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) peerId: Int,
        body: GG20GammaCommitmentDto
    ) {
        commitmentHandler.storeCommitment(sessionId, peerId, body)
    }

    @POST
    @Path("/commitment/broadcast")
    fun broadcast(@QueryParam("sessionId") sessionId: String): Uni<Void> =
        commitmentHandler.broadcastGammaCommitment(sessionId).toUni()

    @POST
    @Path("/mta/exchange")
    fun exchange(@QueryParam("sessionId") sessionId: String): Uni<Void> =
        mtAHandler.exchange(sessionId).toUni()

    @POST
    @Path("/mta/compute")
    fun compute(
        @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) idx: Int,
        body: GG20MtAComputeRequest
    ): GG20MtAResult {
       return mtAHandler.compute(idx, body)
    }

    @POST
    @Path("/prephase")
    fun storeOfflinePhase(
        @QueryParam("sessionId") sessionId: String,
        @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) idx: Int,
        body: GG20OfflinePhaseData
    ) {
        offlinePhase.store(sessionId, idx, body)
    }

    @POST
    @Path("/prephase/broadcast")
    fun broadcastOfflinePhase(@QueryParam("sessionId") sessionId: String): Uni<Void> =
        offlinePhase.broadcast(sessionId).toUni()

    @GET
    @Path("/signature/s")
    fun computeS(@QueryParam("sessionId") sessionId: String): Value<BigInteger> =
        signaturePartHandler.computePartialS(sessionId, finalize = true)

    @POST
    @Path("/abort")
    fun abort(@QueryParam("sessionId") sessionId: String) {
        factory.clear(sessionId)
    }
}