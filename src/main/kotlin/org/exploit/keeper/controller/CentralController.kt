package org.exploit.keeper.controller

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import jakarta.ws.rs.GET
import jakarta.ws.rs.POST
import jakarta.ws.rs.Path
import jakarta.ws.rs.QueryParam
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.constant.SessionType.FROST
import org.exploit.keeper.constant.SessionType.GG20
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.model.PublicKeyDto
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.request.Sign
import org.exploit.keeper.service.frost.initiator.FrostSignatureService
import org.exploit.keeper.service.gg20.initiator.GG20SignatureService
import org.exploit.keeper.service.pub.PublicKeyService
import org.jboss.resteasy.reactive.ResponseStatus

@Singleton
@Path("/v1/keeper")
class CentralController(
    private val gg20: GG20SignatureService,
    private val frost: FrostSignatureService,
    private val pub: PublicKeyService
) {
    @Path("/ping")
    @ResponseStatus(200)
    fun ping() {}

    @POST
    @Path("/sign")
    fun sign(body: Sign): Uni<TSSResult> = when (body.type) {
        GG20 -> gg20.sign(
            sessionId = body.sessionId,
            keyId = body.keyId,
            message = body.message64.decodeBase64(),
            curve = KeeperCurve.fromName(body.curve)
        )

        FROST -> frost.sign(
            sessionId = body.sessionId,
            keyId = body.keyId,
            message = body.message64.decodeBase64(),
            curve = KeeperCurve.fromName(body.curve)
        )
    }

    @GET
    @Path("/publicKey")
    fun publicKey(@QueryParam("keyId") keyId: String): PublicKeyDto =
        pub.getPublicKey(keyId)
}