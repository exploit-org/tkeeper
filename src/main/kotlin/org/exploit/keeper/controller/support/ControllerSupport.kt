package org.exploit.keeper.controller.support

import com.fasterxml.jackson.databind.ObjectMapper
import com.linecorp.armeria.common.*
import com.linecorp.armeria.server.Route
import com.linecorp.armeria.server.ServerBuilder
import com.linecorp.armeria.server.ServiceRequestContext
import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.media.MsgPack
import org.exploit.keeper.extension.http.auditId
import org.exploit.keeper.extension.messagePackMapper
import org.exploit.keeper.extension.objectMapper
import org.exploit.keeper.model.ErrorMessage
import org.exploit.keeper.model.audit.ctx.Ctx
import org.exploit.keeper.model.audit.ctx.Outcome
import org.exploit.keeper.model.capability.HasCryptoContext
import org.exploit.keeper.model.capability.HasSessionId
import org.exploit.keeper.service.audit.AuditContextService
import org.exploit.keeper.service.audit.AuditService
import org.slf4j.Logger
import org.slf4j.LoggerFactory

@Singleton
class ControllerSupport(
    private val audit: AuditService,
    private val auditCtx: AuditContextService
) {
    fun <O : Any> ServerBuilder.publicGet(
        path: String,
        handler: (ServiceRequestContext) -> O
    ) {
        this.service(route(HttpMethod.GET, path)) { ctx, _ ->
            val out = handler(ctx)

            finish(out, ctx, MediaType.JSON, objectMapper)
        }
    }

    fun <I : Any, O : Any> ServerBuilder.publicPost(
        path: String,
        type: Class<I>,
        handler: (ServiceRequestContext, I) -> O
    ) {
        this.service(route(HttpMethod.POST, path)) { ctx, req ->
            HttpResponse.of(
                req.aggregate().thenApply { agg ->
                    val requestBytes = agg.content().array()

                    val body: I = try {
                        objectMapper.readValue(requestBytes, type)
                    } catch (e: Exception) {
                        finishAndAudit(ctx, ErrorType.INVALID_REQUEST_BODY.statusCode, ErrorType.INVALID_REQUEST_BODY, e.message)
                        return@thenApply writeJsonError(ErrorType.INVALID_REQUEST_BODY)
                    }

                    inspectBody(requestBytes, body, ctx)

                    val out = handler(ctx, body)
                    finish(out, ctx, MediaType.JSON, objectMapper)
                }
            )
        }
    }

    fun ServerBuilder.publicPostRaw(path: String, handler: (ServiceRequestContext) -> HttpResponse) {
        this.service(route(HttpMethod.POST, path)) { ctx, _ ->
            val out = handler(ctx)

            if (!finishAndAudit(ctx, HttpStatus.OK.code(), null, null))
                return@service auditFailedJson()

            out
        }
    }

    fun <O: Any> ServerBuilder.publicPost(path: String, handler: (ServiceRequestContext) -> O) {
        this.service(route(HttpMethod.POST, path)) { ctx, req ->
            val out = handler(ctx)
            finish(out, ctx, MediaType.JSON, objectMapper)
        }
    }

    fun ServerBuilder.delete(path: String, handler: (ServiceRequestContext) -> HttpResponse) {
        this.service(route(HttpMethod.DELETE, path)) { ctx, _ ->
            val out = handler(ctx)

            if (!finishAndAudit(ctx, HttpStatus.OK.code(), null, null))
                return@service auditFailedJson()

            out
        }
    }

    fun ServerBuilder.internalPost(
        path: String,
        handler: (ServiceRequestContext) -> Any
    ) {
        service(route(HttpMethod.POST, path)) { ctx, _ ->
            val out = handler(ctx)
            finish(out, ctx, MsgPack.MEDIA_TYPE, messagePackMapper)
        }
    }

    fun <O : Any> ServerBuilder.internalGet(
        path: String,
        handler: (ServiceRequestContext) -> O
    ) {
        this.service(route(HttpMethod.GET, path)) { ctx, _ ->
            val out = handler(ctx)
            finish(out, ctx, MsgPack.MEDIA_TYPE, messagePackMapper)
        }
    }

    fun <I : Any, O : Any> ServerBuilder.internalPost(
        path: String,
        type: Class<I>,
        handler: (ServiceRequestContext, I) -> O
    ) {
        this.service(route(HttpMethod.POST, path)) { ctx, req ->
            HttpResponse.of(
                req.aggregate().thenApply { agg ->
                    val requestBytes = agg.content().array()

                    val body: I = try {
                        messagePackMapper.readValue(requestBytes, type)
                    } catch (e: Exception) {
                        finishAndAudit(ctx, ErrorType.INVALID_REQUEST_BODY.statusCode, ErrorType.INVALID_REQUEST_BODY, e.message)
                        return@thenApply writeMsgpackError(ErrorType.INVALID_REQUEST_BODY)
                    }

                    inspectBody(requestBytes, body, ctx)

                    val out = handler(ctx, body)
                    finish(out, ctx, MsgPack.MEDIA_TYPE, messagePackMapper)
                }
            )
        }
    }

    fun finishOkJson(ctx: ServiceRequestContext): HttpResponse {
        if (!finishAndAudit(ctx, HttpStatus.OK.code(), null, null))
            return auditFailedJson()

        return HttpResponse.of(HttpStatus.OK)
    }

    fun finishNoContent(ctx: ServiceRequestContext): HttpResponse {
        if (!finishAndAudit(ctx, HttpStatus.NO_CONTENT.code(), null, null))
            return auditFailedJson()

        return HttpResponse.of(HttpStatus.NO_CONTENT)
    }

    fun finishUnavailable(ctx: ServiceRequestContext): HttpResponse {
        if (!finishAndAudit(ctx, HttpStatus.SERVICE_UNAVAILABLE.code(), null, null))
            return auditFailedJson()

        return HttpResponse.of(HttpStatus.SERVICE_UNAVAILABLE)
    }

    fun finishNoContentMsgpack(ctx: ServiceRequestContext): HttpResponse {
        if (!finishAndAudit(ctx, HttpStatus.NO_CONTENT.code(), null, null))
            return auditFailedMsgpack()

        return HttpResponse.of(HttpStatus.NO_CONTENT)
    }

    fun finishErrorJson(ctx: ServiceRequestContext, err: ErrorType, details: String? = null): HttpResponse {
        if (!finishAndAudit(ctx, err.statusCode, err, details))
            return auditFailedJson()

        return writeJsonError(err, details)
    }

    fun finishErrorMsgpack(ctx: ServiceRequestContext, err: ErrorType, details: String? = null): HttpResponse {
        if (!finishAndAudit(ctx, err.statusCode, err, details))
            return auditFailedMsgpack()

        return writeMsgpackError(err, details)
    }

    private fun finish(out: Any, ctx: ServiceRequestContext, mediaType: MediaType, mapper: ObjectMapper): HttpResponse {
        if (out is HttpResponse) {
            if (!finishAndAudit(ctx, HttpStatus.OK.code(), null, null))
                return auditFailedMsgpack()

            return out
        }

        if (out === Unit)
            return finishNoContentMsgpack(ctx)

        val bytes = mapper.writeValueAsBytes(out)

        if (!finishAndAudit(ctx, HttpStatus.OK.code(), null, null))
            return auditFailedMsgpack()

        return HttpResponse.of(HttpStatus.OK, mediaType, HttpData.copyOf(bytes))
    }

    fun finishAndAudit(
        ctx: ServiceRequestContext,
        statusCode: Int,
        error: ErrorType?,
        details: String? = null,
        imposters: List<String>? = null,
        dead: List<String>? = null
    ): Boolean {
        val rid = ctx.auditId() ?: return true

        auditCtx.updateIfPresent(rid) {
            it.imposters = imposters?.sorted()
            it.dead = dead?.sorted()

            it.out = Outcome(
                statusCode = statusCode,
                error = error,
                details = details
            )
        }

        val event = auditCtx.finish(rid) ?: return true

        return try {
            audit.log(event)
            true
        } catch (e: Exception) {
            LOGGER.error("Failed to audit event (${event.event})", e)
            false
        }
    }

    private fun inspectBody(bytes: ByteArray, body: Any, ctx: ServiceRequestContext) {
        ctx.auditId()?.let {
            auditCtx.updateIfPresent(it) { a ->
                if (body is HasCryptoContext) a.crypto = body.crypto()
                if (body is HasSessionId) a.ctx = Ctx(sid = body.sessionId)
                a.reqBody = bytes
            }
        }
    }

    private fun route(method: HttpMethod, path: String): Route = Route.builder()
        .methods(method)
        .path(path)
        .build()

    fun writeError(mapper: ObjectMapper, error: ErrorType, details: String? = null, imposters: Collection<String>? = null, dead: Collection<String>? = null): HttpResponse {
        val body = ErrorMessage(
            code = error.errorCode,
            error = error,
            details = details,
            imposters = imposters?.sorted(),
            dead = dead?.sorted()
        )

        val bytes = mapper.writeValueAsBytes(body)
        return HttpResponse.of(HttpStatus.valueOf(error.statusCode), MediaType.JSON, HttpData.copyOf(bytes))
    }

    fun writeWarning(warning: String): HttpResponse {
        return HttpResponse.of(ResponseHeaders.of(HttpStatus.valueOf(299), "Warning", warning))
    }

    fun writeJsonError(error: ErrorType, details: String? = null): HttpResponse {
        return writeError(objectMapper, error, details)
    }

    private fun writeMsgpackError(error: ErrorType, details: String? = null): HttpResponse {
        return writeError(messagePackMapper, error, details)
    }

    fun auditFailedJson(): HttpResponse =
        auditFailed(objectMapper)

    fun auditFailedMsgpack(): HttpResponse =
        auditFailed(messagePackMapper)

    fun auditFailed(mapper: ObjectMapper, imposters: Set<String>? = null, dead: Set<String>? = null): HttpResponse =
        writeError(mapper, ErrorType.AUDIT_FAILED, null, imposters, dead)

    fun auditNotAvailable(mapper: ObjectMapper): HttpResponse =
        writeError(mapper, ErrorType.AUDIT_NOT_AVAILABLE)

    private companion object {
        val LOGGER: Logger = LoggerFactory.getLogger(ControllerSupport::class.java)
    }
}
