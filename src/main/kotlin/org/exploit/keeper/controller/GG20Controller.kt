package org.exploit.keeper.controller

import io.smallrye.mutiny.Uni
import jakarta.inject.Singleton
import jakarta.ws.rs.*
import org.exploit.keeper.api.auth.KeeperAuthenticator
import org.exploit.keeper.constant.KeeperCurve
import org.exploit.keeper.extension.decodeBase64
import org.exploit.keeper.extension.toUni
import org.exploit.keeper.model.TSSResult
import org.exploit.keeper.model.common.InitSession
import org.exploit.keeper.model.common.Value
import org.exploit.keeper.model.gg20.commitment.GG20GammaCommitmentDto
import org.exploit.keeper.model.gg20.commitment.GG20OfflinePhaseData
import org.exploit.keeper.model.gg20.mta.GG20MtAComputeRequest
import org.exploit.keeper.model.gg20.mta.GG20MtAResult
import org.exploit.keeper.model.request.Sign
import org.exploit.keeper.service.gg20.*
import org.exploit.keeper.service.gg20.initiator.GG20SignatureService
import java.math.BigInteger

@Singleton
@Path("/v1/gg20")
class GG20Controller(
    private val factory: GG20SessionFactory,
    private val commitmentHandler: GG20CommitmentHandler,
    private val mtAHandler: GG20MtAHandler,
    private val offlinePhase: GG20OfflinePhaseHandler,
    private val signaturePartHandler: GG20SignaturePartHandler,
    private val signature: GG20SignatureService
) {
    @POST
    @Path("/sign")
    fun sign(body: Sign): Uni<TSSResult> {
        val curve = KeeperCurve.fromName(body.curve)
        return signature.sign(body.sessionId, body.keyId, body.message64.decodeBase64(), curve)
    }

    @POST
    @Path("/init")
    fun init(session: InitSession) {
        factory.createSession(
            sessionId = session.sessionId,
            keyId = session.keyId,
            message = session.message64.decodeBase64(),
            participants = session.participants,
            curve = KeeperCurve.fromName(session.curve)
        )
    }

    @POST
    @Path("/commitment")
    fun storeCommitment(
        @QueryParam("sessionId") sessionId: String,
        @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) peerId: Int,
        body: GG20GammaCommitmentDto
    ) {
        commitmentHandler.storeCommitment(sessionId, peerId, body)
    }

    @POST
    @Path("/commitment/broadcast")
    fun broadcast(@QueryParam("sessionId") sessionId: String): Uni<Void> =
        commitmentHandler.broadcastGammaCommitment(sessionId).toUni()

    @POST
    @Path("/mta/exchange")
    fun exchange(@QueryParam("sessionId") sessionId: String): Uni<Void> =
        mtAHandler.exchange(sessionId).toUni()

    @POST
    @Path("/mta/compute")
    fun compute(
        @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) idx: Int,
        body: GG20MtAComputeRequest
    ): GG20MtAResult {
       return mtAHandler.compute(idx, body)
    }

    @POST
    @Path("/prephase")
    fun storeOfflinePhase(
        @QueryParam("sessionId") sessionId: String,
        @HeaderParam(KeeperAuthenticator.HEADER_INSTANCE_ID) idx: Int,
        body: GG20OfflinePhaseData
    ) {
        offlinePhase.store(sessionId, idx, body)
    }

    @POST
    @Path("/prephase/broadcast")
    fun broadcastOfflinePhase(@QueryParam("sessionId") sessionId: String): Uni<Void> =
        offlinePhase.broadcast(sessionId).toUni()

    @GET
    @Path("/signature/s")
    fun computeS(@QueryParam("sessionId") sessionId: String): Value<BigInteger> =
        signaturePartHandler.computePartialS(sessionId, finalize = true)

    @POST
    @Path("/abort")
    fun abort(@QueryParam("sessionId") sessionId: String) {
        factory.clear(sessionId)
    }
}