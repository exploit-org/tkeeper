package org.exploit.keeper.controller.external

import com.linecorp.armeria.server.ServerBuilder
import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.permission.Permission
import org.exploit.keeper.controller.support.ControllerSupport
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.crypto.decodeBase64
import org.exploit.keeper.extension.http.auditId
import org.exploit.keeper.extension.http.hasPermission
import org.exploit.keeper.model.request.Decrypt
import org.exploit.keeper.model.request.Encrypt
import org.exploit.keeper.service.audit.AuditContextService
import org.exploit.keeper.service.ecies.ThresholdECIESManager
import org.exploit.keeper.util.validation.InputValidator

@Singleton
class ECIESController(
    private val support: ControllerSupport,
    private val auditCtx: AuditContextService,
    private val manager: ThresholdECIESManager
) : ExternalController {
    override fun register(sb: ServerBuilder) = with(support) {
        sb.publicPost("/v1/keeper/ecies/encrypt", Encrypt::class.java) { ctx, body ->
            if (!ctx.hasPermission(Permission.keyEncrypt(body.keyId)))
                throw TKeeperException(ErrorType.ACCESS_DENIED)

            ctx.auditId()?.let { rid ->
                auditCtx.updateIfPresent(rid) { it.crypto = body.crypto() }
            }

            val normalizedKeyId = body.keyId.trim().lowercase()

            if (!InputValidator.isValidKeyId(normalizedKeyId))
                throw TKeeperException(ErrorType.INVALID_KEY_ID, normalizedKeyId)

            manager.encrypt(
                keyId = normalizedKeyId,
                cipherType = body.algorithm,
                plaintext = body.plaintext64.decodeBase64()
            )
        }

        sb.publicPost("/v1/keeper/ecies/decrypt", Decrypt::class.java) { ctx, body ->
            if (!ctx.hasPermission(Permission.keyDecrypt(body.keyId)))
                throw TKeeperException(ErrorType.ACCESS_DENIED)

            ctx.auditId()?.let { rid ->
                auditCtx.updateIfPresent(rid) { it.crypto = body.crypto() }
            }

            manager.decrypt(
                keyId = body.keyId,
                cipherType = body.algorithm,
                ciphertext = body.ciphertext64.decodeBase64(),
                generation = body.generation
            )
        }
    }
}