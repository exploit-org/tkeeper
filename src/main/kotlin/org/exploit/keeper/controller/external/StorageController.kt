package org.exploit.keeper.controller.external

import com.linecorp.armeria.server.ServerBuilder
import jakarta.inject.Singleton
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.permission.Permission
import org.exploit.keeper.controller.support.ControllerSupport
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.http.auditId
import org.exploit.keeper.extension.http.hasPermission
import org.exploit.keeper.extension.http.toQueryMap
import org.exploit.keeper.model.audit.ctx.Crypto
import org.exploit.keeper.model.request.Store
import org.exploit.keeper.service.audit.AuditContextService
import org.exploit.keeper.service.core.KeeperStorageService

@Singleton
class StorageController(
    private val support: ControllerSupport,
    private val auditCtx: AuditContextService,
    private val storage: KeeperStorageService
) : ExternalController {
    override fun register(sb: ServerBuilder): Unit = with(support) {
        sb.publicPost("/v1/keeper/storage/store", Store::class.java) { ctx, body ->
            if (!ctx.hasPermission(Permission.storageWrite()))
                throw TKeeperException(ErrorType.ACCESS_DENIED)

            storage.store(body)
            finishOkJson(ctx)
        }

        sb.delete("/v1/keeper/storage/delete") { ctx ->
            val keyId = ctx.query()?.toQueryMap()?.get("keyId")
                ?: return@delete finishErrorJson(ctx, ErrorType.INVALID_REQUEST_BODY, "keyId is required")

            if (!ctx.hasPermission(Permission.storageDelete()))
                return@delete finishErrorJson(ctx, ErrorType.ACCESS_DENIED)

            ctx.auditId()?.let { rid ->
                auditCtx.updateIfPresent(rid) {
                    it.crypto = Crypto(kid = keyId)
                }
            }

            storage.delete(keyId)
            finishNoContent(ctx)
        }
    }
}