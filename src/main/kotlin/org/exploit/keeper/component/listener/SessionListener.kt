package org.exploit.keeper.component.listener

import io.quarkus.runtime.Startup
import jakarta.annotation.PostConstruct
import jakarta.inject.Singleton
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.model.event.SessionFailedEvent
import org.exploit.keeper.service.client.BitKeeperClients
import org.exploit.keeper.service.signature.frost.FrostSessionFactory
import org.exploit.keeper.service.signature.gg20.GG20SessionFactory
import org.exploit.signalix.annotations.EventHandler
import org.exploit.signalix.manager.EventScope
import org.exploit.signalix.marker.Listener
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.core.scheduler.Schedulers

@Startup
@Singleton
class SessionListener(
    private val eventScope: EventScope,
    private val clients: BitKeeperClients,
    private val frost: FrostSessionFactory,
    private val gg20: GG20SessionFactory
): Listener {
    @EventHandler
    fun onSessionCompleted(event: SessionCleanEvent) {
        clear(event.sessionId, event.type)
    }

    @EventHandler
    fun onError(event: SessionFailedEvent) {
        val participants = collectParticipants(event.sessionId, event.type)
        clear(event.sessionId, event.type)

        Flux.fromIterable(clients.forBroadcast(participants))
            .flatMap {
                when (event.type) {
                    SessionType.GG20 -> it.gg20.abort(event.sessionId).toMono()
                    SessionType.FROST -> it.frost.abort(event.sessionId).toMono()
                }
            }
            .onErrorResume { Mono.empty() }
            .subscribeOn(Schedulers.boundedElastic())
            .subscribe()
    }

    private fun collectParticipants(sessionId: String, type: SessionType): List<Int> =
        when (type) {
            SessionType.GG20 -> gg20.session(sessionId).client.context().crypto().participants()
            SessionType.FROST -> frost.session(sessionId).client.context().crypto().participants()
        }

    private fun clear(sessionId: String, type: SessionType) {
        when (type) {
            SessionType.GG20 -> gg20.clear(sessionId)
            SessionType.FROST -> frost.clear(sessionId)
        }
    }

    @PostConstruct
    private fun register() {
        eventScope.registerListener(this)
    }
}