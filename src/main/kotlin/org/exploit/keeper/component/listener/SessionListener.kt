package org.exploit.keeper.component.listener

import io.quarkus.runtime.Startup
import jakarta.annotation.PostConstruct
import jakarta.inject.Singleton
import org.exploit.keeper.constant.SessionType
import org.exploit.keeper.extension.successOrThrow
import org.exploit.keeper.extension.toMono
import org.exploit.keeper.model.event.SessionCleanEvent
import org.exploit.keeper.model.event.SessionFailedEvent
import org.exploit.keeper.service.client.TKeeperClients
import org.exploit.keeper.service.signature.frost.FrostSessionManager
import org.exploit.keeper.service.signature.gg20.GG20SessionManager
import org.exploit.keeper.service.signature.instance.SessionManagerResolver
import org.exploit.signalix.annotations.EventHandler
import org.exploit.signalix.manager.EventScope
import org.exploit.signalix.marker.Listener
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono
import reactor.core.scheduler.Schedulers

@Startup
@Singleton
class SessionListener(
    private val eventScope: EventScope,
    private val clients: TKeeperClients,
    private val resolver: SessionManagerResolver
): Listener {
    @EventHandler
    fun onSessionCompleted(event: SessionCleanEvent) {
        clear(event.sessionId, event.type)
    }

    @EventHandler
    fun onError(event: SessionFailedEvent) {
        val participants = collectParticipants(event.sessionId, event.type)
        clear(event.sessionId, event.type)

        Flux.fromIterable(clients.forBroadcast(participants))
            .flatMap {
                when (event.type) {
                    SessionType.GG20 -> it.gg20.abort(event.sessionId).toMono()
                        .flatMap { r -> r.successOrThrow() }

                    SessionType.FROST -> it.frost.abort(event.sessionId).toMono()
                        .flatMap { r -> r.successOrThrow() }
                }
            }
            .onErrorResume { Mono.empty() }
            .subscribeOn(Schedulers.boundedElastic())
            .subscribe()
    }

    private fun collectParticipants(sessionId: String, type: SessionType): List<Int> {
        val session = resolver.findBySessionId(type, sessionId)
            ?: return emptyList()

        return when (session) {
            is GG20SessionManager<*> -> session.session(sessionId).client.context().crypto().participants()
            is FrostSessionManager<*> -> session.session(sessionId).client.context().crypto().participants()
            else -> throw IllegalArgumentException("Unknown session type: $type")
        }
    }

    private fun clear(sessionId: String, type: SessionType) {
        resolver.findBySessionId(type, sessionId)
            ?.destroy(sessionId)
    }

    @PostConstruct
    private fun register() {
        eventScope.registerListener(this)
    }
}