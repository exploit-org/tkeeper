package org.exploit.keeper.filter

import jakarta.annotation.Priority
import jakarta.ws.rs.Priorities
import jakarta.ws.rs.container.ContainerRequestContext
import jakarta.ws.rs.container.ContainerRequestFilter
import jakarta.ws.rs.core.Response
import jakarta.ws.rs.ext.Provider
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.filter.matcher.AntPathMatcher
import org.exploit.keeper.model.ErrorMessage
import org.exploit.keeper.service.auth.NoOpMachineAuthenticator
import org.exploit.keeper.service.auth.RequestAuthenticator

@Provider
@Priority(Priorities.AUTHENTICATION)
class MachineAuthFilter(
    private val config: KeeperConfig,
    private val authenticator: RequestAuthenticator
): ContainerRequestFilter {
    private val publicPaths = listOf(
        "/v1/keeper/system/health",
        "/v1/keeper/system/ready",
        "/v1/keeper/ping",
        "/v1/keeper/peerId"
    )

    private val matcher = AntPathMatcher.of("/v1/keeper/**")

    override fun filter(ctx: ContainerRequestContext) {
        val path = ctx.uriInfo.requestUri.getPath()

        if (path in publicPaths)
            return

        if (!matcher.matches(path))
            return

        if (authenticator is NoOpMachineAuthenticator) {
            if (!config.auth().allowAnonymous())
                ctx.abortWith(
                    Response.status(Response.Status.UNAUTHORIZED)
                        .entity(ErrorMessage(ERROR_MESSAGE))
                        .build()
                )

            return
        }

        val token: String? = ctx.getHeaderString(HEADER)

        if (token.isNullOrBlank()) {
            ctx.abortWith(Response.status(Response.Status.UNAUTHORIZED).build())
            return
        }

        ctx.setProperty(AUTH_PROPERTY, authenticator.authenticate(token))
    }

    companion object {
        private const val HEADER = "X-AUTH-TOKEN"
        private const val ERROR_MESSAGE = "Anonymous access is not allowed"

        const val AUTH_PROPERTY: String = "systemTokenData"
    }
}