package org.exploit.keeper.filter

import jakarta.annotation.Priority
import jakarta.ws.rs.NotAuthorizedException
import jakarta.ws.rs.Priorities
import jakarta.ws.rs.container.ContainerRequestContext
import jakarta.ws.rs.container.ContainerRequestFilter
import jakarta.ws.rs.ext.Provider
import org.exploit.keeper.api.auth.KeeperAuthenticator
import org.exploit.keeper.filter.matcher.AntPathMatcher
import org.exploit.keeper.service.client.TKeeperClients

@Provider
@Priority(Priorities.AUTHENTICATION)
class KeeperAuthFilter(private val clients: TKeeperClients) : ContainerRequestFilter {
    private val ignoreMatchers = listOf(
        AntPathMatcher.of("/v1/keeper/**"),
        AntPathMatcher.of("/v1/integrity/**")
    )

    override fun filter(p0: ContainerRequestContext) {
        val path = p0.uriInfo.path

        if (ignoreMatchers.any { it.matches(path) }) {
            return
        }

        val instanceId = p0.getHeaderString(KeeperAuthenticator.HEADER_INSTANCE_ID)
            ?.toIntOrNull()
            ?: throw NotAuthorizedException("Invalid instance id")

        val signature = p0.getHeaderString(KeeperAuthenticator.HEADER_SIGNATURE)
            ?: throw NotAuthorizedException("Missing signature")

        val timestamp = p0.getHeaderString(KeeperAuthenticator.HEADER_TIMESTAMP)
            ?.toLongOrNull()
            ?: throw NotAuthorizedException("Missing timestamp")

        try {
            val client = clients.find(instanceId)

            if (!client.verifySignature(signature, path, timestamp)) {
                throw NotAuthorizedException("Signature verification failed")
            }
        } catch (e: Exception) {
            throw NotAuthorizedException("Signature verification failed")
        }
    }
}