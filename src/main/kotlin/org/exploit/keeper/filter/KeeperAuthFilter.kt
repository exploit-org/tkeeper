package org.exploit.keeper.filter

import jakarta.annotation.Priority
import jakarta.ws.rs.NotAuthorizedException
import jakarta.ws.rs.Priorities
import jakarta.ws.rs.container.ContainerRequestContext
import jakarta.ws.rs.container.ContainerRequestFilter
import jakarta.ws.rs.ext.Provider
import org.exploit.keeper.api.auth.KeeperAuthenticator
import org.exploit.keeper.service.client.BitKeeperClients

@Provider
@Priority(Priorities.AUTHENTICATION)
class KeeperAuthFilter(
    private val clients: BitKeeperClients
) : ContainerRequestFilter {

    override fun filter(p0: ContainerRequestContext) {
        val path = p0.uriInfo.path

        if (path.startsWith("/v1/keeper"))
            return

        val instanceId = p0.getHeaderString(KeeperAuthenticator.HEADER_INSTANCE_ID)
            .toIntOrNull() ?: throw NotAuthorizedException("Invalid instance id")

        val signature = p0.getHeaderString(KeeperAuthenticator.HEADER_SIGNATURE)
            ?: throw NotAuthorizedException("Missing signature")

        val timestamp = p0.getHeaderString(KeeperAuthenticator.HEADER_TIMESTAMP).toLongOrNull()
            ?: throw NotAuthorizedException("Missing timestamp")

        try {
            val client = clients.find(instanceId)

            if (!client.verifySignature(signature, path, timestamp))
                throw NotAuthorizedException("Signature verification failed")
        } catch (e: Exception) {
            throw NotAuthorizedException("Signature verification failed")
        }
    }
}