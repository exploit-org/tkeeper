package org.exploit.keeper

import com.fasterxml.jackson.databind.ObjectMapper
import com.linecorp.armeria.common.HttpResponse
import com.linecorp.armeria.common.HttpStatus
import com.linecorp.armeria.common.logging.LogLevel
import com.linecorp.armeria.common.logging.LogWriter
import com.linecorp.armeria.common.util.Sampler
import com.linecorp.armeria.server.DecoratingHttpServiceFunction
import com.linecorp.armeria.server.Route
import com.linecorp.armeria.server.Server
import com.linecorp.armeria.server.ServerBuilder
import com.linecorp.armeria.server.logging.LoggingService
import jakarta.inject.Singleton
import org.exploit.keeper.config.dev.DevConfig
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.config.keeper.KeeperServerConfig
import org.exploit.keeper.controller.KeeperController
import org.exploit.keeper.controller.external.ExternalController
import org.exploit.keeper.controller.internal.InternalController
import org.exploit.keeper.controller.support.ControllerSupport
import org.exploit.keeper.extension.messagePackMapper
import org.exploit.keeper.extension.objectMapper
import org.exploit.keeper.service.audit.AuditContextService
import org.exploit.keeper.service.audit.AuditService
import org.exploit.keeper.service.audit.decorator.AuditStartDecorator
import org.exploit.keeper.service.auth.decorator.ExternalAuthDecorator
import org.exploit.keeper.service.auth.internal.InternalAuthenticator
import org.exploit.keeper.service.core.KeeperInitService
import org.exploit.keeper.service.dev.EnsureLoopbackAddress
import org.exploit.keeper.service.exception.KeeperExceptionHandler
import org.slf4j.LoggerFactory
import java.io.File
import java.io.FileInputStream
import java.net.InetSocketAddress
import java.security.KeyStore
import java.util.*
import java.util.concurrent.CompletableFuture
import javax.net.ssl.KeyManagerFactory

@Singleton
class ServerLauncher(
    private val support: ControllerSupport,
    private val audit: AuditService,
    private val devConfig: Optional<DevConfig>,
    private val keeper: KeeperInitService,
    private val keeperConfig: KeeperConfig,
    private val auditCtx: AuditContextService,
    private val internalAuth: InternalAuthenticator,
    private val externalAuth: ExternalAuthDecorator,
    private val externalControllers: List<ExternalController>,
    private val internalControllers: List<InternalController>
) {
    private val log = LoggerFactory.getLogger(ServerLauncher::class.java)

    @Volatile
    private var publicServer: Server? = null

    @Volatile
    private var internalServer: Server? = null

    fun start() {
        val start = System.currentTimeMillis()

        val pub = buildServer(
            cfg = keeperConfig.servers.public,
            mapper = objectMapper,
            authDecorator = externalAuth,
            controllers = externalControllers
        )

        val inl = buildServer(
            cfg = keeperConfig.servers.internal,
            mapper = messagePackMapper,
            authDecorator = internalAuth,
            controllers = internalControllers
        )

        publicServer = pub
        internalServer = inl

        CompletableFuture.allOf(pub.start(), inl.start()).join()

        log.info("Public server on port {}", pub.activeLocalPort())
        log.info("Internal server on port {}", inl.activeLocalPort())

        log.info("Servers started in {} ms", System.currentTimeMillis() - start)
    }

    fun stop() {
        try { publicServer?.stop()?.join() } catch (_: Exception) {}
        try { internalServer?.stop()?.join() } catch (_: Exception) {}
    }

    fun blockUntilShutdown() {
        publicServer?.whenClosed()?.join()
        internalServer?.whenClosed()?.join()
    }

    private fun buildServer(
        cfg: KeeperServerConfig,
        mapper: ObjectMapper,
        authDecorator: DecoratingHttpServiceFunction,
        controllers: List<KeeperController>
    ): Server {
        val sb = Server.builder()
        applyNetwork(sb, cfg)
        applyCommon(sb, cfg)

        val logWriter = LogWriter.builder()
            .logger("tk.server")
            .successfulResponseLogLevel(LogLevel.OFF)
            .failureResponseLogLevel(LogLevel.WARN)
            .build()

        val exceptionHandler = KeeperExceptionHandler(support, mapper)

        sb.errorHandler(exceptionHandler)
        sb.decorator(authDecorator)
        applyDevModeIfPresent(sb)
        sb.decorator(AuditStartDecorator(support, mapper, audit, keeper, keeperConfig, auditCtx))
        sb.decorator(exceptionHandler)

        sb.decorator(
            LoggingService.builder()
                .logWriter(logWriter)
                .successSampler(Sampler.always())
                .failureSampler(Sampler.always())
                .newDecorator()
        )

        controllers.forEach { it.register(sb) }

        sb.service(Route.ofCatchAll()) { _, _ ->
            HttpResponse.of(HttpStatus.NOT_FOUND)
        }

        return sb.build()
    }

    private fun applyDevModeIfPresent(sb: ServerBuilder) {
        val devMode = System.getProperty("keeper.dev.enabled")
            ?.toBoolean()
            ?: false

        if (!devMode) return

        devConfig.ifPresentOrElse({ _ -> sb.decorator(EnsureLoopbackAddress) }) {
            error("Dev mode is enabled, but config not provided. Specify -Dkeeper.dev.config.location flag.")
        }

        log.warn("Server is configured in dev mode. Only loopback access is allowed.")
    }

    private fun applyCommon(sb: ServerBuilder, cfg: KeeperServerConfig) {
        sb.maxRequestLength(cfg.maxRequestLength)
        sb.idleTimeout(cfg.idleTimeout)
    }

    private fun applyNetwork(sb: ServerBuilder, cfg: KeeperServerConfig) {
        val tls = cfg.tls
        if (tls?.enabled == true) {
            sb.https(InetSocketAddress(cfg.host, cfg.port))

            val hasPem = !tls.certificateChainPath.isNullOrBlank() && !tls.privateKeyPath.isNullOrBlank()
            val hasKs = !tls.keyStorePath.isNullOrBlank()

            when {
                hasPem -> applyPemTLS(sb, tls)
                hasKs -> applyKsTLS(sb, tls)

                else -> error("TLS enabled, but neither PEM nor keystore provided")
            }
        } else {
            sb.http(InetSocketAddress(cfg.host, cfg.port))
        }
    }

    private fun applyPemTLS(sb: ServerBuilder, tls: KeeperServerConfig.Tls) {
        val certFile = File(requireNotNull(tls.certificateChainPath))
        val keyFile = File(requireNotNull(tls.privateKeyPath))

        sb.tls(certFile, keyFile, tls.privateKeyPassword)
    }

    private fun applyKsTLS(sb: ServerBuilder, tls: KeeperServerConfig.Tls) {
        val ksPath = requireNotNull(tls.keyStorePath)
        val pwd = (tls.keyStorePassword ?: "").toCharArray()

        val ksType = tls.keyStoreType
            ?: when {
                ksPath.endsWith(".p12", ignoreCase = true) || ksPath.endsWith(".pfx", ignoreCase = true) -> "PKCS12"
                else -> "JKS"
            }

        val ks = KeyStore.getInstance(ksType)
        FileInputStream(ksPath).use { ks.load(it, pwd) }

        val kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
        kmf.init(ks, pwd)

        sb.tls(kmf)
    }
}