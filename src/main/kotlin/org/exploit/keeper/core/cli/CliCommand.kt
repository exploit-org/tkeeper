package org.exploit.keeper.core.cli

import io.quarkus.arc.Unremovable
import org.exploit.keeper.core.shell.DeleteCommand
import org.exploit.keeper.core.shell.ShellCommand
import org.exploit.keeper.core.shell.StoreCommand
import org.exploit.keeper.db.LMKDB
import org.jline.reader.LineReaderBuilder
import org.jline.reader.UserInterruptException
import org.jline.reader.impl.history.DefaultHistory
import org.jline.terminal.TerminalBuilder
import picocli.CommandLine.Command
import java.util.concurrent.Callable

@Unremovable
@Command(name = "cli", description = ["Interactive shell for key management"])
class CliCommand(private val db: LMKDB) : Callable<Int> {
    private val handlers: Map<String, ShellCommand> = listOf(
        StoreCommand(),
        DeleteCommand()
    ).associateBy { it.name }

    override fun call(): Int {
        try {
            val terminal = TerminalBuilder.builder().system(true).build()
            val reader = LineReaderBuilder.builder()
                .terminal(terminal)
                .history(DefaultHistory())
                .build()

            val prompt = "\u001B[35mbitkeeper>\u001B[0m "

            while (true) {
                val line = reader.readLine(prompt) ?: break
                val trimmed = line.trim()
                if (trimmed.isEmpty()) continue

                if (trimmed.equals("exit", true) || trimmed.equals("quit", true))
                    break

                val tokens = trimmed.split(" ")
                val cmd = handlers[tokens[0]]
                try {
                    if (cmd != null) {
                        cmd.execute(tokens, db)
                    } else {
                        println("Unknown command '${tokens[0]}'. Available: ${handlers.keys}")
                    }
                } catch (e: IllegalArgumentException) {
                    println("Usage: ${cmd?.usage() ?: "n/a"}")
                } catch (e: Exception) {
                    println("Error: ${e.message ?: e.javaClass.simpleName}")
                }
            }

            return 0
        } catch (e: UserInterruptException) {
            println("Exiting...")
            return 1
        }
    }
}