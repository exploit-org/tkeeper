package org.exploit.keeper.db

import org.exploit.keeper.extension.crypto.toBase64
import org.exploit.keeper.model.Page
import org.exploit.keeper.model.keyset.KeySetMeta
import org.rocksdb.Transaction
import java.nio.charset.StandardCharsets

class OwnerIndexStore(private val ops: KeyStoreOps) {
    fun syncHead(tx: Transaction, meta: KeySetMeta) {
        sync(tx, meta.logicalId, meta.assetOwner, meta.destroyed)
    }

    fun sync(logicalId: String, assetOwner: String?, destroyed: Boolean) =
        ops.runInTransaction { tx -> sync(tx, logicalId, assetOwner, destroyed) }

    fun sync(tx: Transaction, logicalId: String, assetOwner: String?, destroyed: Boolean) {
        val newOwner = assetOwner?.trim()?.takeIf { it.isNotEmpty() && !destroyed }

        val revK = revKey(logicalId)
        val oldOwnerEnc = ops.getRaw(tx, revK)?.toString(StandardCharsets.UTF_8)
        val newOwnerEnc = newOwner?.let { encodeOwner(it) }

        if (oldOwnerEnc != null && (newOwnerEnc == null || newOwnerEnc != oldOwnerEnc)) {
            ops.delete(tx, idxKey(oldOwnerEnc, logicalId))
            ops.delete(tx, revK)
        }

        if (newOwnerEnc != null && newOwnerEnc != oldOwnerEnc) {
            ops.saveRaw(tx, idxKey(newOwnerEnc, logicalId), byteArrayOf(1))
            ops.saveRaw(tx, revK, newOwnerEnc.toByteArray(StandardCharsets.UTF_8))
        }
    }

    fun clear(logicalId: String) =
        ops.runInTransaction { tx -> clear(tx, logicalId) }

    fun clear(tx: Transaction, logicalId: String) {
        val revK = revKey(logicalId)
        val oldOwnerEnc = ops.getRaw(tx, revK)?.toString(StandardCharsets.UTF_8) ?: return

        ops.delete(tx, idxKey(oldOwnerEnc, logicalId))
        ops.delete(tx, revK)
    }

    fun listByOwner(owner: String, limit: Int = 200, cursor: String? = null): Page<String, String> {
        val safeLimit = limit.coerceIn(1, 2000)
        val ownerEnc = encodeOwner(owner.trim())

        val prefixStr = "$P_IDX$ownerEnc:"
        val prefix = prefixStr.toByteArray(StandardCharsets.UTF_8)

        val startKey = (cursor ?: prefixStr).toByteArray(StandardCharsets.UTF_8)

        val out = ArrayList<String>(minOf(safeLimit, 256))
        var lastKey: String? = null

        ops.newIterator().use { it ->
            it.seek(startKey)

            if (cursor != null && it.isValid) {
                val k0 = String(it.key(), StandardCharsets.UTF_8)
                if (k0 == cursor) it.next()
            }

            while (it.isValid && out.size < safeLimit) {
                val kBytes = it.key()
                if (!startsWith(kBytes, prefix)) break

                val kStr = String(kBytes, StandardCharsets.UTF_8)
                val logicalId = kStr.substring(prefixStr.length)
                if (logicalId.isNotEmpty()) {
                    out += logicalId
                    lastKey = kStr
                }

                it.next()
            }
        }

        val next = if (out.size >= safeLimit) lastKey else null
        return Page(out, next)
    }

    private fun encodeOwner(owner: String): String {
        val bytes = owner.toByteArray(StandardCharsets.UTF_8)
        return bytes.toBase64()
    }

    private fun startsWith(bytes: ByteArray, prefix: ByteArray): Boolean {
        if (bytes.size < prefix.size) return false
        for (i in prefix.indices) if (bytes[i] != prefix[i]) return false
        return true
    }

    companion object {
        private const val P_IDX = "o:idx:"
        private const val P_REV = "o:rev:"

        private fun idxKey(ownerEnc: String, logicalId: String): String = "$P_IDX$ownerEnc:$logicalId"
        private fun revKey(logicalId: String): String = "$P_REV$logicalId"
    }
}