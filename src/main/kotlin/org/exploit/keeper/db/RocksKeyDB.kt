package org.exploit.keeper.db

import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.crypto.key.ECPublicKey
import org.exploit.crypto.key.ed25519.Ed25519KeyPair
import org.exploit.crypto.key.ed25519.Ed25519PrivateKey
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.ed25519.Ed25519
import org.exploit.ed25519.Ed25519PointOps
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.request.KeeperInitData
import org.exploit.keeper.service.key.KeyOps
import org.exploit.keeper.util.KeySerializer
import org.rocksdb.*
import java.io.Closeable
import java.nio.charset.StandardCharsets

class RocksKeyDB(dbPath: String, private var opsProvider: () -> KeyOps) : Closeable {
    private val db: TransactionDB
    private val cfHandles: List<ColumnFamilyHandle>
    private val writeOpts: WriteOptions

    val storage: KeyStore

    init {
        RocksDB.loadLibrary()

        writeOpts = WriteOptions()

        val options = DBOptions()
            .setCreateIfMissing(true)
            .setCreateMissingColumnFamilies(true)

        val txnOptions = TransactionDBOptions()

        val cfDescs = listOf(
            ColumnFamilyDescriptor(RocksDB.DEFAULT_COLUMN_FAMILY),
            ColumnFamilyDescriptor(PRIVATE_KEY_MAP.toByteArray()),
            ColumnFamilyDescriptor(PUBLIC_KEY_MAP.toByteArray())
        )

        val handles = ArrayList<ColumnFamilyHandle>()
        db = TransactionDB.open(options, txnOptions, dbPath, cfDescs, handles)

        cfHandles = handles
        val cfMap = mapOf(
            PRIVATE_KEY_MAP to cfHandles[1],
            PUBLIC_KEY_MAP to cfHandles[2]
        )
        storage = KeyStore(cfMap[PRIVATE_KEY_MAP]!!)
    }

    fun isInitialized(): Boolean = storage.hasKey(SENTINEL_KEY)

    fun writeSentinel(ops: KeyOps) = storage.saveRaw(SENTINEL_KEY, ops.encrypt(SENTINEL_VAL))

    fun writeIntegrityKey(ops: KeyOps) {
        val keyPair = Ed25519.generateKeyPair()

        try {
            storage.saveRaw(INTEGRITY_KEY, ops.encrypt(KeySerializer.serialize(
                CurveName.ED25519,
                keyPair.secretKey
            )))
        } finally {
            keyPair.secretKey.fill(0)
        }
    }

    fun writeInitData(peerId: Int, threshold: Int, total: Int) {
        storage.saveMultiRaw(mapOf(
            PEER_ID_KEY to peerId.toString().toByteArray(StandardCharsets.UTF_8),
            THRESHOLD_KEY to threshold.toString().toByteArray(StandardCharsets.UTF_8),
            TOTAL_PEERS_KEY to total.toString().toByteArray(StandardCharsets.UTF_8)
        ))
    }

    fun readInitData(): KeeperInitData {
        val peerId = storage.getRaw(PEER_ID_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Peer ID not found")
        val threshold = storage.getRaw(THRESHOLD_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Threshold not found")
        val totalPeers = storage.getRaw(TOTAL_PEERS_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Total peers not found")

        return KeeperInitData(peerId, threshold, totalPeers)
    }

    fun writeIntegrityKey() {
        writeIntegrityKey(opsProvider.invoke())
    }

    fun getIntegrityKey(): ECPublicKey<Ed25519PointOps> {
        val privateIntegrityKey = storage.get(INTEGRITY_KEY)?.toPrivateKey()
            ?: throw IllegalStateException("Integrity key not found")

        val sk = Ed25519PrivateKey(privateIntegrityKey.ski)

        return try {
            Ed25519Provider.getInstance().getPublicKey(sk) as Ed25519PublicKey
        } finally {
            sk.erase()
        }
    }

    fun getIntegrityKeyPair(): Ed25519KeyPair {
        val privateIntegrityKey = storage.get(INTEGRITY_KEY)?.toPrivateKey()
            ?: throw IllegalStateException("Integrity key not found")

        val privateKey = Ed25519PrivateKey.create(privateIntegrityKey.ski) as Ed25519PrivateKey
        val publicKey = Ed25519Provider.getInstance().getPublicKey(privateKey) as Ed25519PublicKey

        return Ed25519KeyPair(privateKey, publicKey)
    }

    fun checkValidKey(ops: KeyOps): Boolean =
        storage.getRaw(SENTINEL_KEY)?.let { ops.decrypt(it).contentEquals(SENTINEL_VAL) } ?: false

    override fun close() {
        cfHandles.forEach { it.close() }
        db.close()
    }

    open inner class KeyStore(private val cf: ColumnFamilyHandle) {
        open fun save(id: String, raw: ByteArray) {
            val enc = opsProvider().encrypt(raw)
            db.beginTransaction(writeOpts).use { tx ->
                tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), enc)
                tx.commit()
            }
        }

        open fun saveRaw(id: String, raw: ByteArray) {
            db.beginTransaction(writeOpts).use { tx ->
                tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), raw)
                tx.commit()
            }
        }

        open fun saveMulti(data: Map<String, ByteArray>) {
            db.beginTransaction(writeOpts).use { tx ->
                data.forEach { (id, raw) ->
                    if (PROTECTED_KEYS.contains(id))
                        throw TKeeperException(400, "Cannot save protected key: $id")

                    tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), opsProvider().encrypt(raw))
                }
                tx.commit()
            }
        }

        open fun saveMultiRaw(data: Map<String, ByteArray>) {
            db.beginTransaction(writeOpts).use { tx ->
                data.forEach { (id, raw) ->
                    tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), raw)
                }
                tx.commit()
            }
        }

        open fun get(id: String): ByteArray? =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8))?.let { opsProvider().decrypt(it) }

        open fun getRaw(id: String): ByteArray? =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8))

        open fun hasKey(id: String): Boolean =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8)) != null

        open fun delete(id: String) {
            db.beginTransaction(writeOpts).use { tx ->
                tx.delete(cf, id.toByteArray(StandardCharsets.UTF_8))
                tx.commit()
            }
        }
    }

    companion object {
        val SENTINEL_VAL = "BK-v1".toByteArray()

        const val INTEGRITY_KEY = "__integrity__"
        const val SENTINEL_KEY = "__meta__"
        const val PEER_ID_KEY = "__peer_id__"
        const val THRESHOLD_KEY = "__threshold__"
        const val TOTAL_PEERS_KEY = "__total_peers__"
        const val PRIVATE_KEY_MAP = "privateKey"
        const val PUBLIC_KEY_MAP = "publicKey"

        val PROTECTED_KEYS = setOf(
            INTEGRITY_KEY,
            SENTINEL_KEY,
            PEER_ID_KEY,
            THRESHOLD_KEY,
            TOTAL_PEERS_KEY
        )
    }
}