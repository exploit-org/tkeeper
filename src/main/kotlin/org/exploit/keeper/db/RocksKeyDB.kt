package org.exploit.keeper.db

import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.crypto.key.ECPublicKey
import org.exploit.crypto.key.ed25519.Ed25519KeyPair
import org.exploit.crypto.key.ed25519.Ed25519PrivateKey
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.ed25519.Ed25519
import org.exploit.ed25519.Ed25519PointOps
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.toByteArray
import org.exploit.keeper.extension.toInt
import org.exploit.keeper.extension.toPrivateKey
import org.exploit.keeper.model.request.KeeperInitData
import org.exploit.keeper.service.key.KeyOps
import org.exploit.keeper.util.KeySerializer
import org.exploit.keeper.util.crypto.Random
import org.rocksdb.*
import java.io.Closeable
import java.nio.charset.StandardCharsets

class RocksKeyDB(dbPath: String, private var opsProvider: () -> KeyOps) : Closeable {
    private val db: TransactionDB
    private val cfHandles: List<ColumnFamilyHandle>
    private val writeOpts: WriteOptions

    val storage: KeyStore

    init {
        RocksDB.loadLibrary()

        writeOpts = WriteOptions()

        val options = DBOptions()
            .setCreateIfMissing(true)
            .setCreateMissingColumnFamilies(true)

        val txnOptions = TransactionDBOptions()

        val cfDescs = listOf(
            ColumnFamilyDescriptor(RocksDB.DEFAULT_COLUMN_FAMILY),
            ColumnFamilyDescriptor(PRIVATE_KEY_MAP.toByteArray()),
            ColumnFamilyDescriptor(PUBLIC_KEY_MAP.toByteArray())
        )

        val handles = ArrayList<ColumnFamilyHandle>()
        db = TransactionDB.open(options, txnOptions, dbPath, cfDescs, handles)

        cfHandles = handles
        val cfMap = mapOf(
            PRIVATE_KEY_MAP to cfHandles[1],
            PUBLIC_KEY_MAP to cfHandles[2]
        )
        storage = KeyStore(cfMap[PRIVATE_KEY_MAP]!!)
    }

    fun isInitialized(): Boolean = storage.hasKey(SENTINEL_KEY)

    fun writeSentinel(ops: KeyOps) = storage.saveRaw(SENTINEL_KEY, ops.encrypt(SENTINEL_VAL))

    fun writeIntegrityKey(ops: KeyOps) {
        val currentVersion = storage.getRaw(INTEGRITY_KEY_VERSION)
            ?.toInt()
            ?: 0

        val keyPair = Ed25519.generateKeyPair()

        try {
            storage.saveRaw(INTEGRITY_KEY.format(currentVersion + 1), ops.encrypt(KeySerializer.serialize(
                CurveName.ED25519,
                keyPair.secretKey
            )))

            storage.saveRaw(INTEGRITY_KEY_VERSION, (currentVersion + 1).toByteArray())
        } finally {
            keyPair.secretKey.fill(0)
        }
    }

    fun writeHmacKey(ops: KeyOps) {
        val bytes = Random.bytes(32)

        try {
            val currentVersion = storage.getRaw(HMAC_KEY_VERSION)
                ?.toInt()
                ?: 0

            val nextVersion = currentVersion + 1

            storage.saveMultiRaw(mapOf(
                HMAC_KEY.format(nextVersion) to ops.encrypt(bytes),
                HMAC_KEY_VERSION to nextVersion.toByteArray()
            ))
        } finally {
            bytes.fill(0)
        }
    }

    fun writeInitData(peerId: Int, threshold: Int, total: Int) {
        storage.saveMultiRaw(mapOf(
            PEER_ID_KEY to peerId.toString().toByteArray(StandardCharsets.UTF_8),
            THRESHOLD_KEY to threshold.toString().toByteArray(StandardCharsets.UTF_8),
            TOTAL_PEERS_KEY to total.toString().toByteArray(StandardCharsets.UTF_8)
        ))
    }

    fun readInitData(): KeeperInitData {
        val peerId = storage.getRaw(PEER_ID_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Peer ID not found")
        val threshold = storage.getRaw(THRESHOLD_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Threshold not found")
        val totalPeers = storage.getRaw(TOTAL_PEERS_KEY)?.toString(StandardCharsets.UTF_8)?.toInt()
            ?: throw IllegalStateException("Total peers not found")

        return KeeperInitData(peerId, threshold, totalPeers)
    }

    fun writeIntegrityKey() {
        writeIntegrityKey(opsProvider.invoke())
    }

    fun readIntegrityPublicKey(version: Int? = null): ECPublicKey<Ed25519PointOps> {
        val currentVersion = version ?: storage.getRaw(INTEGRITY_KEY_VERSION)
            ?.toInt()
            ?: throw IllegalStateException("Integrity key version not found")

        val privateIntegrityKey = storage.get(INTEGRITY_KEY.format(currentVersion))?.toPrivateKey()
            ?: throw TKeeperException(ErrorType.INTEGRITY_KEY_NOT_FOUND)

        val sk = Ed25519PrivateKey(privateIntegrityKey.ski)

        return try {
            Ed25519Provider.getInstance().getPublicKey(sk) as Ed25519PublicKey
        } finally {
            sk.erase()
        }
    }

    fun readIntegrityKeyVersion(): Int =
        storage.getRaw(INTEGRITY_KEY_VERSION)
            ?.toInt()
            ?: throw TKeeperException(ErrorType.HMAC_KEY_NOT_FOUND)

    fun readHmacKeyVersion(): Int =
        storage.getRaw(HMAC_KEY_VERSION)
            ?.toInt()
            ?: throw TKeeperException(ErrorType.HMAC_KEY_NOT_FOUND)

    fun readIntegrityKeyPair(version: Int? = null): Ed25519KeyPair {
        val currentVersion = version ?: storage.getRaw(INTEGRITY_KEY_VERSION)
            ?.toInt()
            ?: throw TKeeperException(ErrorType.INTEGRITY_KEY_NOT_FOUND)

        val privateIntegrityKey = storage.get(INTEGRITY_KEY.format(currentVersion))?.toPrivateKey()
            ?: throw TKeeperException(ErrorType.INTEGRITY_KEY_NOT_FOUND)

        val privateKey = Ed25519PrivateKey.create(privateIntegrityKey.ski) as Ed25519PrivateKey
        val publicKey = Ed25519Provider.getInstance().getPublicKey(privateKey) as Ed25519PublicKey

        return Ed25519KeyPair(privateKey, publicKey)
    }

    fun readHmacKey(version: Int? = null): ByteArray {
        val currentVersion = version ?: storage.getRaw(HMAC_KEY_VERSION)
            ?.toInt()
            ?: throw IllegalStateException("HMAC key version not found")

        return storage.get(HMAC_KEY.format(currentVersion))
            ?: throw IllegalStateException("HMAC key not found")
    }

    fun checkValidKey(ops: KeyOps): Boolean =
        storage.getRaw(SENTINEL_KEY)?.let { ops.decrypt(it).contentEquals(SENTINEL_VAL) } ?: false

    override fun close() {
        cfHandles.forEach { it.close() }
        db.close()
    }

    open inner class KeyStore(private val cf: ColumnFamilyHandle) {
        open fun save(id: String, raw: ByteArray) {
            val enc = opsProvider().encrypt(raw)
            db.beginTransaction(writeOpts).use { tx ->
                tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), enc)
                tx.commit()
            }
        }

        open fun saveRaw(id: String, raw: ByteArray) {
            db.beginTransaction(writeOpts).use { tx ->
                tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), raw)
                tx.commit()
            }
        }

        open fun saveMulti(data: Map<String, ByteArray>) {
            db.beginTransaction(writeOpts).use { tx ->
                data.forEach { (id, raw) ->
                    if (PROTECTED_KEYS.contains(id))
                        throw TKeeperException(ErrorType.PROTECTED_KEY, id)

                    tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), opsProvider().encrypt(raw))
                }
                tx.commit()
            }
        }

        open fun saveMultiRaw(data: Map<String, ByteArray>) {
            db.beginTransaction(writeOpts).use { tx ->
                data.forEach { (id, raw) ->
                    tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), raw)
                }
                tx.commit()
            }
        }

        open fun get(id: String): ByteArray? =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8))?.let { opsProvider().decrypt(it) }

        open fun getRaw(id: String): ByteArray? =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8))

        open fun hasKey(id: String): Boolean =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8)) != null

        open fun delete(id: String) {
            db.beginTransaction(writeOpts).use { tx ->
                tx.delete(cf, id.toByteArray(StandardCharsets.UTF_8))
                tx.commit()
            }
        }
    }

    companion object {
        val SENTINEL_VAL = "BK-v1".toByteArray()

        const val HMAC_KEY = "__hmac_key__%s"
        const val HMAC_KEY_VERSION = "__hmac_key_version__"

        const val INTEGRITY_KEY_VERSION = "__integrity_key_version__"
        const val INTEGRITY_KEY = "__integrity__%s"
        const val SENTINEL_KEY = "__meta__"
        const val PEER_ID_KEY = "__peer_id__"
        const val THRESHOLD_KEY = "__threshold__"
        const val TOTAL_PEERS_KEY = "__total_peers__"
        const val PRIVATE_KEY_MAP = "privateKey"
        const val PUBLIC_KEY_MAP = "publicKey"

        val PROTECTED_KEYS = setOf(
            INTEGRITY_KEY,
            SENTINEL_KEY,
            PEER_ID_KEY,
            THRESHOLD_KEY,
            TOTAL_PEERS_KEY
        )
    }
}