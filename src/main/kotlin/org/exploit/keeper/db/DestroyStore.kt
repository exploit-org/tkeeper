package org.exploit.keeper.db

import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.constant.destroy.DestroySessionState
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.extension.objectMapper
import org.exploit.keeper.model.destroy.KeyDestroyIntent
import org.exploit.keeper.model.destroy.KeyDestroySession
import org.rocksdb.Transaction
import java.nio.charset.StandardCharsets
import java.time.Instant

class DestroyStore(val ops: KeyStoreOps) {
    fun isCommitted(logicalId: String, gen: Int): Boolean =
        ops.runInTransaction { tx -> isCommitted(tx, logicalId, gen) }

    fun isCommitted(tx: Transaction, logicalId: String, gen: Int): Boolean {
        return ops.getSigned(tx, DESTROY_COMMITTED.format(logicalId, gen)) != null
    }

    fun markCommitted(logicalId: String, gen: Int, sessionId: String) =
        ops.runInTransaction { tx -> markCommitted(tx, logicalId, gen, sessionId) }

    fun markCommitted(tx: Transaction, logicalId: String, gen: Int, sessionId: String) {
        ops.saveSigned(
            tx,
            DESTROY_COMMITTED.format(logicalId, gen),
            sessionId.toByteArray(StandardCharsets.UTF_8)
        )
    }

    fun saveSession(session: KeyDestroySession) =
        ops.runInTransaction { tx -> saveSession(tx, session) }

    fun saveSession(tx: Transaction, session: KeyDestroySession) {
        val bytes = objectMapper.writeValueAsBytes(session)

        ops.saveSigned(tx, DESTROY_SESSION.format(session.sessionId), bytes)

        val activeKey = DESTROY_ACTIVE.format(session.intent.logicalId, session.intent.generation)

        if (session.state.isRunning()) {
            ops.saveSigned(tx, activeKey, session.sessionId.toByteArray(StandardCharsets.UTF_8))
        } else {
            ops.delete(tx, activeKey)
        }

        if (session.state == DestroySessionState.COMMITTED) {
            markCommitted(tx, session.intent.logicalId, session.intent.generation, session.sessionId)
        }
    }

    fun loadSession(sessionId: String): KeyDestroySession? =
        ops.runInTransaction { tx -> loadSession(tx, sessionId) }

    fun loadSession(tx: Transaction, sessionId: String): KeyDestroySession? {
        val raw = ops.getSigned(tx, DESTROY_SESSION.format(sessionId)) ?: return null
        return objectMapper.readValue(raw, KeyDestroySession::class.java)
    }

    fun findActiveSessionId(logicalId: String, gen: Int): String? =
        ops.runInTransaction { tx -> findActiveSessionId(tx, logicalId, gen) }

    fun findActiveSessionId(tx: Transaction, logicalId: String, gen: Int): String? {
        val raw = ops.getSigned(tx, DESTROY_ACTIVE.format(logicalId, gen)) ?: return null
        return String(raw, StandardCharsets.UTF_8)
    }

    fun expireIfNeeded(sessionId: String): KeyDestroySession? =
        ops.runInTransaction { tx -> expireIfNeeded(tx, sessionId) }

    fun expireIfNeeded(tx: Transaction, sessionId: String): KeyDestroySession? {
        val s = loadSession(tx, sessionId) ?: return null
        val now = Instant.now().epochSecond

        if (now >= s.intent.expiresAt && s.state.isRunning()) {
            val expired = s.copy(state = DestroySessionState.EXPIRED, updatedAt = now)
            saveSession(tx, expired)
            return expired
        }

        return s
    }

    fun createIfAbsentRunning(sessionId: String, intent: KeyDestroyIntent): KeyDestroySession =
        ops.runInTransaction { tx -> createIfAbsentRunning(tx, sessionId, intent) }

    fun createIfAbsentRunning(tx: Transaction, sessionId: String, intent: KeyDestroyIntent): KeyDestroySession {
        val now = Instant.now().epochSecond
        val existing = loadSession(tx, sessionId)
        if (existing != null) return expireIfNeeded(tx, sessionId) ?: existing

        val s = KeyDestroySession(
            sessionId = sessionId,
            state = DestroySessionState.RUNNING,
            intent = intent,
            updatedAt = now
        )

        saveSession(tx, s)
        return s
    }

    fun updateSession(sessionId: String, mutate: (KeyDestroySession) -> KeyDestroySession): KeyDestroySession =
        ops.runInTransaction { tx -> updateSession(tx, sessionId, mutate) }

    fun updateSession(tx: Transaction, sessionId: String, mutate: (KeyDestroySession) -> KeyDestroySession): KeyDestroySession {
        val s = expireIfNeeded(tx, sessionId)
            ?: throw TKeeperException(ErrorType.INTERNAL_ERROR, "Destroy session not found: $sessionId")

        val updated = mutate(s)
        saveSession(tx, updated)
        return updated
    }
    
    private companion object {
        const val DESTROY_SESSION = "__destroy_session__%s"
        const val DESTROY_ACTIVE = "__destroy_active__%s__version__%s"
        const val DESTROY_COMMITTED = "__destroy_committed__%s__version__%s"
    }
}