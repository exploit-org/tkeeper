package org.exploit.keeper.db

import org.mapdb.DB
import org.mapdb.DBMaker
import org.mapdb.HTreeMap
import org.mapdb.Serializer
import java.io.Closeable
import java.io.File
import java.nio.ByteBuffer
import java.security.SecureRandom
import javax.crypto.Cipher
import javax.crypto.SecretKey
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.PBEKeySpec
import javax.crypto.spec.SecretKeySpec

class LMKDB(dbPath: String, masterPassword: CharArray) : Closeable {
    private val db: DB = DBMaker
        .fileDB(File(dbPath))
        .fileMmapEnable()
        .transactionEnable()
        .make()

    private val encryptionService: EncryptionServiceInterface

    val private: KeyStore
    val public: KeyStore

    init {
        val salt = loadSalt()
        encryptionService = if (salt == null) {
            val newSalt = EncryptionService.nextSalt()
            saveSalt(newSalt)
            EncryptionService(masterPassword, newSalt)
        } else {
            EncryptionService(masterPassword, salt)
        }

        private = KeyStore("privateKey") { encryptionService }
        public = KeyStore("publicKey") { NoOpEncryptionService }

        private.openDb()
        public.openDb()
    }

    private fun loadSalt(): ByteArray? {
        val saltMap = db.hashMap("privateKey", Serializer.STRING, Serializer.BYTE_ARRAY)
            .createOrOpen()
        return saltMap["salt"]
    }

    private fun saveSalt(salt: ByteArray) {
        val saltMap = db.hashMap("privateKey", Serializer.STRING, Serializer.BYTE_ARRAY)
            .createOrOpen()
        saltMap["salt"] = salt
        db.commit()
    }

    override fun close() {
        db.close()
    }

    interface EncryptionServiceInterface {
        fun encrypt(data: ByteArray): ByteBuffer
        fun decrypt(data: ByteArray): ByteArray
    }

    inner class KeyStore(
        private val mapName: String,
        private val encryptionServiceProvider: () -> EncryptionServiceInterface
    ) {
        private lateinit var map: HTreeMap<String, ByteArray>

        internal fun openDb() {
            map = db.hashMap(mapName, Serializer.STRING, Serializer.BYTE_ARRAY)
                .createOrOpen()
        }

        fun save(keyId: String, raw: ByteArray) {
            val buf = encryptionServiceProvider().encrypt(raw)
            val bytes = ByteArray(buf.remaining()).also { buf.get(it) }
            map[keyId] = bytes
            db.commit()
        }

        fun delete(keyId: String) {
            map.remove(keyId)
            db.commit()
        }

        fun get(keyId: String): ByteArray? {
            val stored = map[keyId] ?: return null
            return encryptionServiceProvider().decrypt(stored)
        }
    }

    private class EncryptionService(password: CharArray, salt: ByteArray) : EncryptionServiceInterface {
        private val secretKey: SecretKey = deriveKey(password, salt)

        companion object {
            private const val GCM_IV_LENGTH = 12
            private const val GCM_TAG_LENGTH = 16
            private val RANDOM = SecureRandom()

            fun nextSalt(): ByteArray = ByteArray(16).also { RANDOM.nextBytes(it) }
        }

        private fun deriveKey(password: CharArray, salt: ByteArray): SecretKey {
            val factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
            val spec = PBEKeySpec(password, salt, 65536, 256)
            val tmp = factory.generateSecret(spec)
            return SecretKeySpec(tmp.encoded, "AES")
        }

        override fun encrypt(data: ByteArray): ByteBuffer {
            val cipher = Cipher.getInstance("AES/GCM/NoPadding")
            val iv = ByteArray(GCM_IV_LENGTH).also { RANDOM.nextBytes(it) }
            val spec = GCMParameterSpec(GCM_TAG_LENGTH * 8, iv)
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, spec)
            val ct = cipher.doFinal(data)
            return ByteBuffer.allocateDirect(iv.size + ct.size)
                .apply { put(iv).put(ct).flip() }
        }

        override fun decrypt(data: ByteArray): ByteArray {
            val iv = data.copyOfRange(0, GCM_IV_LENGTH)
            val ct = data.copyOfRange(GCM_IV_LENGTH, data.size)
            val cipher = Cipher.getInstance("AES/GCM/NoPadding")
            val spec = GCMParameterSpec(GCM_TAG_LENGTH * 8, iv)
            cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)
            return cipher.doFinal(ct)
        }
    }

    private object NoOpEncryptionService : EncryptionServiceInterface {
        override fun encrypt(data: ByteArray): ByteBuffer =
            ByteBuffer.allocateDirect(data.size).apply { put(data); flip() }

        override fun decrypt(data: ByteArray) = data
    }
}