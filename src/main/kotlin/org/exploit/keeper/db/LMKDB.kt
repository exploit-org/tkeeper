package org.exploit.keeper.db

import org.exploit.keeper.service.key.KeyOps
import org.rocksdb.*
import java.io.Closeable
import java.nio.charset.StandardCharsets

class LMKDB(dbPath: String, private var opsProvider: () -> KeyOps) : Closeable {
    private val db: TransactionDB
    private val cfHandles: List<ColumnFamilyHandle>
    private val writeOpts: WriteOptions
    val private: KeyStore
    val public: KeyStore

    init {
        RocksDB.loadLibrary()

        writeOpts = WriteOptions()

        val options = DBOptions()
            .setCreateIfMissing(true)
            .setCreateMissingColumnFamilies(true)

        val txnOptions = TransactionDBOptions()

        val cfDescs = listOf(
            ColumnFamilyDescriptor(RocksDB.DEFAULT_COLUMN_FAMILY),
            ColumnFamilyDescriptor(PRIVATE_KEY_MAP.toByteArray()),
            ColumnFamilyDescriptor(PUBLIC_KEY_MAP.toByteArray())
        )

        val handles = ArrayList<ColumnFamilyHandle>()
        db = TransactionDB.open(options, txnOptions, dbPath, cfDescs, handles)

        cfHandles = handles
        val cfMap = mapOf(
            PRIVATE_KEY_MAP to cfHandles[1],
            PUBLIC_KEY_MAP to cfHandles[2]
        )
        private = KeyStore(PRIVATE_KEY_MAP, cfMap[PRIVATE_KEY_MAP]!!)
        public = NoOpsKeyStore(PUBLIC_KEY_MAP, cfMap[PUBLIC_KEY_MAP]!!)
    }

    fun isInitialized(): Boolean = private.hasKey(SENTINEL_KEY)

    fun writeSentinel(ops: KeyOps) = private.saveRaw(SENTINEL_KEY, ops.encrypt(SENTINEL_VAL))

    fun checkValidKey(ops: KeyOps): Boolean =
        private.getRaw(SENTINEL_KEY)?.let { ops.decrypt(it).contentEquals(SENTINEL_VAL) } ?: false

    override fun close() {
        cfHandles.forEach { it.close() }
        db.close()
    }

    open inner class KeyStore(private val mapName: String, private val cf: ColumnFamilyHandle) {
        open fun save(id: String, raw: ByteArray) {
            val enc = opsProvider().encrypt(raw)
            db.beginTransaction(writeOpts).use { tx ->
                tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), enc)
                tx.commit()
            }
        }

        open fun saveRaw(id: String, raw: ByteArray) {
            db.beginTransaction(writeOpts).use { tx ->
                tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), raw)
                tx.commit()
            }
        }

        open fun get(id: String): ByteArray? =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8))?.let { opsProvider().decrypt(it) }

        open fun getRaw(id: String): ByteArray? =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8))

        open fun hasKey(id: String): Boolean =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8)) != null

        open fun delete(id: String) {
            db.beginTransaction(writeOpts).use { tx ->
                tx.delete(cf, id.toByteArray(StandardCharsets.UTF_8))
                tx.commit()
            }
        }
    }

    inner class NoOpsKeyStore(mapName: String, private val cf: ColumnFamilyHandle) : KeyStore(mapName, cf) {
        override fun save(id: String, raw: ByteArray) {
            db.beginTransaction(writeOpts).use { tx ->
                tx.put(cf, id.toByteArray(StandardCharsets.UTF_8), raw)
                tx.commit()
            }
        }

        override fun get(id: String): ByteArray? =
            db.get(cf, id.toByteArray(StandardCharsets.UTF_8))
    }

    private companion object {
        val SENTINEL_VAL = "BK-v1".toByteArray()

        const val SENTINEL_KEY = "__meta__"
        const val PRIVATE_KEY_MAP = "privateKey"
        const val PUBLIC_KEY_MAP = "publicKey"
    }
}