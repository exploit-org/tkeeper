package org.exploit.keeper.db

import org.exploit.crypto.curve.Ed25519Provider
import org.exploit.keeper.constant.common.ErrorType
import org.exploit.keeper.exception.TKeeperException
import org.exploit.keeper.service.key.dek.DekOps
import org.exploit.keeper.util.SignedSerializer
import org.exploit.tss.signature.SchnorrSignature
import org.exploit.tss.util.Hash
import org.rocksdb.*
import java.nio.charset.StandardCharsets

class KeyStoreOps(
    private val keyDb: RocksKeyDB,
    private val cf: ColumnFamilyHandle,
    private val writeOpts: WriteOptions,
    private val readOpts: ReadOptions,
    private val opsProvider: () -> DekOps
) {
    private val transactionDb by lazy {
        keyDb.rocksdb()
    }

    fun newIterator(): RocksIterator = transactionDb.newIterator(cf)

    fun newIterator(tx: Transaction): RocksIterator = tx.getIterator(ReadOptions(), cf)

    fun <T> runInTransaction(block: (Transaction) -> T): T {
        transactionDb.beginTransaction(writeOpts).use { tx ->
            try {
                val res = block(tx)
                tx.commit()
                return res
            } catch (e: Throwable) {
                try { tx.rollback() } catch (_: Throwable) {}
                throw e
            }
        }
    }

    fun save(id: String, raw: ByteArray) =
        runInTransaction { tx -> save(tx, id, raw) }

    fun save(tx: Transaction, id: String, raw: ByteArray) {
        val ops = opsProvider()
        tx.put(cf, id.toBytes(), ops.encrypt(raw))
    }

    fun saveRaw(id: String, raw: ByteArray) =
        runInTransaction { tx -> saveRaw(tx, id, raw) }

    fun saveRaw(tx: Transaction, id: String, raw: ByteArray) {
        tx.put(cf, id.toBytes(), raw)
    }

    fun saveMulti(data: Map<String, ByteArray>) =
        runInTransaction { tx -> saveMulti(tx, data) }

    fun saveMulti(tx: Transaction, data: Map<String, ByteArray>) {
        val ops = opsProvider()
        data.forEach { (id, raw) ->
            tx.put(cf, id.toBytes(), ops.encrypt(raw))
        }
    }

    fun saveMultiRaw(data: Map<String, ByteArray>) =
        runInTransaction { tx -> saveMultiRaw(tx, data) }

    fun saveMultiRaw(tx: Transaction, data: Map<String, ByteArray>) {
        data.forEach { (id, raw) ->
            tx.put(cf, id.toBytes(), raw)
        }
    }

    fun saveSigned(id: String, data: ByteArray) =
        runInTransaction { tx -> saveSigned(tx, id, data) }

    fun saveSigned(tx: Transaction, id: String, data: ByteArray) {
        val integrityKeyVersion = keyDb.readIntegrityKeyVersion()
        val integrityKeyPair = keyDb.readIntegrityKeyPair()

        val signature = Ed25519Provider.getInstance().sign(Hash.sha256(data), integrityKeyPair)
        val serialized = SignedSerializer.serialize(data, integrityKeyVersion, signature.encode())

        saveRaw(tx, id, serialized)
    }

    fun getSigned(tx: Transaction, id: String): ByteArray? {
        val signed = getRaw(tx, id) ?: return null
        return extractAndVerify(id, signed)
    }

    fun getSigned(id: String): ByteArray? {
        val signed = getRaw(id) ?: return null
        return extractAndVerify(id, signed)
    }

    fun get(id: String): ByteArray? =
        transactionDb.get(cf, id.toBytes())?.let { opsProvider().decrypt(it) }

    fun get(tx: Transaction, id: String): ByteArray? =
        tx.get(readOpts, cf, id.toBytes())?.let { opsProvider().decrypt(it) }

    fun getRaw(id: String): ByteArray? =
        transactionDb.get(cf, id.toBytes())

    fun getRaw(tx: Transaction, id: String): ByteArray? =
        tx.get(readOpts,cf, id.toBytes())

    fun hasKey(id: String): Boolean =
        transactionDb.get(cf, id.toBytes()) != null

    fun hasKey(tx: Transaction, id: String): Boolean =
        tx.get(readOpts, cf, id.toBytes()) != null

    fun delete(id: String) =
        runInTransaction { tx -> delete(tx, id) }

    fun delete(tx: Transaction, id: String) {
        tx.delete(cf, id.toBytes())
    }

    private fun extractAndVerify(id: String, signed: ByteArray): ByteArray {
        val payload = SignedSerializer.deserialize(signed)

        val integrityPublicKey = keyDb.readIntegrityPublicKey(payload.keyVersion)
        val r = payload.signature.copyOfRange(0, 32)
        val s = payload.signature.copyOfRange(32, 64)
        val signature = SchnorrSignature(r, s)

        if (!Ed25519Provider.getInstance().verify(Hash.sha256(payload.data), signature, integrityPublicKey))
            throw TKeeperException(ErrorType.TAMPERED_KEEPER, "Data under $id failed signature check")

        return payload.data
    }

    private fun String.toBytes(): ByteArray =
        this.toByteArray(StandardCharsets.UTF_8)
}