package org.exploit.keeper.db

import org.exploit.keeper.constant.expire.ExpireType
import org.exploit.keeper.model.Page
import org.exploit.keeper.model.expire.ExpireItem
import org.exploit.keeper.model.keyset.KeySetPolicy
import org.rocksdb.Transaction
import java.nio.charset.StandardCharsets
import java.util.*

class ExpireStore(private val ops: KeyStoreOps) {
    fun syncHead(tx: Transaction, logicalId: String, gen: Int, policy: KeySetPolicy?) {
        upsert(tx, ExpireType.APPLY, logicalId, gen, policy?.apply?.seconds())
        upsert(tx, ExpireType.PROCESS, logicalId, gen, policy?.process?.seconds())
    }

    fun syncNonHead(tx: Transaction, logicalId: String, gen: Int, policy: KeySetPolicy?) {
        clear(tx, ExpireType.APPLY, logicalId, gen)
        upsert(tx, ExpireType.PROCESS, logicalId, gen, policy?.process?.seconds())
    }

    fun clearAllForGen(tx: Transaction, logicalId: String, gen: Int) {
        clear(tx, ExpireType.APPLY, logicalId, gen)
        clear(tx, ExpireType.PROCESS, logicalId, gen)
    }

    fun scan(
        type: ExpireType,
        fromEpochSec: Long = 0,
        toEpochSec: Long,
        limit: Int = 500,
        cursor: String? = null
    ): Page<ExpireItem, String> {
        val prefix = prefix(type)
        val prefixBytes = prefix.toByteArray(StandardCharsets.UTF_8)

        val startKey = cursor ?: (prefix + due13(fromEpochSec) + ":")
        val startKeyBytes = startKey.toByteArray(StandardCharsets.UTF_8)

        val res = ArrayList<ExpireItem>(minOf(limit, 256))
        var lastKey: String? = null

        ops.newIterator().use {
            it.seek(startKeyBytes)

            if (cursor != null && it.isValid) {
                val k0 = String(it.key(), StandardCharsets.UTF_8)
                if (k0 == cursor) it.next()
            }

            while (it.isValid && res.size < limit) {
                val k = it.key()
                if (!startsWith(k, prefixBytes)) break

                val keyStr = String(k, StandardCharsets.UTF_8)
                val parsed = parseIndexKey(type, keyStr)

                if (parsed == null) {
                    it.next()
                    continue
                }

                if (parsed.expiresAt > toEpochSec) break

                res += parsed
                lastKey = keyStr
                it.next()
            }
        }

        val next = if (res.size >= limit) lastKey else null
        return Page(res, next)
    }

    private fun upsert(tx: Transaction, type: ExpireType, logicalId: String, gen: Int, expiresAt: Long?) {
        if (expiresAt == null || expiresAt <= 0) {
            clear(tx, type, logicalId, gen)
            return
        }

        val revKey = revKey(type, logicalId, gen)
        val oldIndexKey = ops.getRaw(tx, revKey)?.let { String(it, StandardCharsets.UTF_8) }
        if (oldIndexKey != null) {
            ops.delete(tx, oldIndexKey)
        }

        val idxKey = indexKey(type, logicalId, gen, expiresAt)
        ops.saveRaw(tx, idxKey, byteArrayOf(1))
        ops.saveRaw(tx, revKey, idxKey.toByteArray(StandardCharsets.UTF_8))
    }

    private fun clear(tx: Transaction, type: ExpireType, logicalId: String, gen: Int) {
        val revKey = revKey(type, logicalId, gen)
        val oldIndexKey = ops.getRaw(tx, revKey)?.let { String(it, StandardCharsets.UTF_8) }
        if (oldIndexKey != null) ops.delete(tx, oldIndexKey)
        ops.delete(tx, revKey)
    }

    private fun parseIndexKey(type: ExpireType, key: String): ExpireItem? {
        val p = prefix(type)
        if (!key.startsWith(p)) return null

        val rest = key.substring(p.length)
        val parts = rest.split(':')
        if (parts.size < 3) return null

        val expiresAt = parts[0].toLongOrNull() ?: return null
        val logicalId = decodeId(parts[1])
        val gen = parts[2].toIntOrNull() ?: return null

        return ExpireItem(type, logicalId, gen, expiresAt)
    }

    companion object {
        private const val P_A = "e:a:"
        private const val P_P = "e:p:"
        private const val P_REV_A = "e:rev:a:"
        private const val P_REV_P = "e:rev:p:"

        private fun prefix(type: ExpireType) = if (type == ExpireType.APPLY) P_A else P_P

        private fun due13(x: Long): String = String.format("%013d", x.coerceAtLeast(0))
        private fun gen10(x: Int): String = String.format("%010d", x.coerceAtLeast(0))

        private fun encodeId(id: String): String =
            Base64.getUrlEncoder().encodeToString(id.toByteArray(StandardCharsets.UTF_8))

        private fun decodeId(b64: String): String = String(Base64.getUrlDecoder().decode(b64), StandardCharsets.UTF_8)
        private fun indexKey(type: ExpireType, logicalId: String, gen: Int, expiresAt: Long): String {
            val p = prefix(type)
            return p + due13(expiresAt) + ":" + encodeId(logicalId) + ":" + gen10(gen)
        }

        private fun revKey(type: ExpireType, logicalId: String, gen: Int): String {
            val p = if (type == ExpireType.APPLY) P_REV_A else P_REV_P
            return p + encodeId(logicalId) + ":" + gen10(gen)
        }

        private fun startsWith(bytes: ByteArray, prefix: ByteArray): Boolean {
            if (bytes.size < prefix.size) return false
            for (i in prefix.indices) if (bytes[i] != prefix[i]) return false
            return true
        }
    }
}