package org.exploit.keeper.db

import org.exploit.keeper.extension.objectMapper
import org.exploit.keeper.model.SignedPayload
import org.exploit.keeper.model.keyset.KeySetMeta
import org.exploit.keeper.model.keyset.KeySetPolicy
import org.exploit.keeper.util.SignedSerializer
import org.rocksdb.Transaction
import java.time.Instant

class MetaStore(val ops: KeyStoreOps, private val expire: ExpireStore, private val ownerIndex: OwnerIndexStore) {
    fun nextGenId(logicalId: String): Int =
        ops.runInTransaction { tx -> nextGenId(tx, logicalId) }

    fun nextGenId(tx: Transaction, logicalId: String): Int {
        val existing = loadKeysetMeta(tx, logicalId)
        return (existing?.currentGeneration ?: 0) + 1
    }

    fun loadPendingKeysetMeta(logicalId: String): KeySetMeta? =
        loadPendingKeysetMeta(null, logicalId)

    fun loadPendingKeysetMeta(tx: Transaction?, logicalId: String): KeySetMeta? {
        val raw = if (tx != null)
            ops.getSigned(tx, PENDING_KEYSET_META.format(logicalId))
        else
            ops.getSigned(PENDING_KEYSET_META.format(logicalId))

        raw ?: return null
        return objectMapper.readValue(raw, KeySetMeta::class.java)
    }

    fun savePendingKeysetMeta(meta: KeySetMeta) =
        ops.runInTransaction { tx -> savePendingKeysetMeta(tx, meta) }

    fun savePendingKeysetMeta(tx: Transaction, meta: KeySetMeta) {
        val bytes = objectMapper.writeValueAsBytes(meta)

        ops.saveSigned(tx, PENDING_KEYSET_META.format(meta.logicalId), bytes)
        ops.saveSigned(tx, PENDING_KEYSET_META_VERSION.format(meta.logicalId, meta.currentGeneration), bytes)
    }

    fun deletePendingKeysetMeta(logicalId: String) =
        ops.runInTransaction { tx -> deletePendingKeysetMeta(tx, logicalId) }

    fun deletePendingKeysetMeta(tx: Transaction, logicalId: String) {
        ops.delete(tx, PENDING_KEYSET_META.format(logicalId))
    }

    fun loadPendingVersionedMeta(logicalId: String, generation: Int): KeySetMeta? =
        loadPendingVersionedMeta(null, logicalId, generation)

    fun loadPendingVersionedMeta(tx: Transaction?, logicalId: String, generation: Int): KeySetMeta? {
        val key = PENDING_KEYSET_META_VERSION.format(logicalId, generation)
        val raw = (if (tx != null) ops.getSigned(tx, key) else ops.getSigned(key))
            ?: return null

        return objectMapper.readValue(raw, KeySetMeta::class.java)
    }

    fun savePendingVersionedMeta(meta: KeySetMeta) =
        ops.runInTransaction { tx -> savePendingVersionedMeta(tx, meta) }

    fun savePendingVersionedMeta(tx: Transaction, meta: KeySetMeta) {
        val bytes = objectMapper.writeValueAsBytes(meta)
        ops.saveSigned(tx, PENDING_KEYSET_META_VERSION.format(meta.logicalId, meta.currentGeneration), bytes)
    }

    fun deletePendingVersionedMeta(logicalId: String, generation: Int) =
        ops.runInTransaction { tx -> deletePendingVersionedMeta(tx, logicalId, generation) }

    fun deletePendingVersionedMeta(tx: Transaction, logicalId: String, generation: Int) {
        ops.delete(tx, PENDING_KEYSET_META_VERSION.format(logicalId, generation))
    }

    fun promotePendingMetaToActive(logicalId: String, generation: Int): KeySetMeta? =
        ops.runInTransaction { tx -> promotePendingMetaToActive(tx, logicalId, generation) }

    fun promotePendingMetaToActive(tx: Transaction, logicalId: String, generation: Int): KeySetMeta? {
        val active = loadKeysetMeta(tx, logicalId)
        val prevGen = active?.currentGeneration
        val prevPolicy = active?.policy

        if (active != null && active.currentGeneration == generation) {
            dropPendingMeta(tx, logicalId, generation)
            return active
        }

        val pending = loadPendingVersionedMeta(tx, logicalId, generation)
            ?: loadPendingKeysetMeta(tx, logicalId)?.takeIf { it.currentGeneration == generation }
            ?: return null

        if (pending.currentGeneration != generation) return null

        saveKeysetMeta(tx, pending)
        saveVersionedMeta(tx, pending)

        if (prevGen != null) {
            expire.syncNonHead(tx, logicalId, prevGen, prevPolicy)
        }

        dropPendingMeta(tx, logicalId, generation)

        return pending
    }

    fun dropPendingMeta(logicalId: String, generation: Int) =
        ops.runInTransaction { tx -> dropPendingMeta(tx, logicalId, generation) }

    fun dropPendingMeta(tx: Transaction, logicalId: String, generation: Int) {
        val head = loadPendingKeysetMeta(tx, logicalId)
        if (head != null && head.currentGeneration == generation) {
            deletePendingKeysetMeta(tx, logicalId)
        }
        deletePendingVersionedMeta(tx, logicalId, generation)
    }

    fun loadKeysetMeta(logicalId: String): KeySetMeta? =
        loadKeysetMeta(null, logicalId)

    fun loadKeysetMeta(tx: Transaction?, logicalId: String): KeySetMeta? {
        val key = KEYSET_META.format(logicalId)
        val raw = (if (tx != null) ops.getSigned(tx, key) else ops.getSigned(key))
            ?: return null

        return objectMapper.readValue(raw, KeySetMeta::class.java)
    }

    fun loadSignedKeyMeta(logicalId: String): SignedPayload? =
        loadSignedKeyMeta(null, logicalId)

    fun loadSignedKeyMeta(tx: Transaction?, logicalId: String): SignedPayload? {
        val key = KEYSET_META.format(logicalId)
        val raw = (if (tx != null) ops.getRaw(tx, key) else ops.getRaw(key))
            ?: return null

        return SignedSerializer.deserialize(raw)
    }

    fun saveKeysetMeta(meta: KeySetMeta) =
        ops.runInTransaction { tx -> saveKeysetMeta(tx, meta) }

    fun saveKeysetMeta(tx: Transaction, meta: KeySetMeta) {
        val bytes = objectMapper.writeValueAsBytes(meta)
        ops.saveSigned(tx, KEYSET_META.format(meta.logicalId), bytes)

        expire.syncHead(tx, meta.logicalId, meta.currentGeneration, meta.policy)
        ownerIndex.syncHead(tx, meta)
    }

    fun loadVersionedMeta(logicalId: String, generation: Int): KeySetMeta? =
        loadVersionedMeta(null, logicalId, generation)

    fun loadVersionedMeta(tx: Transaction?, logicalId: String, generation: Int): KeySetMeta? {
        val key = KEYSET_META_VERSION.format(logicalId, generation)
        val raw = if (tx != null) ops.getSigned(tx, key) else ops.getSigned(key)
        raw ?: return null
        return objectMapper.readValue(raw, KeySetMeta::class.java)
    }

    fun saveVersionedMeta(meta: KeySetMeta) =
        ops.runInTransaction { tx -> saveVersionedMeta(tx, meta) }

    fun saveVersionedMeta(tx: Transaction, meta: KeySetMeta) {
        val bytes = objectMapper.writeValueAsBytes(meta)
        ops.saveSigned(tx, KEYSET_META_VERSION.format(meta.logicalId, meta.currentGeneration), bytes)
    }

    private fun deleteHead(logicalId: String) =
        ops.runInTransaction { tx -> deleteHead(tx, logicalId) }

    private fun deleteHead(tx: Transaction, logicalId: String) {
        val existing = loadKeysetMeta(tx, logicalId)
        if (existing != null) {
            expire.clearAllForGen(tx, logicalId, existing.currentGeneration)
        }

        ops.delete(tx, KEYSET_META.format(logicalId))
        ownerIndex.clear(tx, logicalId)
    }

    fun upsertKeysetMeta(logicalId: String, mutate: (KeySetMeta?) -> KeySetMeta): KeySetMeta =
        ops.runInTransaction { tx -> upsertKeysetMeta(tx, logicalId, mutate) }

    fun upsertKeysetMeta(tx: Transaction, logicalId: String, mutate: (KeySetMeta?) -> KeySetMeta): KeySetMeta {
        val existing = loadKeysetMeta(tx, logicalId)
        val updated = mutate(existing)
        saveKeysetMeta(tx, updated)
        return updated
    }

    fun upsertNotNullKeysetMeta(
        logicalId: String,
        generation: Int,
        mutate: (KeySetMeta) -> KeySetMeta
    ): KeySetMeta = ops.runInTransaction { tx ->
        upsertNotNullKeysetMeta(tx, logicalId, generation, mutate)
    }

    fun upsertNotNullKeysetMeta(
        tx: Transaction,
        logicalId: String,
        generation: Int,
        mutate: (KeySetMeta) -> KeySetMeta
    ): KeySetMeta {
        val now = Instant.now()
        val existing = loadKeysetMeta(tx, logicalId)
            ?: KeySetMeta(
                logicalId = logicalId,
                currentGeneration = generation,
                enabled = true,
                createdAt = now.epochSecond,
                updatedAt = now.epochSecond,
                policy = null
            )

        val updated = mutate(existing)
        saveKeysetMeta(tx, updated)
        saveVersionedMeta(tx, updated)
        return updated
    }

    fun setCurrentGeneration(logicalId: String, generation: Int, policy: KeySetPolicy?): KeySetMeta =
        ops.runInTransaction { tx -> setCurrentGeneration(tx, logicalId, generation, policy) }

    fun setCurrentGeneration(tx: Transaction, logicalId: String, generation: Int, policy: KeySetPolicy?): KeySetMeta {
        val prev = loadKeysetMeta(tx, logicalId)
        val prevGen = prev?.currentGeneration
        val prevPolicy = prev?.policy

        val updated = upsertNotNullKeysetMeta(tx, logicalId, generation) { existing ->
            val now = Instant.now()
            existing.copy(currentGeneration = generation, updatedAt = now.epochSecond, policy = policy)
        }

        if (prevGen != null && prevGen != generation) {
            expire.syncNonHead(tx, logicalId, prevGen, prevPolicy)
        }

        return updated
    }

    fun enabled(logicalId: String, gen: Int, status: Boolean): KeySetMeta =
        ops.runInTransaction { tx -> enabled(tx, logicalId, gen, status) }

    fun enabled(tx: Transaction, logicalId: String, gen: Int, status: Boolean): KeySetMeta {
        return upsertNotNullKeysetMeta(tx, logicalId, gen) { existing ->
            val now = Instant.now()
            existing.copy(enabled = status, updatedAt = now.epochSecond)
        }
    }

    fun rollbackToLatest(logicalId: String, failedGeneration: Int): KeySetMeta? =
        ops.runInTransaction { tx -> rollbackToLatest(tx, logicalId, failedGeneration) }

    fun rollbackToLatest(tx: Transaction, logicalId: String, failedGeneration: Int): KeySetMeta? {
        val failedHead = loadKeysetMeta(tx, logicalId)
        dropPendingMeta(tx, logicalId, failedGeneration)

        val current = failedHead ?: return null
        if (current.currentGeneration != failedGeneration) return current

        val prevGen = failedGeneration - 1
        if (prevGen <= 0) {
            expire.clearAllForGen(tx, logicalId, failedGeneration)
            deleteHead(tx, logicalId)
            return null
        }

        val prevMeta = loadVersionedMeta(tx, logicalId, prevGen)
            ?: current.copy(currentGeneration = prevGen, updatedAt = Instant.now().epochSecond)

        val fixed = prevMeta.copy(currentGeneration = prevGen, updatedAt = Instant.now().epochSecond)
        saveKeysetMeta(tx, fixed)

        expire.syncNonHead(tx, logicalId, failedGeneration, current.policy)

        return fixed
    }

    companion object {
        const val KEYSET_META_VERSION = "__keyset_meta_version__%s__version__%010d"
        const val PENDING_KEYSET_META_VERSION = "__pending_keyset_meta__%s__version__%010d"

        const val KEYSET_META_PREFIX = "__keyset_meta__"
        const val KEYSET_META = "$KEYSET_META_PREFIX%s"
        const val KEYSET_META_VERSION_PREFIX = "__keyset_meta_version__"

        const val PENDING_KEYSET_META = "__pending_keyset_meta__%s"
    }
}