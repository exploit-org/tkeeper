package org.exploit.keeper.db

import org.exploit.keeper.model.key.KeyVersion
import org.rocksdb.Transaction
import java.nio.charset.StandardCharsets

class LogicalKeyStore(val ops: KeyStoreOps) {
    fun readLatestVersion(logicalId: String): KeyVersion =
        ops.runInTransaction { tx -> readLatestVersion(tx, logicalId) }

    fun readLatestVersion(tx: Transaction, logicalId: String): KeyVersion {
        val actualGen = findLatestGeneration(tx, logicalId)
        val pendingGen = findLatestPendingGeneration(tx, logicalId)
        return KeyVersion(actualGen, pendingGen)
    }

    fun toLatestGenKeyId(logicalId: String): String =
        ops.runInTransaction { tx -> toLatestGenKeyId(tx, logicalId) }

    fun toLatestGenKeyId(tx: Transaction, logicalId: String): String {
        val gen = findLatestGeneration(tx, logicalId) ?: return logicalId
        if (gen == 0) return logicalId
        return LOGICAL_KEY.format(logicalId, gen)
    }

    fun findLatestPendingGeneration(logicalId: String): Int? =
        ops.runInTransaction { tx -> findLatestPendingGeneration(tx, logicalId) }

    fun findLatestPendingGeneration(tx: Transaction, logicalId: String): Int? {
        val prefix = PENDING_VERSION_PREFIX.format(logicalId)
        return scanMaxGenerationByPrefix(tx, prefix)
    }

    fun findLatestGeneration(logicalId: String): Int? =
        ops.runInTransaction { tx -> findLatestGeneration(tx, logicalId) }

    fun findLatestGeneration(tx: Transaction, logicalId: String): Int? {
        val genBytes = ops.getRaw(tx, KEY_GENERATION.format(logicalId))
            ?: return if (ops.hasKey(tx, logicalId)) 0 else null

        return String(genBytes, StandardCharsets.UTF_8).toInt()
    }

    fun savePending(logicalId: String, generation: Int, raw: ByteArray) =
        ops.runInTransaction { tx -> savePending(tx, logicalId, generation, raw) }

    fun savePending(tx: Transaction, logicalId: String, generation: Int, raw: ByteArray) {
        val pendingId = PENDING_LOGICAL_KEY.format(logicalId, generation)
        ops.save(tx, pendingId, raw)
    }

    fun readPending(logicalId: String, generation: Int): ByteArray? =
        ops.runInTransaction { tx -> readPending(tx, logicalId, generation) }

    fun readPending(tx: Transaction, logicalId: String, generation: Int): ByteArray? {
        val pendingId = PENDING_LOGICAL_KEY.format(logicalId, generation)
        return ops.get(tx, pendingId)
    }

    fun deletePending(logicalId: String, generation: Int) =
        ops.runInTransaction { tx -> deletePending(tx, logicalId, generation) }

    fun deletePending(tx: Transaction, logicalId: String, generation: Int) {
        val pendingId = PENDING_LOGICAL_KEY.format(logicalId, generation)
        ops.delete(tx, pendingId)
    }

    fun promotePendingToActive(logicalId: String, generation: Int) =
        ops.runInTransaction { tx -> promotePendingToActive(tx, logicalId, generation) }

    fun promotePendingToActive(tx: Transaction, logicalId: String, generation: Int) {
        val pendingId = PENDING_LOGICAL_KEY.format(logicalId, generation)
        val raw = ops.get(tx, pendingId)
            ?: throw IllegalStateException("Pending key not found for $logicalId/$generation")

        saveKey(tx, logicalId, generation, raw)
        ops.delete(tx, pendingId)
    }

    fun hasKey(logicalId: String, generation: Int): Boolean =
        ops.runInTransaction { tx -> hasKey(tx, logicalId, generation) }

    fun hasKey(tx: Transaction, logicalId: String, generation: Int): Boolean {
        val keyId = LOGICAL_KEY.format(logicalId, generation)
        return ops.hasKey(tx, keyId)
    }

    fun deleteKey(logicalId: String, generation: Int) =
        ops.runInTransaction { tx -> deleteKey(tx, logicalId, generation) }

    fun deleteKey(tx: Transaction, logicalId: String, generation: Int) {
        val keyId = LOGICAL_KEY.format(logicalId, generation)
        ops.delete(tx, keyId)
    }

    fun hasKey(logicalId: String): Boolean =
        ops.runInTransaction { tx -> hasKey(tx, logicalId) }

    fun hasKey(tx: Transaction, logicalId: String): Boolean {
        val keyId = toLatestGenKeyId(tx, logicalId)
        return ops.hasKey(tx, keyId)
    }

    fun getCurrentGeneration(logicalId: String): Int =
        ops.runInTransaction { tx -> getCurrentGeneration(tx, logicalId) }

    fun getCurrentGeneration(tx: Transaction, logicalId: String): Int {
        val raw = ops.getRaw(tx, KEY_GENERATION.format(logicalId)) ?: return 0
        return String(raw, StandardCharsets.UTF_8).toInt()
    }

    fun setCurrentGeneration(logicalId: String, generation: Int) =
        ops.runInTransaction { tx -> setCurrentGeneration(tx, logicalId, generation) }

    fun setCurrentGeneration(tx: Transaction, logicalId: String, generation: Int) {
        ops.saveRaw(
            tx,
            KEY_GENERATION.format(logicalId),
            generation.toString().toByteArray(StandardCharsets.UTF_8)
        )
    }

    fun clearGeneration(logicalId: String) =
        ops.runInTransaction { tx -> clearGeneration(tx, logicalId) }

    fun clearGeneration(tx: Transaction, logicalId: String) {
        ops.delete(tx, KEY_GENERATION.format(logicalId))
    }

    fun saveKey(logicalId: String, generation: Int, raw: ByteArray) =
        ops.runInTransaction { tx -> saveKey(tx, logicalId, generation, raw) }

    fun saveKey(tx: Transaction, logicalId: String, generation: Int, raw: ByteArray) {
        val keyId = LOGICAL_KEY.format(logicalId, generation)
        ops.save(tx, keyId, raw)

        val current = getCurrentGeneration(tx, logicalId)
        if (generation > current) {
            setCurrentGeneration(tx, logicalId, generation)
        }
    }

    fun readKey(logicalId: String, generation: Int): ByteArray? =
        ops.runInTransaction { tx -> readKey(tx, logicalId, generation) }

    fun readKey(tx: Transaction, logicalId: String, generation: Int): ByteArray? {
        if (generation == 0) return ops.get(tx, logicalId)
        val keyId = LOGICAL_KEY.format(logicalId, generation)
        return ops.get(tx, keyId)
    }

    fun readCurrentKey(logicalId: String): ByteArray? =
        ops.runInTransaction { tx -> readCurrentKey(tx, logicalId) }

    fun readCurrentKey(tx: Transaction, logicalId: String): ByteArray? {
        val keyId = toLatestGenKeyId(tx, logicalId)
        return ops.get(tx, keyId)
    }

    fun rotateKey(logicalId: String, raw: ByteArray): Int =
        ops.runInTransaction { tx -> rotateKey(tx, logicalId, raw) }

    fun rotateKey(tx: Transaction, logicalId: String, raw: ByteArray): Int {
        val nextGen = getCurrentGeneration(tx, logicalId) + 1
        saveKey(tx, logicalId, nextGen, raw)
        return nextGen
    }

    fun rollbackToGeneration(logicalId: String, failedGeneration: Int) =
        ops.runInTransaction { tx -> rollbackToGeneration(tx, logicalId, failedGeneration) }

    fun rollbackToGeneration(tx: Transaction, logicalId: String, failedGeneration: Int) {
        val current = getCurrentGeneration(tx, logicalId)
        if (current != failedGeneration) return

        val failedKeyId = LOGICAL_KEY.format(logicalId, failedGeneration)
        if (ops.hasKey(tx, failedKeyId)) {
            ops.delete(tx, failedKeyId)
        }

        val prevGen = failedGeneration - 1
        if (prevGen <= 0) {
            clearGeneration(tx, logicalId)
        } else {
            setCurrentGeneration(tx, logicalId, prevGen)
        }
    }

    private fun scanMaxGenerationByPrefix(tx: Transaction, prefix: String): Int? {
        val prefixBytes = prefix.toByteArray(StandardCharsets.UTF_8)
        var maxGen: Int? = null

        ops.newIterator(tx).use { it ->
            it.seek(prefixBytes)
            while (it.isValid) {
                val keyStr = String(it.key(), StandardCharsets.UTF_8)
                if (!keyStr.startsWith(prefix)) break

                val genStr = keyStr.substring(prefix.length)
                val gen = genStr.toIntOrNull()
                if (gen != null && (maxGen == null || gen > maxGen)) {
                    maxGen = gen
                }
                it.next()
            }
        }

        return maxGen
    }
    
    private companion object {
        const val LOGICAL_KEY = "__logical_key__%s__version__%010d"
        const val PENDING_LOGICAL_KEY = "__pending_logical_key__%s__version__%010d"
        const val KEY_GENERATION = "__key_generation__%s"
        const val PENDING_VERSION_PREFIX = "__pending_logical_key__%s__version__"
    }
}