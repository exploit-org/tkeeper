package org.exploit.keeper.db

import org.exploit.keeper.model.keygen.DkgCommitments
import org.exploit.keeper.util.CommitmentsSerializer.deserialize
import org.exploit.keeper.util.CommitmentsSerializer.serialize
import org.rocksdb.Transaction

class CommitStore(val ops: KeyStoreOps) {
    fun savePending(tx: Transaction, keyId: String, gen: Int, commits: DkgCommitments) {
        val raw = serialize(commits)
        ops.saveSigned(tx, DKG_COMMITMENTS_PENDING.format(keyId, gen), raw)
    }

    fun readPending(keyId: String, gen: Int): DkgCommitments? =
        ops.runInTransaction { tx -> readPending(tx, keyId, gen) }

    fun readPending(tx: Transaction, keyId: String, gen: Int): DkgCommitments? {
        val raw = ops.getSigned(tx, DKG_COMMITMENTS_PENDING.format(keyId, gen)) ?: return null
        return deserialize(raw)
    }

    fun deletePending(keyId: String, gen: Int) =
        ops.runInTransaction { tx -> deletePending(tx, keyId, gen) }

    fun deletePending(tx: Transaction, keyId: String, gen: Int) {
        ops.delete(tx, DKG_COMMITMENTS_PENDING.format(keyId, gen))
    }

    fun readActive(keyId: String, gen: Int): DkgCommitments? =
        ops.runInTransaction { tx -> readActive(tx, keyId, gen) }

    fun readActive(tx: Transaction, keyId: String, gen: Int): DkgCommitments? {
        val raw = ops.getSigned(tx, DKG_COMMITMENTS.format(keyId, gen)) ?: return null
        return deserialize(raw)
    }

    fun deleteActive(keyId: String, gen: Int) =
        ops.runInTransaction { tx -> deleteActive(tx, keyId, gen) }

    fun deleteActive(tx: Transaction, keyId: String, gen: Int) {
        ops.delete(tx, DKG_COMMITMENTS.format(keyId, gen))
    }

    fun hasPending(keyId: String, gen: Int): Boolean =
        ops.runInTransaction { tx -> hasPending(tx, keyId, gen) }

    fun hasPending(tx: Transaction, keyId: String, gen: Int): Boolean =
        ops.hasKey(tx, DKG_COMMITMENTS_PENDING.format(keyId, gen))

    fun hasActive(keyId: String, gen: Int): Boolean =
        ops.runInTransaction { tx -> hasActive(tx, keyId, gen) }

    fun hasActive(tx: Transaction, keyId: String, gen: Int): Boolean =
        ops.hasKey(tx, DKG_COMMITMENTS.format(keyId, gen))

    fun promotePendingToActive(tx: Transaction, keyId: String, gen: Int): DkgCommitments {
        val active = readActive(tx, keyId, gen)
        if (active != null) {
            deletePending(tx, keyId, gen)
            return active
        }

        val pendingId = DKG_COMMITMENTS_PENDING.format(keyId, gen)
        val raw = ops.getSigned(tx, pendingId) ?: throw IllegalStateException("Pending commitments not found for $keyId/$gen")

        ops.saveSigned(tx, DKG_COMMITMENTS.format(keyId, gen), raw)
        ops.delete(tx, pendingId)

        return deserialize(raw)
    }

    fun promotePendingToActiveIfPresent(tx: Transaction, keyId: String, gen: Int): DkgCommitments? {
        val active = readActive(tx, keyId, gen)
        if (active != null) {
            deletePending(tx, keyId, gen)
            return active
        }

        val pendingId = DKG_COMMITMENTS_PENDING.format(keyId, gen)
        val raw = ops.getSigned(tx, pendingId) ?: return null

        ops.saveSigned(tx, DKG_COMMITMENTS.format(keyId, gen), raw)
        ops.delete(tx, pendingId)

        return deserialize(raw)
    }

    fun findLatestActiveGeneration(keyId: String): Int? =
        ops.runInTransaction { tx -> findLatestActiveGeneration(tx, keyId) }

    fun findLatestActiveGeneration(tx: Transaction, keyId: String): Int? {
        val prefix = DKG_COMMITMENTS_PREFIX.format(keyId)
        return scanMaxGenerationByPrefix(tx, prefix)
    }

    fun readLatestActive(keyId: String): Pair<Int, DkgCommitments>? =
        ops.runInTransaction { tx -> readLatestActive(tx, keyId) }

    fun readLatestActive(tx: Transaction, keyId: String): Pair<Int, DkgCommitments>? {
        val gen = findLatestActiveGeneration(tx, keyId) ?: return null
        val commits = readActive(tx, keyId, gen) ?: return null
        return gen to commits
    }

    private fun scanMaxGenerationByPrefix(tx: Transaction, prefix: String): Int? {
        val prefixBytes = prefix.toByteArray(Charsets.UTF_8)
        var maxGen: Int? = null

        ops.newIterator(tx).use { it ->
            it.seek(prefixBytes)
            while (it.isValid) {
                val keyStr = String(it.key(), Charsets.UTF_8)
                if (!keyStr.startsWith(prefix)) break

                val genStr = keyStr.substring(prefix.length)
                val gen = genStr.toIntOrNull()
                if (gen != null && (maxGen == null || gen > maxGen)) {
                    maxGen = gen
                }
                it.next()
            }
        }

        return maxGen
    }

    private companion object {
        const val DKG_COMMITMENTS = "__dkg_commitments__%s__version__%010d"
        const val DKG_COMMITMENTS_PENDING = "__pending_dkg_commitments__%s__version__%010d"
        const val DKG_COMMITMENTS_PREFIX = "__dkg_commitments__%s__version__"
    }
}