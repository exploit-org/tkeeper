package org.exploit.keeper.extension

import org.exploit.jettyx.model.HttpResponse
import org.exploit.keeper.api.client.TKeeperClient
import java.util.concurrent.CompletableFuture

fun <T: Any> List<CompletableFuture<T>>.wait(): List<T> {
    CompletableFuture.allOf(*this.toTypedArray()).join()

    return this.map { it.join() }
}

fun <T : Any> CompletableFuture<HttpResponse<T>>.succeed(): CompletableFuture<T> = handle { response, e ->
    if (e == null && response != null && response.status in 200..299) {
        return@handle response.body
    }

    if (e != null)
        throw e

    error("Unexpected response: ${response.status}, ${response.body}")
}

fun <T: Any> List<TKeeperClient>.perform(action: (TKeeperClient) -> CompletableFuture<HttpResponse<T>>): List<T> {
    val futures = this.map { client -> action(client).succeed() }
    return futures.wait()
}

fun <T : Any> List<TKeeperClient>.performIndexed(
    action: (TKeeperClient) -> CompletableFuture<HttpResponse<T>>
): Map<Int, T> {
    val tasks = this.map { client ->
        val id = client.peerId
        id to action(client).succeed()
    }

    CompletableFuture.allOf(*tasks.map { it.second }.toTypedArray()).join()
    return tasks.associate { (id, f) -> id to f.join() }
}

fun <T : Any> List<TKeeperClient>.performSuccessOnly(
    action: (TKeeperClient) -> CompletableFuture<HttpResponse<T>>
): Map<Int, HttpResponse<T>> {
    val tasks = this.map { client ->
        val id = client.peerId
        id to action(client).handle { resp, e ->
            if (e == null && resp != null && resp.status in 200..299) resp else null
        }
    }

    CompletableFuture.allOf(*tasks.map { it.second }.toTypedArray()).join()
    return tasks.associate { (id, f) -> id to f.join() }.filterValues { it != null }
        .mapValues { (_, v) -> v!! }
}