package org.exploit.keeper.extension

import org.bouncycastle.math.ec.ECPoint
import org.exploit.keeper.model.common.PointDto
import org.exploit.keeper.model.frost.FrostCommitmentDto
import org.exploit.keeper.model.gg20.commitment.ChaumPedersonProofDto
import org.exploit.keeper.model.gg20.commitment.GG20ChaumPedersonCommitmentDto
import org.exploit.keeper.model.gg20.mta.MtAInitiatorMessageDto
import org.exploit.keeper.model.gg20.mta.MtAResultDto
import org.exploit.keeper.model.gg20.mta.ZKSetupDto
import org.exploit.keeper.model.gg20.paillier.PaillierPublicKeyDto
import org.exploit.keeper.model.gg20.paillier.PaillierRangeProofDto
import org.exploit.keeper.model.gg20.paillier.PaillierRespondentProofDto
import org.exploit.threshield.curve.PointOps
import org.exploit.threshield.curve.jce.ECPointOps
import org.exploit.threshield.ecdsa.commitment.ChaumPedersenProof
import org.exploit.threshield.ecdsa.commitment.ChaumPedersonCommitment
import org.exploit.threshield.ecdsa.commitment.ChaumPedersonCommitmentWithValue
import org.exploit.threshield.frost.model.ParticipantCommitment
import org.exploit.zktrust.cipher.key.PaillierPublicKey
import org.exploit.zktrust.mta.model.MtAInitiatorMessage
import org.exploit.zktrust.mta.model.MtAResult
import org.exploit.zktrust.proof.pallier.model.ZKSetup
import org.exploit.zktrust.proof.pallier.model.proof.PaillierRangeProof
import org.exploit.zktrust.proof.pallier.model.proof.PaillierRespondentProof

fun <P : PointOps<P>> ParticipantCommitment<P>.dto(): FrostCommitmentDto {
    return FrostCommitmentDto(
        D64 = D.encode(true).toBase64(),
        E64 = E.encode(true).toBase64(),
        Y64 = Y_i.encode(true).toBase64(),
    )
}

fun ChaumPedersenProof.dto() = ChaumPedersonProofDto(
    A = a.dto(),
    r = r,
    s = s
)

fun ChaumPedersonCommitment.dto() = GG20ChaumPedersonCommitmentDto(
    tpoint = T.dto(),
    t = t,
    proof = proof.dto()
)

fun ChaumPedersonCommitmentWithValue.dto() = GG20ChaumPedersonCommitmentDto(
    tpoint = commitment.T.dto(),
    t = commitment.t,
    proof = commitment.proof.dto(),
    value = value.dto()
)

fun PaillierRespondentProof.dto() = PaillierRespondentProofDto(
    z64 = z.toBase64(),
    zPrime64 = zPrime.toBase64(),
    t64 = t.toBase64(),
    v64 = v.toBase64(),
    w64 = w.toBase64(),
    s64 = s.toBase64(),
    s1 = s1,
    s2 = s2,
    t1 = t1,
    t2 = t2
)

fun PaillierRangeProof.dto() = PaillierRangeProofDto(
    z64 = z.toBase64(),
    u64 = u.toBase64(),
    w64 = w.toBase64(),
    s64 = s.toBase64(),
    s1 = s1,
    s2 = s2
)

fun ZKSetup.dto() = ZKSetupDto(hatN, h1, h2)

fun PaillierPublicKey.dto() = PaillierPublicKeyDto(n(), g(), bitLength())

fun MtAInitiatorMessage.dto() = MtAInitiatorMessageDto(
    cA = cA,
    proof = proof.dto()
)

fun ECPointOps.dto() = PointDto(x, y)

fun ECPoint.dto() = PointDto(affineXCoord.toBigInteger(), affineYCoord.toBigInteger())

fun MtAResult.dto() = MtAResultDto(c = c_j, y = y, r = r, proofDto = proof?.dto())