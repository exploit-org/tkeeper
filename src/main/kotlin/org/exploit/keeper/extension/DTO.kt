package org.exploit.keeper.extension

import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.OperationsDto
import org.exploit.keeper.model.frost.FrostCommitmentDto
import org.exploit.keeper.model.gg20.commitment.ChaumPedersonProofDto
import org.exploit.keeper.model.gg20.commitment.GG20ChaumPedersonCommitmentDto
import org.exploit.keeper.model.gg20.mta.MtAInitiatorMessageDto
import org.exploit.keeper.model.gg20.mta.MtAResultDto
import org.exploit.keeper.model.gg20.mta.ZKSetupDto
import org.exploit.keeper.model.gg20.paillier.PaillierPublicKeyDto
import org.exploit.keeper.model.gg20.paillier.PaillierRangeProofDto
import org.exploit.keeper.model.gg20.paillier.PaillierRespondentProofDto
import org.exploit.tss.curve.PointOps
import org.exploit.tss.ecdsa.commitment.ChaumPedersenProof
import org.exploit.tss.ecdsa.commitment.ChaumPedersonCommitment
import org.exploit.tss.ecdsa.commitment.ChaumPedersonCommitmentWithValue
import org.exploit.tss.frost.model.ParticipantCommitment
import org.exploit.tss.mta.model.MtAInitiatorMessage
import org.exploit.tss.mta.model.MtAResult
import org.exploit.tss.pallier.key.PaillierPublicKey
import org.exploit.tss.proof.model.PaillierRangeProof
import org.exploit.tss.proof.model.PaillierRespondentProof
import org.exploit.tss.proof.model.ZKSetup

fun OperationsDto.unwrap(): Operations =
    Operations(values = values64.mapValues { it.value.decodeBase64() },)

fun <P : PointOps<P>> ParticipantCommitment<P>.dto(): FrostCommitmentDto {
    return FrostCommitmentDto(
        D64 = D.encode(true).toBase64(),
        E64 = E.encode(true).toBase64(),
        Y64 = Y_i.encode(true).toBase64(),
    )
}

fun ChaumPedersenProof<*>.dto() = ChaumPedersonProofDto(
    A64 = a.encode(true).toBase64(),
    r = r,
    s = s
)

fun ChaumPedersonCommitment<*>.dto() = GG20ChaumPedersonCommitmentDto(
    tpoint64 = T.encode(true).toBase64(),
    t = t,
    proof = proof.dto()
)

fun ChaumPedersonCommitmentWithValue<*>.dto() = GG20ChaumPedersonCommitmentDto(
    tpoint64 = commitment.T.encode(true).toBase64(),
    t = commitment.t,
    proof = commitment.proof.dto(),
    value64 = value.encode(true).toBase64()
)

fun PaillierRespondentProof.dto() = PaillierRespondentProofDto(
    z64 = z.toBase64(),
    zPrime64 = zPrime.toBase64(),
    t64 = t.toBase64(),
    v64 = v.toBase64(),
    w64 = w.toBase64(),
    s64 = s.toBase64(),
    s1 = s1,
    s2 = s2,
    t1 = t1,
    t2 = t2
)

fun PaillierRangeProof.dto() = PaillierRangeProofDto(
    z64 = z.toBase64(),
    u64 = u.toBase64(),
    w64 = w.toBase64(),
    s64 = s.toBase64(),
    s1 = s1,
    s2 = s2
)

fun ZKSetup.dto() = ZKSetupDto(hatN, h1, h2)

fun PaillierPublicKey.dto() = PaillierPublicKeyDto(n(), g(), bitLength())

fun MtAInitiatorMessage.dto() = MtAInitiatorMessageDto(
    cA = cA,
    proof = proof.dto()
)

fun MtAResult.dto() = MtAResultDto(c = c_j, y = y, r = r, proofDto = proof?.dto())