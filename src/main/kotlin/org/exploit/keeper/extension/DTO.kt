package org.exploit.keeper.extension

import org.exploit.ecies.model.PartialDecrypt
import org.exploit.keeper.extension.crypto.decodeBase64
import org.exploit.keeper.model.Operations
import org.exploit.keeper.model.common.OperationsDto
import org.exploit.keeper.model.ecies.PartiallyDecrypted
import org.exploit.keeper.model.ecies.dleq.DleqProofDto
import org.exploit.keeper.model.frost.FrostCommitmentDto
import org.exploit.keeper.model.gg20.commitment.ChaumPedersonProofDto
import org.exploit.keeper.model.gg20.commitment.GG20ChaumPedersonCommitmentDto
import org.exploit.keeper.model.gg20.mta.MtAInitiatorMessageDto
import org.exploit.keeper.model.gg20.mta.MtAResultDto
import org.exploit.keeper.model.gg20.mta.ZKSetupDto
import org.exploit.keeper.model.gg20.paillier.PaillierPublicKeyDto
import org.exploit.keeper.model.gg20.paillier.PaillierRespondentProofDto
import org.exploit.tss.curve.PointOps
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitment
import org.exploit.tss.ecdsa.commitment.ChaumPedersenCommitmentWithValue
import org.exploit.tss.frost.model.ParticipantCommitment
import org.exploit.tss.mta.model.MtAInitiatorMessage
import org.exploit.tss.mta.model.MtAResult
import org.exploit.tss.pallier.key.PaillierPublicKey
import org.exploit.tss.proof.model.ChaumPedersenProof
import org.exploit.tss.proof.model.DleqProof
import org.exploit.tss.proof.model.PaillierRespondentProof
import org.exploit.tss.proof.model.ZKSetup

fun OperationsDto.unwrap(): Operations =
    Operations(values = values64.mapValues { it.value.decodeBase64() },)

fun <P : PointOps<P>> ParticipantCommitment<P>.dto(): FrostCommitmentDto {
    return FrostCommitmentDto(
        d = D.encode(true),
        e = E.encode(true),
        y = Y_i.encode(true),
        r = R.encode(true),
        sigma = sigma
    )
}

fun ChaumPedersenProof<*>.dto() = ChaumPedersonProofDto(
    a = A.encode(true),
    r = r,
    s = s
)

fun ChaumPedersenCommitment<*>.dto() = GG20ChaumPedersonCommitmentDto(
    tpoint = T.encode(true),
    proof = proof.dto()
)

fun ChaumPedersenCommitmentWithValue<*>.dto() = GG20ChaumPedersonCommitmentDto(
    tpoint = commitment.T.encode(true),
    proof = commitment.proof.dto(),
    value = value.encode(true)
)

fun PaillierRespondentProof.dto() = PaillierRespondentProofDto(
    z = z,
    zprime = zPrime,
    t = t,
    v = v,
    w = w,
    s = s,
    s1 = s1,
    s2 = s2,
    t1 = t1,
    t2 = t2
)

fun ZKSetup.dto() = ZKSetupDto(hatN, h1, h2)

fun PaillierPublicKey.dto() = PaillierPublicKeyDto(n(), g(), bitLength())

fun MtAInitiatorMessage.dto() = MtAInitiatorMessageDto(
    cA = cA,
    proof = proof,
    biPrimeProof = biPrimeProof,
    factorProof = factorProof
)

fun MtAResult.dto() = MtAResultDto(c = c_j, y = y, r = r, proofDto = proof?.dto())

fun DleqProof<*>.dto() = DleqProofDto(
    a1 = a1.encode(true),
    a2 = a2.encode(true),
    r = r
)

fun PartialDecrypt<*>.dto() = PartiallyDecrypted(
    peerId = idx,
    di = this.di,
    yi = Yi().encode(true),
    proof = proof.dto()
)