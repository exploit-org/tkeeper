package org.exploit.keeper.extension

import com.fasterxml.jackson.core.StreamReadConstraints
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.registerKotlinModule
import org.exploit.crypto.key.ECPublicKey
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey
import org.exploit.keeper.constant.CurveName
import org.exploit.keeper.util.KeySerializer
import java.util.function.Function

fun <T, R> T.then(block: (T) -> R): R {
    return block(this)
}

fun jackson(): ObjectMapper = jacksonObjectMapper().registerKotlinModule().apply {
    factory.setStreamReadConstraints(StreamReadConstraints.builder()
        .maxNumberLength(2000)
        .build()
    )
}

fun decodePublicKey(curve: CurveName, bytes: ByteArray): ECPublicKey = when(curve) {
    CurveName.SECP256K1 -> if (bytes.size == 33)
        Secp256k1PublicKey.fromCompressed(bytes)
    else
        Secp256k1PublicKey.create(bytes)

    CurveName.ED25519 -> Ed25519PublicKey(bytes)
}

fun ByteArray.toPrivateKey() = KeySerializer.deserialize(this)

fun <T> ByteArray.use(function: Function<ByteArray, T>): T {
    try {
        return function.apply(this)
    } finally {
        this.fill(0)
    }
}