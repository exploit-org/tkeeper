package org.exploit.keeper.extension.crypto

import org.exploit.crypto.key.ECPublicKey
import org.exploit.crypto.key.ed25519.Ed25519PublicKey
import org.exploit.crypto.key.secp256k1.Secp256k1PublicKey
import org.exploit.keeper.constant.crypto.CurveName
import org.exploit.tss.signature.SchnorrSignature

fun ByteArray.toSchnorrSignature(): SchnorrSignature {
    if (this.size != 64) {
        throw IllegalArgumentException("Invalid signature size: ${this.size}, expected 64 bytes")
    }

    val r = this.copyOfRange(0, 32)
    val s = this.copyOfRange(32, 64)

    return SchnorrSignature(r, s)
}

fun decodePublicKey(curve: CurveName, bytes: ByteArray): ECPublicKey<*> = when(curve) {
    CurveName.SECP256K1 -> if (bytes.size == 33)
        Secp256k1PublicKey.fromCompressed(bytes)
    else
        Secp256k1PublicKey.create(bytes)

    CurveName.ED25519 -> Ed25519PublicKey(bytes)
}
