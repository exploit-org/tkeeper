package org.exploit.keeper.datatype

import java.io.Closeable
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.Executors
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicLong

class InMemoryTemporaryMap<K, V>(expirationTime: Long, timeUnit: TimeUnit) : TemporaryMap<K, V>, Closeable {
    private val map = ConcurrentHashMap<K, ExpiringValue<V>>()
    private val expirationTimeMillis = timeUnit.toMillis(expirationTime)
    private val cleaner: ScheduledExecutorService = Executors.newSingleThreadScheduledExecutor()

    init {
        cleaner.scheduleAtFixedRate(
            { cleanExpired() }, expirationTimeMillis, expirationTimeMillis, TimeUnit.MILLISECONDS
        )
    }

    override fun put(key: K, value: V) {
        map[key] = ExpiringValue(value)
    }

    override fun get(key: K): V? {
        return map[key]?.getValue()
    }

    override fun remove(key: K): V? {
        return map.remove(key)?.getValue()
    }

    override fun containsKey(key: K): Boolean {
        return map.containsKey(key)
    }

    private fun cleanExpired() {
        val now = System.currentTimeMillis()

        map.keys.forEach { key ->
            val expValue = map[key]
            if (expValue != null && now - expValue.getLastAccessTime() > expirationTimeMillis) {
                map.remove(key)
            }
        }
    }

    override fun close() {
        cleaner.shutdown()
    }

    private class ExpiringValue<V>(private val value: V) {
        private val lastAccessTime = AtomicLong(System.currentTimeMillis())

        fun getValue(): V {
            lastAccessTime.set(System.currentTimeMillis())
            return value
        }

        fun getLastAccessTime(): Long {
            return lastAccessTime.get()
        }
    }
}
