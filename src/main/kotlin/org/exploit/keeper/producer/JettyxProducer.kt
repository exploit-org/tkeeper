package org.exploit.keeper.producer

import com.fasterxml.jackson.databind.ObjectMapper
import jakarta.enterprise.inject.Produces
import jakarta.inject.Singleton
import org.eclipse.jetty.util.ssl.SslContextFactory
import org.exploit.jettyx.Jettyx
import org.exploit.jettyx.http2.Http2Version
import org.exploit.jettyx.jackson.JacksonHttpMapper
import org.exploit.keeper.api.auth.KeeperAuthenticator
import org.exploit.keeper.api.client.TKeeperClient
import org.exploit.keeper.config.KeeperConfig
import org.exploit.keeper.db.RocksKeyDB
import java.util.concurrent.Executors

@Singleton
class JettyxProducer(
    private val config: KeeperConfig,
    private val objectMapper: ObjectMapper
) {
    @Produces
    @Singleton
    fun jettyx(): Jettyx {
        val builder = Jettyx.newBuilder()
            .enableVersion(Http2Version())
            .addHttpMapper(JacksonHttpMapper.create(objectMapper))
            .executor(Executors.newWorkStealingPool(config.parallelism()))

        if (config.ssl().enabled()) {
            val sslContext = SslContextFactory.Client()
            sslContext.trustStorePath = config.ssl().trustStorePath() ?: throw IllegalArgumentException("keeper.ssl.trust-store-path must be set while keeper.ssl.enabled is set to true")
            sslContext.setTrustStorePassword(config.ssl().trustStorePassword() ?: throw IllegalArgumentException("keeper.ssl.trust-store-password must be set while keeper.ssl.enabled is set to true"))
        }

        return builder.build()
    }

    @Produces
    @Singleton
    fun authenticator(db: RocksKeyDB): KeeperAuthenticator {
        return KeeperAuthenticator(db)
    }

    @Produces
    @Singleton
    fun clients(jettyx: Jettyx, authenticator: KeeperAuthenticator): List<TKeeperClient> =
        config.peers().map { peer ->
            TKeeperClient(
                peerId = peer.id(),
                auth = authenticator,
                url = peer.publicUrl(),
                jettyx = jettyx
            )
        }
}