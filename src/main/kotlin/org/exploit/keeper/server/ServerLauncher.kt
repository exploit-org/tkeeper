package org.exploit.keeper.server

import com.fasterxml.jackson.databind.ObjectMapper
import com.linecorp.armeria.common.HttpHeaderNames
import com.linecorp.armeria.common.HttpResponse
import com.linecorp.armeria.common.HttpStatus
import com.linecorp.armeria.common.logging.HeadersSanitizer
import com.linecorp.armeria.common.logging.LogFormatter
import com.linecorp.armeria.common.logging.LogLevel
import com.linecorp.armeria.common.logging.LogWriter
import com.linecorp.armeria.common.util.Sampler
import com.linecorp.armeria.server.DecoratingHttpServiceFunction
import com.linecorp.armeria.server.Route
import com.linecorp.armeria.server.Server
import com.linecorp.armeria.server.ServerBuilder
import com.linecorp.armeria.server.logging.LoggingService
import jakarta.inject.Singleton
import org.exploit.keeper.config.dev.DevConfig
import org.exploit.keeper.config.keeper.KeeperConfig
import org.exploit.keeper.config.keeper.KeeperServerConfig
import org.exploit.keeper.controller.KeeperController
import org.exploit.keeper.controller.external.ExternalController
import org.exploit.keeper.controller.internal.InternalController
import org.exploit.keeper.controller.support.ControllerSupport
import org.exploit.keeper.extension.messagePackMapper
import org.exploit.keeper.extension.objectMapper
import org.exploit.keeper.service.audit.AuditContextService
import org.exploit.keeper.service.audit.AuditService
import org.exploit.keeper.service.audit.decorator.AuditStartDecorator
import org.exploit.keeper.service.auth.decorator.ExternalAuthDecorator
import org.exploit.keeper.service.auth.external.DevMachineAuthenticator
import org.exploit.keeper.service.auth.external.JwtMachineAuthenticator
import org.exploit.keeper.service.auth.internal.InternalAuthenticator
import org.exploit.keeper.service.core.KeeperService
import org.exploit.keeper.service.exception.KeeperExceptionHandler
import org.slf4j.LoggerFactory
import java.net.InetSocketAddress
import java.util.*
import java.util.concurrent.CompletableFuture

@Singleton
class ServerLauncher(
    private val support: ControllerSupport,
    private val audit: AuditService,
    private val devConfig: Optional<DevConfig>,
    private val keeper: KeeperService,
    private val keeperConfig: KeeperConfig,
    private val auditCtx: AuditContextService,
    private val internalAuth: InternalAuthenticator,
    private val externalAuth: ExternalAuthDecorator,
    private val externalControllers: List<ExternalController>,
    private val internalControllers: List<InternalController>,
    private val tlsConfig: ServerTLSConfigurer
) {
    private val log = LoggerFactory.getLogger(ServerLauncher::class.java)

    @Volatile
    private var publicServer: Server? = null

    @Volatile
    private var internalServer: Server? = null

    fun start() {
        val start = System.currentTimeMillis()

        val pub = buildServer(
            cfg = keeperConfig.servers.public,
            mapper = objectMapper,
            authDecorator = externalAuth,
            controllers = externalControllers
        )

        val inl = buildServer(
            cfg = keeperConfig.servers.internal,
            mapper = messagePackMapper,
            authDecorator = internalAuth,
            controllers = internalControllers
        )

        publicServer = pub
        internalServer = inl

        CompletableFuture.allOf(pub.start(), inl.start()).join()

        log.info("Public server on port {}", pub.activeLocalPort())
        log.info("Internal server on port {}", inl.activeLocalPort())

        log.info("Servers started in {} ms", System.currentTimeMillis() - start)
    }

    fun stop() {
        try { publicServer?.stop()?.join() } catch (_: Exception) {}
        try { internalServer?.stop()?.join() } catch (_: Exception) {}
    }

    fun blockUntilShutdown() {
        publicServer?.whenClosed()?.join()
        internalServer?.whenClosed()?.join()
    }

    private fun buildServer(
        cfg: KeeperServerConfig,
        mapper: ObjectMapper,
        authDecorator: DecoratingHttpServiceFunction,
        controllers: List<KeeperController>
    ): Server {
        val sb = Server.builder()
            .disableServerHeader()
            .disableDateHeader()

        applyNetwork(sb, cfg)
        applyCommon(sb, cfg)

        val headersSanitizer = HeadersSanitizer.builderForText()
            .sensitiveHeaders(SANITIZE_HEADERS)
            .sensitiveHeaders(HttpHeaderNames.AUTHORIZATION, HttpHeaderNames.PROXY_AUTHORIZATION)
            .build()

        val logFormatter = LogFormatter.builderForText()
            .requestHeadersSanitizer(headersSanitizer)
            .responseHeadersSanitizer(headersSanitizer)
            .build()

        val logWriter = LogWriter.builder()
            .logger("tk.server")
            .logFormatter(logFormatter)
            .successfulResponseLogLevel(LogLevel.OFF)
            .failureResponseLogLevel(LogLevel.OFF)
            .responseLogLevel(HttpStatus.INTERNAL_SERVER_ERROR, LogLevel.ERROR)
            .build()

        val exceptionHandler = KeeperExceptionHandler(support, mapper)

        sb.errorHandler(exceptionHandler)
        sb.decorator(authDecorator)
        checkDevMode()
        sb.decorator(AuditStartDecorator(support, mapper, audit, keeper, keeperConfig, auditCtx))
        sb.decorator(exceptionHandler)

        sb.decorator(
            LoggingService.builder()
                .logWriter(logWriter)
                .successSampler(Sampler.always())
                .failureSampler(Sampler.always())
                .newDecorator()
        )

        controllers.forEach { it.register(sb) }

        sb.service(Route.ofCatchAll()) { _, _ ->
            HttpResponse.of(HttpStatus.NOT_FOUND)
        }

        return sb.build()
    }

    private fun checkDevMode() {
        val devMode = System.getProperty("keeper.dev.enabled")
            ?.toBoolean()
            ?: false

        if (!devMode) return

        if (devConfig.isEmpty) {
            error("Dev mode is enabled, but config not provided. Specify -Dkeeper.dev.config.location flag.")
        }

        log.warn("Server is configured in dev mode.")
    }

    private fun applyCommon(sb: ServerBuilder, cfg: KeeperServerConfig) {
        sb.maxRequestLength(cfg.maxRequestLength)
        sb.idleTimeout(cfg.idleTimeout)
    }

    private fun applyNetwork(sb: ServerBuilder, cfg: KeeperServerConfig) {
        val tls = cfg.tls
        if (tls?.enabled == true) {
            sb.https(InetSocketAddress(cfg.host, cfg.port))

            val hasPem = !tls.certificateChainPath.isNullOrBlank() && !tls.privateKeyPath.isNullOrBlank()
            val hasKs = !tls.keyStorePath.isNullOrBlank()

            when {
                hasPem -> tlsConfig.applyPem(sb, tls)
                hasKs -> tlsConfig.applyKsTLS(sb, tls)

                else -> error("TLS enabled, but neither PEM nor keystore provided")
            }
        } else {
            sb.http(InetSocketAddress(cfg.host, cfg.port))
        }
    }

    private companion object {
        val SANITIZE_HEADERS = listOf(DevMachineAuthenticator.Companion.DEV_TOKEN_HEADER, JwtMachineAuthenticator.Companion.REQUEST_HEADER)
    }
}