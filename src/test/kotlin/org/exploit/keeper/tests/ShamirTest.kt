package org.exploit.keeper.tests

import org.exploit.gmp.BigInt
import org.exploit.keeper.loadNativeLibraries
import org.exploit.keeper.util.crypto.Shamir
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertDoesNotThrow
import java.security.SecureRandom

class ShamirTest {
    private val rnd = SecureRandom()

    @BeforeEach
    fun prepare() {
        loadNativeLibraries()
    }

    private fun randomBytes(len: Int, rnd: SecureRandom): ByteArray =
        ByteArray(len).also { rnd.nextBytes(it) }

    private fun randomBytesNoLeadingZero(len: Int, rnd: SecureRandom): ByteArray {
        while (true) {
            val b = randomBytes(len, rnd)
            if (b.isNotEmpty() && b[0] != 0.toByte()) return b
        }
    }

    private fun combineToFixedSize(shares: List<Shamir.Share>, size: Int): ByteArray {
        val raw = Shamir.combine(shares)
        require(raw.size <= size) { "Recovered secret too large: ${raw.size} bytes > $size" }

        val out = ByteArray(size)
        System.arraycopy(raw, 0, out, size - raw.size, raw.size)
        return out
    }

    @Test
    fun splitAndCombine_recoversOriginal_forManyRandomKeys_noLeadingZero() {
        val rnd = SecureRandom()

        val iterations = 5_000
        val n = 5
        val k = 3

        repeat(iterations) {
            val secret = randomBytesNoLeadingZero(32, rnd)
            val shares = Shamir.split(secret, n, k)
            val picked = shares.shuffled(rnd).take(k)

            val recovered = Shamir.combine(picked)
            assertArrayEquals(secret, recovered, "Mismatch at iteration $it")
        }
    }

    @Test
    fun splitAndCombine_fixedSize32_recoversEvenWhenLeadingZero() {
        val iterations = 5_000
        val n = 5
        val k = 3

        repeat(iterations) {
            val secret = randomBytes(32, rnd)
            val shares = Shamir.split(secret, n, k)
            val picked = shares.shuffled(rnd).take(k)

            val recovered32 = Shamir.combine(picked)
            assertArrayEquals(secret, recovered32, "Mismatch at iteration $it")
        }
    }

    @Test
    fun splitAndCombine_worksForAnyKofNSubset() {
        val n = 8
        val k = 5
        val secret = randomBytesNoLeadingZero(32, rnd)

        val shares = Shamir.split(secret, n, k)

        repeat(200) { i ->
            val picked = shares.shuffled(rnd).take(k)
            val recovered = Shamir.combine(picked)
            assertArrayEquals(secret, recovered, "Mismatch on subset round $i")
        }
    }

    @Test
    fun encodeDecode_roundTrip_keepsSharesValid() {

        val n = 7
        val k = 4
        val secret = randomBytesNoLeadingZero(32, rnd)

        val shares = Shamir.split(secret, n, k)
        val encoded = Shamir.encodeShares(shares)
        val decoded = Shamir.decodeShares(encoded)

        val recovered = Shamir.combine(decoded.shuffled(rnd).take(k))
        assertArrayEquals(secret, recovered)
    }

    @Test
    fun combine_throwsOnDuplicateX() {
        val shares = Shamir.split(randomBytesNoLeadingZero(32, rnd), n = 5, k = 3)

        val dup = listOf(shares[0], shares[0], shares[1])
        assertThrows(IllegalArgumentException::class.java) {
            Shamir.combine(dup)
        }
    }

    @Test
    fun combine_isOrderIndependent() {
        val n = 6
        val k = 3
        val secret = randomBytesNoLeadingZero(32, rnd)
        val shares = Shamir.split(secret, n, k)

        val picked = shares.take(k)
        val a = Shamir.combine(picked)
        val b = Shamir.combine(picked.reversed())

        assertArrayEquals(a, b)
        assertArrayEquals(secret, a)
    }

    @Test
    fun combine_doesNotThrow_inStressLoop() {
        val iterations = 10_000
        val n = 10
        val k = 6

        repeat(iterations) { i ->
            val secret = randomBytesNoLeadingZero(32, rnd)
            val shares = Shamir.split(secret, n, k)
            val picked = shares.shuffled(rnd).take(k)

            assertDoesNotThrow("Threw at iteration $i") {
                Shamir.combine(picked)
            }
        }
    }

    @Test
    fun combine_withMixedPrimes_shouldNotMatchOriginal() {
        val n = 5
        val k = 3
        val secret = randomBytesNoLeadingZero(32, rnd)
        val shares = Shamir.split(secret, n, k).toMutableList()

        val badPrime = shares[0].prime.add(BigInt.ONE)
        shares[0] = Shamir.Share(shares[0].x, shares[0].y, badPrime)

        val recovered = try {
            Shamir.combine(shares.take(k))
        } catch (_: Exception) {
            null
        }

        if (recovered != null) {
            assertFalse(secret.contentEquals(recovered))
        } else {
            assertTrue(true)
        }
    }
}