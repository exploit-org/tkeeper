package org.exploit.keeper.tests

import org.exploit.ed25519.Ed25519CurveParams
import org.exploit.gmp.BigInt
import org.exploit.keeper.loadNativeLibraries
import org.exploit.keeper.service.dkg.generator.NodeKeyGen
import org.exploit.secp256k1.Secp256k1CurveParams
import org.exploit.tss.curve.EllipticCurveParams
import org.exploit.tss.curve.PointOps
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

class NodeKeyGenTest {
    @BeforeEach
    fun prepare() {
        loadNativeLibraries()
    }

    @Test
    fun secp256k1_generatesSharesThatVerifyAgainstCommitments() {
        verifiesSharesAgainstCommitments(Secp256k1CurveParams(), n = 5, t = 3, zeroConst = false)
    }

    @Test
    fun ed25519_generatesSharesThatVerifyAgainstCommitments() {
        verifiesSharesAgainstCommitments(Ed25519CurveParams(), n = 5, t = 3, zeroConst = false)
    }

    @Test
    fun secp256k1_rejectsModifiedShare() {
        rejectsModifiedShare(Secp256k1CurveParams(), n = 6, t = 4, zeroConst = false)
    }

    @Test
    fun ed25519_rejectsModifiedShare() {
        rejectsModifiedShare(Ed25519CurveParams(), n = 6, t = 4, zeroConst = false)
    }

    @Test
    fun secp256k1_rejectsShareAgainstCommitmentsFromOtherGenerator() {
        rejectsShareAgainstCommitmentsFromOtherGenerator(Secp256k1CurveParams(), n = 7, t = 4, zeroConst = false)
    }

    @Test
    fun ed25519_rejectsShareAgainstCommitmentsFromOtherGenerator() {
        rejectsShareAgainstCommitmentsFromOtherGenerator(Ed25519CurveParams(), n = 7, t = 4, zeroConst = false)
    }

    @Test
    fun secp256k1_refreshMaskPreservesAggregatedPublicKeyAndRotatesShares() {
        refreshMaskPreservesAggregatedPublicKeyAndRotatesShares(Secp256k1CurveParams(), n = 7, t = 4, nodes = 3)
    }

    @Test
    fun ed25519_refreshMaskPreservesAggregatedPublicKeyAndRotatesShares() {
        refreshMaskPreservesAggregatedPublicKeyAndRotatesShares(Ed25519CurveParams(), n = 7, t = 4, nodes = 3)
    }

    @Test
    fun secp256k1_aggregatedSharesVerifyAgainstAggregatedCommitments() {
        aggregatedSharesVerifyAgainstAggregatedCommitments(Secp256k1CurveParams(), n = 8, t = 5, nodes = 4, zeroConst = false)
    }

    @Test
    fun ed25519_aggregatedSharesVerifyAgainstAggregatedCommitments() {
        aggregatedSharesVerifyAgainstAggregatedCommitments(Ed25519CurveParams(), n = 8, t = 5, nodes = 4, zeroConst = false)
    }

    private fun <P : PointOps<P>> verifiesSharesAgainstCommitments(
        curve: EllipticCurveParams<P>,
        n: Int,
        t: Int,
        zeroConst: Boolean
    ) {
        val gen = NodeKeyGen(curve = curve, n = n, t = t, zeroConst = zeroConst)
        val commits = gen.commitments().map { it.encode(true) }

        for (idx in 1..n) {
            val share = gen.shareFor(idx)
            assertTrue(NodeKeyGen.verifyShare(curve, idx, share, commits, zeroConst))
        }

        gen.erase()
        assertThrows(IllegalStateException::class.java) { gen.commitments() }
    }

    private fun <P : PointOps<P>> rejectsModifiedShare(
        curve: EllipticCurveParams<P>,
        n: Int,
        t: Int,
        zeroConst: Boolean
    ) {
        val gen = NodeKeyGen(curve = curve, n = n, t = t, zeroConst = zeroConst)
        val commits = gen.commitments().map { it.encode(true) }
        val q = curve.curveOrder

        for (idx in 1..n) {
            val share = gen.shareFor(idx)
            val modified = share.add(BigInt.ONE).mod(q)
            assertFalse(NodeKeyGen.verifyShare(curve, idx, modified, commits, zeroConst))
        }

        gen.erase()
    }

    private fun <P : PointOps<P>> rejectsShareAgainstCommitmentsFromOtherGenerator(
        curve: EllipticCurveParams<P>,
        n: Int,
        t: Int,
        zeroConst: Boolean
    ) {
        val genA = NodeKeyGen(curve = curve, n = n, t = t, zeroConst = zeroConst)
        val genB = NodeKeyGen(curve = curve, n = n, t = t, zeroConst = zeroConst)

        val commitsA = genA.commitments().map { it.encode(true) }

        var rejected = false
        for (idx in 1..n) {
            val shareB = genB.shareFor(idx)
            if (!NodeKeyGen.verifyShare(curve, idx, shareB, commitsA, zeroConst)) {
                rejected = true
                break
            }
        }
        assertTrue(rejected)

        genA.erase()
        genB.erase()
    }

    private fun <P : PointOps<P>> aggregatedSharesVerifyAgainstAggregatedCommitments(
        curve: EllipticCurveParams<P>,
        n: Int,
        t: Int,
        nodes: Int,
        zeroConst: Boolean
    ) {
        val q = curve.curveOrder
        val gens = (1..nodes).map { NodeKeyGen(curve = curve, n = n, t = t, zeroConst = zeroConst) }

        val commitsByNode = gens.map { it.commitments() }
        val aggCommits = aggregateCommitments(curve, commitsByNode).map { it.encode(true) }

        for (idx in 1..n) {
            val shares = gens.map { it.shareFor(idx) }
            val aggShare = NodeKeyGen.aggregateShares(shares, q)
            assertTrue(NodeKeyGen.verifyShare(curve, idx, aggShare, aggCommits, zeroConst))
        }

        gens.forEach { it.erase() }
    }

    private fun <P : PointOps<P>> refreshMaskPreservesAggregatedPublicKeyAndRotatesShares(
        curve: EllipticCurveParams<P>,
        n: Int,
        t: Int,
        nodes: Int
    ) {
        val q = curve.curveOrder

        val baseGens = (1..nodes).map { NodeKeyGen(curve = curve, n = n, t = t, zeroConst = false) }
        val maskGens = (1..nodes).map { NodeKeyGen(curve = curve, n = n, t = t, zeroConst = true) }

        val baseCommitsByNode = baseGens.map { it.commitments() }
        val maskCommitsByNode = maskGens.map { it.commitments() }

        val baseAggCommits = aggregateCommitments(curve, baseCommitsByNode)
        val maskAggCommits = aggregateCommitments(curve, maskCommitsByNode)

        val refreshedAggCommits = (0 until t).map { k ->
            curve.infinity.add(baseAggCommits[k] as P).add(maskAggCommits[k] as P).normalize()
        }

        assertEquals(baseAggCommits[0].normalize(), refreshedAggCommits[0].normalize())

        var changedAtLeastOnce = false
        for (idx in 1..n) {
            val baseShares = baseGens.map { it.shareFor(idx) }
            val maskShares = maskGens.map { it.shareFor(idx) }

            val baseAggShare = NodeKeyGen.aggregateShares(baseShares, q)
            val maskAggShare = NodeKeyGen.aggregateShares(maskShares, q)

            val refreshedAggShare = baseAggShare.add(maskAggShare).mod(q)

            assertTrue(NodeKeyGen.verifyShare(curve, idx, refreshedAggShare, refreshedAggCommits.map { it.encode(true) }, zeroConst = false))

            if (!changedAtLeastOnce && baseAggShare != refreshedAggShare) {
                changedAtLeastOnce = true
            }
        }

        assertTrue(changedAtLeastOnce)

        baseGens.forEach { it.erase() }
        maskGens.forEach { it.erase() }
    }

    private fun <P : PointOps<P>> aggregateCommitments(
        curve: EllipticCurveParams<P>,
        commitsByNode: List<List<PointOps<P>>>
    ): List<PointOps<P>> {
        require(commitsByNode.isNotEmpty())
        val t = commitsByNode[0].size
        require(commitsByNode.all { it.size == t })

        return (0 until t).map { k ->
            var acc = curve.infinity
            for (nodeCommits in commitsByNode) {
                acc = acc.add(nodeCommits[k] as P)
            }
            acc.normalize()
        }
    }
}