package org.exploit.tkeeper.test

import org.exploit.tkeeper.sdk.exception.TKeeperException
import org.exploit.tkeeper.sdk.model.*
import org.exploit.tkeeper.test.compose.ComposeEnvironment
import org.exploit.tkeeper.test.compose.KeeperComposeFactory
import org.junit.jupiter.api.*
import org.testcontainers.junit.jupiter.Container
import org.testcontainers.junit.jupiter.Testcontainers
import kotlin.test.assertEquals
import kotlin.test.assertTrue

@Testcontainers
@TestMethodOrder(MethodOrderer.OrderAnnotation::class)
class KeyLifecycleTests : TKeeperComposeEnvironment() {
    override val env: ComposeEnvironment = dockerEnvironment

    private data class TestKey(val logicalId: String, val curve: CurveName)

    private val k1 by lazy { client(1) }
    private val knownPublicKeys: MutableMap<String, String> = HashMap()

    @Test
    @Order(1)
    fun generateTestKeys() {
        forEachKey { key ->
            assertDoesNotThrow { generate(key, KeyGenMode.CREATE) }
            knownPublicKeys[key.logicalId] = assertDoesNotThrow { publicKey64(key) }
        }
    }

    @Test
    @Order(2)
    fun refreshTestKeys() {
        forEachKey { key ->
            assertDoesNotThrow { generate(key, KeyGenMode.REFRESH) }
            val pk = assertDoesNotThrow { publicKey64(key) }
            assertEquals(knownPublicKeys[key.logicalId], pk)
        }
    }

    @Test
    @Order(3)
    fun rotateMultipleTimes() {
        repeat(3) {
            forEachKey { key ->
                assertDoesNotThrow { generate(key, KeyGenMode.ROTATE) }
            }
        }
    }

    @Test
    @Order(4)
    fun ensureSameGenerationSecp256k1AcrossKeepers() {
        assertSameGenerationAcrossKeepers(SECP256K1, expectedGeneration = 5)
    }

    @Test
    @Order(5)
    fun ensureSameGenerationEd25519AcrossKeepers() {
        assertSameGenerationAcrossKeepers(ED25519, expectedGeneration = 5)
    }

    @Test
    @Order(6)
    fun destroyActualGenerationFails() {
        forEachKey { key ->
            assertThrows<TKeeperException> {
                k1.destroy().destroy(KeyReference(key.logicalId, 5))
            }
        }
    }

    @Test
    @Order(7)
    fun destroyOldGenerationSucceeds() {
        forEachKey { key ->
            assertDoesNotThrow {
                k1.destroy().destroy(KeyReference(key.logicalId, 3))
            }
        }
    }

    @Test
    @Order(8)
    fun ensureDestroyedSecp256k1KeyGenerationOnAllKeepers() {
        assertDestroyedOnAllKeepers(SECP256K1, destroyedGeneration = 3)
    }

    @Test
    @Order(9)
    fun ensureDestroyedEd25519KeyGenerationOnAllKeepers() {
        assertDestroyedOnAllKeepers(ED25519, destroyedGeneration = 3)
    }

    @Test
    @Order(10)
    fun ensureNonActualExpired() {
        forEachKey { key ->
            assertNonActualExpiredOnAllKeepers(
                key = key,
                actualGeneration = 5,
                destroyedGeneration = 3
            )
        }
    }

    private fun generate(key: TestKey, mode: KeyGenMode) {
        k1.dkg().generate(Generate(key.logicalId, key.curve, mode))
    }

    private fun publicKey64(key: TestKey): String =
        k1.central().getPublicKey(key.logicalId).data64()

    private fun forEachKey(block: (TestKey) -> Unit) = TEST_KEYS.forEach(block)

    private fun assertSameGenerationAcrossKeepers(key: TestKey, expectedGeneration: Int) {
        val gens = PEERS.map { peerId ->
            inventoryOf(peerId, key.logicalId).first().currentGeneration()
        }

        assertEquals(gens.distinct().size, 1, "Generations differ across keepers: $gens")
        assertEquals(expectedGeneration, gens.first())
    }

    private fun assertDestroyedOnAllKeepers(key: TestKey, destroyedGeneration: Int) {
        PEERS.forEach { peerId ->
            val item = inventoryOf(peerId, key.logicalId, historical = true)
                .first { it.currentGeneration() == destroyedGeneration }

            assertEquals(KeyStatus.DESTROYED, item.status())
        }
    }

    private fun assertNonActualExpiredOnAllKeepers(key: TestKey, actualGeneration: Int, destroyedGeneration: Int) {
        PEERS.forEach { peerId ->
            val items = inventoryOf(peerId, key.logicalId, historical = true)
                .filter { it.currentGeneration() != actualGeneration && it.currentGeneration() != destroyedGeneration }

            assertTrue(
                items.all { it.status() == KeyStatus.APPLY_EXPIRED },
                "Not all non-actual generations are APPLY_EXPIRED for ${key.logicalId} on keeper-$peerId: " +
                        items.joinToString { "gen=${it.currentGeneration()} status=${it.status()}" }
            )
        }
    }

    private fun inventoryOf(peerId: Int, logicalId: String, historical: Boolean = false): List<AssetInventoryItem> =
        client(peerId).compliance()
            .inventory(logicalId, historical, null, 200)
            .inventory
            .items()

     companion object {
        @Container
        @JvmField
        val dockerEnvironment = KeeperComposeFactory.newEnv()

        const val SECP256K1_KEY = "dkg-secp256k1"
        const val ED25519_KEY = "dkg-ed25519"

        private val SECP256K1 = TestKey(SECP256K1_KEY, CurveName.SECP256K1)
        private val ED25519 = TestKey(ED25519_KEY, CurveName.ED25519)

        private val TEST_KEYS = listOf(SECP256K1, ED25519)

        val PEERS = listOf(1, 2, 3)
    }
}