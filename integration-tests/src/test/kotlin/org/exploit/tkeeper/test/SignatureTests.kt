package org.exploit.tkeeper.test

import org.exploit.tkeeper.sdk.model.*
import org.exploit.tkeeper.sdk.model.context.BIP340Context
import org.exploit.tkeeper.sdk.model.context.SignatureContext
import org.exploit.tkeeper.sdk.model.context.TaprootContext
import org.exploit.tkeeper.test.compose.ComposeEnvironment
import org.exploit.tkeeper.test.compose.KeeperComposeFactory
import org.junit.jupiter.api.*
import org.testcontainers.junit.jupiter.Container
import org.testcontainers.junit.jupiter.Testcontainers
import java.security.MessageDigest
import java.security.SecureRandom
import java.util.*
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

@Testcontainers
@TestMethodOrder(MethodOrderer.OrderAnnotation::class)
class SignatureTests : TKeeperComposeEnvironment() {
    override val env: ComposeEnvironment = dockerEnvironment

    @Test
    @Order(1)
    fun prepareKeys() {
        forEachKey { key ->
            assertDoesNotThrow { client(1).dkg().generate(Generate(key.logicalId, key.curve, KeyGenMode.CREATE)) }
        }
    }

    @Test
    @Order(2)
    fun testGG20Signature() {
        val msg = "Hello World!".toByteArray()
        val preHashed = b64(sha256(msg))
        val raw = b64(msg)

        val preHashedReq = Sign(SECP256K1.logicalId, SessionType.GG20, ops(OP_ID_1 to preHashed))
        val serverHashedReq = Sign(SECP256K1.logicalId, SessionType.GG20, ops(OP_ID_1 to raw), true)

        val resPreHashed = signOk(peer = 1, preHashedReq)
        val resServerHashed = signOk(peer = 2, serverHashedReq)

        verifyOk(peer = 3, Verify(SECP256K1.logicalId, resPreHashed.type, preHashed, sig(resPreHashed, OP_ID_1)))
        verifyOk(peer = 1, Verify(SECP256K1.logicalId, resServerHashed.type, raw, sig(resServerHashed, OP_ID_1), true))
    }

    @Test
    @Order(3)
    fun testEd25519FrostSignature() {
        signAndVerifyMultiOps(
            key = ED25519,
            sessionType = SessionType.FROST,
            ops = helloOps()
        )
    }

    @Test
    @Order(4)
    fun testSecp256k1FrostSignature() {
        signAndVerifyMultiOps(
            key = SECP256K1,
            sessionType = SessionType.FROST,
            ops = helloOps()
        )
    }

    @Test
    @Order(5)
    fun testSecp256k1FrostSignatureBIP340() {
        val context = BIP340Context()
        signAndVerifyMultiOps(
            key = SECP256K1,
            sessionType = SessionType.FROST,
            ops = helloOps(),
            context = context
        )
    }

    @Test
    @Order(6)
    fun testSecp256k1FrostSignatureTaproot() {
        val context = TaprootContext(randomMerkleRoot32())
        signAndVerifyMultiOps(
            key = SECP256K1,
            sessionType = SessionType.FROST,
            ops = helloOps(),
            context = context
        )
    }

    @Test
    @Order(7)
    fun testSecp256k1FrostSignatureTaprootEmptyMerkleRoot() {
        val context = TaprootContext(null)
        signAndVerifyMultiOps(
            key = SECP256K1,
            sessionType = SessionType.FROST,
            ops = helloOps(),
            context = context
        )
    }

    @Test
    @Order(8)
    fun testGG20SignatureWithTweak() {
        val tweak = SIGN_TWEAK

        val msg = "Hello World!".toByteArray()
        val preHashed = b64(sha256(msg))
        val raw = b64(msg)

        val preHashedReq = Sign(SECP256K1.logicalId, SessionType.GG20, ops(OP_ID_1 to preHashed))
            .withTweak(tweak)

        val serverHashedReq = Sign(SECP256K1.logicalId, SessionType.GG20, ops(OP_ID_1 to raw), true)
            .withTweak(tweak)

        val resPreHashed = signOk(peer = 1, preHashedReq)
        val resServerHashed = signOk(peer = 2, serverHashedReq)

        verifyOk(
            peer = 3,
            request = Verify(SECP256K1.logicalId, resPreHashed.type, preHashed, sig(resPreHashed, OP_ID_1))
                .withTweak(tweak)
        )

        verifyOk(
            peer = 1,
            request = Verify(SECP256K1.logicalId, resServerHashed.type, raw, sig(resServerHashed, OP_ID_1), true)
                .withTweak(tweak)
        )
    }

    @Test
    @Order(9)
    fun testEd25519FrostSignatureWithTweak() {
        signAndVerifyMultiOps(
            key = ED25519,
            sessionType = SessionType.FROST,
            ops = helloOps(),
            tweak = SIGN_TWEAK
        )
    }

    @Test
    @Order(10)
    fun testSecp256k1FrostSignatureWithTweak() {
        signAndVerifyMultiOps(
            key = SECP256K1,
            sessionType = SessionType.FROST,
            ops = helloOps(),
            tweak = SIGN_TWEAK
        )
    }

    @Test
    @Order(11)
    fun testSecp256k1FrostSignatureBIP340WithTweak() {
        val context = BIP340Context()
        signAndVerifyMultiOps(
            key = SECP256K1,
            sessionType = SessionType.FROST,
            ops = helloOps(),
            context = context,
            tweak = SIGN_TWEAK
        )
    }

    @Test
    @Order(12)
    fun testSecp256k1FrostSignatureTaprootWithTweak() {
        val context = TaprootContext(randomMerkleRoot32())
        signAndVerifyMultiOps(
            key = SECP256K1,
            sessionType = SessionType.FROST,
            ops = helloOps(),
            context = context,
            tweak = SIGN_TWEAK
        )
    }

    @Test
    @Order(13)
    fun testSecp256k1FrostSignatureTaprootEmptyMerkleRootWithTweak() {
        val context = TaprootContext(null)
        signAndVerifyMultiOps(
            key = SECP256K1,
            sessionType = SessionType.FROST,
            ops = helloOps(),
            context = context,
            tweak = SIGN_TWEAK
        )
    }

    @Test
    @Order(14)
    fun ensureParticipantVerificationPassesAfterRefresh() {
        forEachKey {
            assertDoesNotThrow {
                client(1).dkg().generate(Generate(it.logicalId, it.curve, KeyGenMode.REFRESH))
            }
        }

        testEd25519FrostSignature()
        testSecp256k1FrostSignature()
        testSecp256k1FrostSignatureTaproot()
        testSecp256k1FrostSignatureBIP340()
        testSecp256k1FrostSignatureTaprootEmptyMerkleRoot()
        testGG20SignatureWithTweak()
        testEd25519FrostSignatureWithTweak()
        testSecp256k1FrostSignatureWithTweak()
        testSecp256k1FrostSignatureTaprootWithTweak()
        testSecp256k1FrostSignatureBIP340WithTweak()
        testSecp256k1FrostSignatureTaprootEmptyMerkleRootWithTweak()
    }

    private fun signAndVerifyMultiOps(
        key: TestKey,
        sessionType: SessionType,
        ops: Map<String, String>,
        serverHash: Boolean = false,
        context: SignatureContext? = null,
        tweak: String? = null
    ) {
        val req = when (context) {
            null -> Sign(key.logicalId, sessionType, ops, serverHash)
            else -> Sign(key.logicalId, sessionType, ops, serverHash, context)
        }.withTweak(tweak)

        val result = signOk(peer = 1, req)

        ops.keys.forEachIndexed { idx, opId ->
            val verifierPeer = VERIFY_PEERS[idx % VERIFY_PEERS.size]
            val data = requireNotNull(ops[opId]) { "Missing data for opId=$opId" }
            val signature = sig(result, opId)

            val verifyReq = when (context) {
                null -> Verify(key.logicalId, result.type, data, signature, serverHash)
                    .withTweak(tweak)
                else -> Verify(key.logicalId, result.type, data, signature, context)
                    .withTweak(tweak)
            }

            verifyOk(peer = verifierPeer, verifyReq)
        }
    }

    private data class TestKey(val logicalId: String, val curve: CurveName)

    private fun forEachKey(block: (TestKey) -> Unit) = TEST_KEYS.forEach(block)

    private fun helloOps(): Map<String, String> = ops(
        OP_ID_1 to b64(sha256("Hello World!".toByteArray())),
        OP_ID_2 to b64(sha256("Hello Keeper!".toByteArray())),
    )

    private fun ops(vararg pairs: Pair<String, String>): Map<String, String> = mapOf(*pairs)

    private fun signOk(peer: Int, request: Sign): ThresholdSignature {
        val res = client(peer).signature().sign(request)
        assertEquals(TSSCode.SUCCESS, res.code())
        return res
    }

    private fun sig(result: ThresholdSignature, opId: String): String {
        return assertNotNull(result.signature()[opId])
    }

    private fun verifyOk(peer: Int, request: Verify) {
        assertTrue { client(peer).signature().verify(request).valid() }
    }

    private fun sha256(data: ByteArray): ByteArray =
        MessageDigest.getInstance("SHA-256").digest(data)

    private fun b64(data: ByteArray): String =
        Base64.getEncoder().encodeToString(data)

    private fun randomMerkleRoot32(): String {
        val bytes = ByteArray(32)
        SecureRandom().nextBytes(bytes)
        return b64(bytes)
    }

    companion object {
        @Container
        @JvmField
        val dockerEnvironment = KeeperComposeFactory.newEnv()

        const val SIGN_TWEAK = "user:2091029520/signature-suite-v1"
        const val OP_ID_1 = "op1"
        const val OP_ID_2 = "op2"

        private val SECP256K1 = TestKey("signature-secp256k1", CurveName.SECP256K1)
        private val ED25519 = TestKey("signature-ed25519", CurveName.ED25519)

        private val TEST_KEYS = listOf(SECP256K1, ED25519)
        val VERIFY_PEERS = listOf(2, 3)
    }
}