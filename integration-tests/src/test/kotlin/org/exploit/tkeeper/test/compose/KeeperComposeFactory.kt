package org.exploit.tkeeper.test.compose

import org.exploit.tkeeper.test.TKeeperComposeEnvironment
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.testcontainers.containers.ComposeContainer
import org.testcontainers.containers.DockerComposeContainer
import org.testcontainers.containers.output.Slf4jLogConsumer
import org.testcontainers.containers.wait.strategy.Wait
import java.io.File
import java.time.Duration
import java.util.concurrent.TimeUnit

object KeeperComposeFactory {
    private val logger: Logger = LoggerFactory.getLogger(TKeeperComposeEnvironment::class.java)
    private val composeFile = File(requireNotNull(System.getProperty("it.compose.file")))

    fun newEnv(): ComposeEnvironment {
        val services = listOf("keeper-1", "keeper-2", "keeper-3")
        val timeout = Duration.ofMinutes(5)
        val consumer = Slf4jLogConsumer(logger)

        val env: ComposeEnvironment = when {
            hasDockerComposeV1() -> wrapV1(
                DockerComposeContainer(composeFile)
            )

            hasDockerComposeV2() -> wrapV2(
                ComposeContainer(composeFile)
            )

            else -> throw IllegalStateException(
                "Docker Compose not found. Install Docker (with 'docker compose') or docker-compose."
            )
        }

        for (svc in services) {
            env.withLogs(svc, consumer)
            env.withExpose(svc, 8080, timeout)
        }

        return env
    }

    private fun ComposeEnvironment.withLogs(service: String, base: Slf4jLogConsumer) {
        when (this) {
            is V1Wrapper -> delegate
                .withTailChildContainers(true)
                .withLogConsumer(service, base.withPrefix(service))
            is V2Wrapper -> delegate
                .withTailChildContainers(true)
                .withLogConsumer(service, base.withPrefix(service))
        }
    }

    private fun ComposeEnvironment.withExpose(service: String, port: Int, timeout: Duration) {
        val wait = Wait.forListeningPort().withStartupTimeout(timeout)

        when (this) {
            is V1Wrapper -> delegate.withExposedService(service, port, wait)
            is V2Wrapper -> delegate.withExposedService(service, port, wait)
        }
    }

    private fun hasDockerComposeV1(): Boolean =
        canRun(listOf("docker-compose", "version"))

    private fun hasDockerComposeV2(): Boolean =
        canRun(listOf("docker", "compose", "version"))

    private fun canRun(cmd: List<String>): Boolean =
        try {
            val p = ProcessBuilder(cmd)
                .redirectErrorStream(true)
                .start()

            p.waitFor(3, TimeUnit.SECONDS) && p.exitValue() == 0
        } catch (_: Exception) {
            false
        }

    private fun wrapV1(c: DockerComposeContainer<*>): ComposeEnvironment = V1Wrapper(c)

    private fun wrapV2(c: ComposeContainer): ComposeEnvironment = V2Wrapper(c)

    private class V1Wrapper(val delegate: DockerComposeContainer<*>) : ComposeEnvironment {
        override fun start() = delegate.start()
        override fun stop() = delegate.stop()
        override fun close() = delegate.close()

        override fun getServiceHost(serviceName: String, servicePort: Int): String =
            delegate.getServiceHost(serviceName, servicePort)

        override fun getServicePort(serviceName: String, servicePort: Int): Int =
            delegate.getServicePort(serviceName, servicePort)
    }

    private class V2Wrapper(val delegate: ComposeContainer) : ComposeEnvironment {
        override fun start() = delegate.start()
        override fun stop() = delegate.stop()
        override fun close() = delegate.close()

        override fun getServiceHost(serviceName: String, servicePort: Int): String =
            delegate.getServiceHost(serviceName, servicePort)

        override fun getServicePort(serviceName: String, servicePort: Int): Int =
            delegate.getServicePort(serviceName, servicePort)
    }
}